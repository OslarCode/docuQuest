# Indices y planificador de consultas

## 1. Qu√© es un √≠ndice en una base de datos

Un **√≠ndice** es como un **√≠ndice alfab√©tico de un libro**:

- Sin √≠ndice: para encontrar algo tienes que **leer p√°gina por p√°gina**.
- Con √≠ndice: vas directamente a la secci√≥n donde est√° la informaci√≥n.

En SQLite:

- Un √≠ndice acelera la b√∫squeda, pero ocupa espacio adicional.
- Se actualiza autom√°ticamente cuando insertas, borras o modificas datos.
- No cambia el resultado de tus consultas: **solo mejora la velocidad**.

## 2. Creaci√≥n b√°sica de √≠ndices

Supongamos que tenemos esta tabla de pedidos:

```sql
CREATE TABLE orders (
  id INTEGER PRIMARY KEY,
  client_id INTEGER NOT NULL,
  total REAL NOT NULL,
  created_at TEXT NOT NULL
);

```

Si hacemos una consulta frecuente como:

```sql
SELECT * FROM orders WHERE client_id = 123;

```

SQLite, sin √≠ndices, tiene que **recorrer toda la tabla** para encontrar coincidencias.

üëâ Soluci√≥n:

```sql
CREATE INDEX IF NOT EXISTS idx_orders_client_id
ON orders(client_id);

```

Ahora SQLite usa el √≠ndice para saltar directamente a las filas que necesita.

Puedes listar todos los √≠ndices con:

```sql
.indexes orders

```

Y verlos en el esquema:

```sql
.schema orders

```

## 3. Ver c√≥mo SQLite ejecuta una consulta ‚Äî `EXPLAIN QUERY PLAN`

La herramienta m√°s importante para entender el rendimiento es:

```sql
EXPLAIN QUERY PLAN
SELECT * FROM orders WHERE client_id = 123;

```

Sin √≠ndice, ver√°s algo como:

```
SCAN TABLE orders

```

Esto significa que **lee toda la tabla** (table scan).

Con √≠ndice:

```
SEARCH TABLE orders USING INDEX idx_orders_client_id (client_id=?)

```

Ahora usa el √≠ndice para encontrar directamente los registros.

*Regla pr√°ctica*: si ves ‚ÄúSCAN TABLE‚Äù en una consulta que corre sobre una tabla grande, probablemente necesites un √≠ndice.

## 4. Cu√°ndo crear √≠ndices (y cu√°ndo no)

Crea un √≠ndice cuando:

- La columna aparece frecuentemente en condiciones `WHERE`.
- La columna se usa en `JOIN`.
- Se usa para ordenar (`ORDER BY`).
- Es una foreign key.

No crees un √≠ndice cuando:

- La tabla es muy peque√±a (no vale la pena).
- Es una columna que cambia constantemente (actualizaciones frecuentes ‚Üí sobrecarga innecesaria).
- No se usa en filtros ni joins.

**Cada √≠ndice adicional ralentiza las escrituras** un poco, porque SQLite debe mantenerlo actualizado.

Por eso se trata de **crear los necesarios, no todos**.

## 5. √çndices compuestos

Un **√≠ndice compuesto** involucra m√°s de una columna.

Esto es √∫til cuando tienes consultas con m√∫ltiples condiciones:

```sql
CREATE INDEX idx_orders_client_date
ON orders(client_id, created_at);

```

Si haces:

```sql
SELECT * FROM orders
WHERE client_id = 123 AND created_at > '2025-01-01';

```

SQLite usar√° este √≠ndice de forma eficiente.

*Importante*: el orden de las columnas en el √≠ndice **s√≠ importa**.

Un √≠ndice `(client_id, created_at)` sirve bien para consultas con `client_id` solo o `client_id` + `created_at`,

pero **no** para `created_at` sola.

## 6. √çndices √∫nicos y parciales

### a) √çndices √∫nicos

Si quieres asegurar que una columna o combinaci√≥n sea √∫nica:

```sql
CREATE UNIQUE INDEX idx_clients_email ON clients(email);

```

Esto es equivalente a `UNIQUE` en la definici√≥n de la tabla.

### b) √çndices parciales (m√°s avanzados)

Puedes crear un √≠ndice **solo para un subconjunto de filas**, por ejemplo pedidos con total alto:

```sql
CREATE INDEX idx_orders_high_value
ON orders(total)
WHERE total > 100;

```

Esto puede reducir el tama√±o del √≠ndice y mejorar a√∫n m√°s la velocidad si la condici√≥n es frecuente.

Verifica su uso:

```sql
EXPLAIN QUERY PLAN
SELECT * FROM orders WHERE total > 100;

```

## 7. Ejercicio pr√°ctico ‚Äî uso real de √≠ndices

1. Crear tabla con muchos datos de ejemplo:

```sql
CREATE TABLE logs (
  id INTEGER PRIMARY KEY,
  user_id INTEGER NOT NULL,
  ts TEXT NOT NULL,
  action TEXT
);

```

1. Insertar registros sint√©ticos (puedes usar un script o `.import` CSV).
2. Consultar sin √≠ndice:

```sql
EXPLAIN QUERY PLAN
SELECT * FROM logs WHERE user_id = 5;

```

Deber√≠a mostrar `SCAN TABLE logs`.

1. Crear √≠ndice:

```sql
CREATE INDEX idx_logs_user_id ON logs(user_id);

```

1. Volver a consultar:

```sql
EXPLAIN QUERY PLAN
SELECT * FROM logs WHERE user_id = 5;

```

Ver√°s `SEARCH TABLE logs USING INDEX`.

üìå Diferencia clara cuando hay miles de filas.

## 8. Mantenimiento y buenas pr√°cticas

- üßº Revisa √≠ndices innecesarios ‚Üí m√°s √≠ndices = m√°s escritura = m√°s espacio.
- üß™ Usa `EXPLAIN QUERY PLAN` regularmente para entender c√≥mo SQLite ejecuta tus consultas.
- üõ† Usa nombres claros: `idx_<tabla>_<columna>` (o varias si es compuesto).
- üß† No indexes columnas con muy poca variaci√≥n (ej. `sexo` o `activo=1`) ‚Äî el √≠ndice no ser√° eficiente.
- üîë Foreign keys deben tener √≠ndice si se usan en joins frecuentes.
- üìä Para an√°lisis profundos, SQLite incluye `ANALYZE` para ayudar al optimizador.

## Errores comunes

| Error / S√≠ntoma | Causa | Soluci√≥n |
| --- | --- | --- |
| Consulta lenta | Falta de √≠ndice | Crear √≠ndice en columnas filtradas |
| ‚ÄúSCAN TABLE‚Äù en EXPLAIN | No hay √≠ndice √∫til | Revisar estructura y orden |
| Escrituras m√°s lentas | Exceso de √≠ndices | Eliminar los que no se usan |
| √çndice no usado | Orden de columnas incorrecto | Reorganizar √≠ndice compuesto |

## 1. Qu√© es el ‚Äúplanificador‚Äù de consultas

Cada vez que SQLite recibe una consulta, no la ejecuta directamente.

Primero **piensa c√≥mo ejecutarla de la manera m√°s r√°pida posible**.

Para eso tiene un **planificador de consultas** (*query planner*).

Este planificador:

- Decide si usar un √≠ndice o leer toda la tabla.
- Elige el orden de los JOINs.
- Usa estad√≠sticas internas para optimizar.

Y t√∫ puedes inspeccionar ese plan para saber **si tu √≠ndice se est√° usando** o no.

## 2. EXPLAIN QUERY PLAN: tu herramienta principal

La forma m√°s sencilla de ‚Äúver‚Äù el planificador en acci√≥n es:

```sql
EXPLAIN QUERY PLAN
SELECT * FROM orders WHERE client_id = 5;

```

Ejemplo t√≠pico de salida:

```
SEARCH TABLE orders USING INDEX idx_orders_client_id (client_id=?)

```

Interpretaci√≥n:

- `SEARCH TABLE ... USING INDEX` ‚Üí ‚úÖ √≠ndice usado.
- `SCAN TABLE ...` ‚Üí ‚ùå no hay √≠ndice √∫til, lectura completa.

Si haces un JOIN:

```sql
EXPLAIN QUERY PLAN
SELECT c.name, o.total
FROM clients c
JOIN orders o ON c.id = o.client_id
WHERE o.total > 50;

```

Puedes ver algo como:

```
SCAN TABLE clients
SEARCH TABLE orders USING INDEX idx_orders_client_id (client_id=?)

```

Esto significa que SQLite:

1. Recorre la tabla `clients` (porque no hay filtro).
2. Busca en `orders` usando el √≠ndice.

**Consejo real**: aprende a leer estas salidas, aunque parezcan ‚Äúsecas‚Äù.

Una simple l√≠nea de ‚ÄúSCAN‚Äù suele indicar **una oportunidad de optimizaci√≥n**.

## 3. Comparaci√≥n real: con y sin √≠ndice

Vamos a hacer un peque√±o experimento pr√°ctico:

```sql
CREATE TABLE logs (
  id INTEGER PRIMARY KEY,
  user_id INTEGER NOT NULL,
  ts TEXT NOT NULL,
  action TEXT
);

```

Insertamos muchos registros (ej. con un script, CSV o bucle).

Luego:

```sql
EXPLAIN QUERY PLAN
SELECT * FROM logs WHERE user_id = 10;

```

`SCAN TABLE logs` (recorre todo).

Creamos √≠ndice:

```sql
CREATE INDEX idx_logs_user_id ON logs(user_id);

```

Repetimos:

```sql
EXPLAIN QUERY PLAN
SELECT * FROM logs WHERE user_id = 10;

```

`SEARCH TABLE logs USING INDEX idx_logs_user_id (user_id=?)` ‚úÖ

Esto es exactamente c√≥mo **validas que tus √≠ndices est√©n ayudando de verdad**.

## 4. C√≥mo decide SQLite si usar un √≠ndice

El planificador **no siempre usa un √≠ndice**, aunque exista.

SQLite eval√∫a:

- Cu√°ntas filas espera leer con el √≠ndice.
- Si el √≠ndice evita ordenamientos adicionales.
- Si hay otros filtros m√°s selectivos.
- Estad√≠sticas internas de la tabla (que veremos ahora).

Ejemplo:

Si tienes un √≠ndice sobre `gender` (con solo dos valores posibles), probablemente **no lo use** porque no mejora nada.

Pero si tienes un √≠ndice sobre `email` (valores √∫nicos), s√≠ lo usar√°.

## 5. ANALYZE ‚Äî dar informaci√≥n real al planificador

SQLite tiene una herramienta llamada `ANALYZE` que **recopila estad√≠sticas internas** sobre tus tablas e √≠ndices.

Estas estad√≠sticas permiten al planificador **tomar mejores decisiones**.

Ejecutar:

```sql
ANALYZE;

```

Esto:

- Calcula la distribuci√≥n de valores en las columnas indexadas.
- Guarda esa info en tablas especiales internas (`sqlite_stat1`, `sqlite_stat4` si est√° habilitado).
- Mejora la calidad de los planes de ejecuci√≥n.

Ver estad√≠sticas:

```sql
SELECT * FROM sqlite_stat1;

```

Ejemplo de salida:

```
logs idx_logs_user_id 100000 1000

```

Esto significa que:

- `logs` tiene 100.000 filas
- `idx_logs_user_id` divide la tabla en aprox. 1000 filas por valor distinto

Con esa informaci√≥n, el planificador sabr√° que **usar el √≠ndice es √∫til**.

## 6. Casos t√≠picos de tuning con ANALYZE

### Caso 1: √≠ndice ignorado ‚Üí se usa tras ANALYZE

```sql
EXPLAIN QUERY PLAN SELECT * FROM logs WHERE user_id = 10;
-- SCAN TABLE logs
ANALYZE;
EXPLAIN QUERY PLAN SELECT * FROM logs WHERE user_id = 10;
-- SEARCH TABLE logs USING INDEX idx_logs_user_id

```

### Caso 2: join con m√∫ltiples √≠ndices

Si tienes dos √≠ndices en una consulta JOIN, ANALYZE ayuda a decidir **qu√© tabla recorrer primero** y cu√°l buscar por √≠ndice.

## 7. Mantener las estad√≠sticas actualizadas

Cada vez que tu base de datos cambia significativamente (miles de inserciones o borrados), **repite `ANALYZE`**.

Tambi√©n puedes limpiar estad√≠sticas obsoletas:

```sql
DELETE FROM sqlite_stat1;
ANALYZE;

```

Esto es especialmente importante si tu aplicaci√≥n crece con el tiempo.

## 8. Otras t√©cnicas de optimizaci√≥n real en SQLite

- **`LIMIT` + `ORDER BY` con √≠ndice**: si ordenas por una columna indexada, SQLite puede evitar operaciones de sorting costosas.
    
    ```sql
    CREATE INDEX idx_orders_total ON orders(total);
    SELECT * FROM orders ORDER BY total DESC LIMIT 10;
    
    ```
    
    Mucho m√°s r√°pido.
    
- **Evitar funciones en WHERE**:
    
    ```sql
    WHERE date(created_at) = '2025-10-09'
    
    ```
    
    Esto no usa el √≠ndice.
    
    Mejor:
    
    ```sql
    WHERE created_at >= '2025-10-09' AND created_at < '2025-10-10'
    
    ```
    
    Esto s√≠ puede usar el √≠ndice sobre `created_at`.
    
- **Evitar comodines al inicio de LIKE**:
    
    `LIKE '%texto'` no usa √≠ndice, pero `LIKE 'texto%'` s√≠.
    

## 9. Ejercicio pr√°ctico ‚Äî tuning real

1. Crea una tabla `ventas` con:

```sql
CREATE TABLE ventas (
  id INTEGER PRIMARY KEY,
  cliente TEXT,
  fecha TEXT,
  total REAL
);

```

1. Inserta muchos registros (por CSV o script).
2. Consulta sin √≠ndice:

```sql
EXPLAIN QUERY PLAN
SELECT * FROM ventas WHERE cliente = 'Marta';

```

1. Crea √≠ndice:

```sql
CREATE INDEX idx_ventas_cliente ON ventas(cliente);

```

1. Repite la consulta con `EXPLAIN`:
    
    deber√≠a cambiar de SCAN a SEARCH.
    
2. Ejecuta `ANALYZE;` y vuelve a probar con filtros m√°s complejos:

```sql
EXPLAIN QUERY PLAN
SELECT * FROM ventas
WHERE cliente = 'Marta'
AND fecha BETWEEN '2025-01-01' AND '2025-12-31';

```

1. Observa c√≥mo el planificador elige √≠ndices m√°s eficientemente.

## 10. Buenas pr√°cticas finales de optimizaci√≥n

- Siempre inspecciona tus consultas con `EXPLAIN QUERY PLAN`.
- Usa `ANALYZE` despu√©s de insertar muchos datos para mejorar los planes.
- Usa √≠ndices en columnas realmente selectivas y usadas en filtros/joins.
- Evita funciones en condiciones `WHERE` que impidan usar √≠ndices.
- No abuses de los √≠ndices ‚Äî revisa su impacto en escrituras.

## Errores comunes

| S√≠ntoma | Causa | Soluci√≥n |
| --- | --- | --- |
| Consulta lenta aunque hay √≠ndice | Planificador no lo usa | Ejecuta `ANALYZE`, revisa selectividad |
| EXPLAIN siempre muestra SCAN | Falta √≠ndice √∫til o expresi√≥n no indexada | Ajusta consulta y crea √≠ndice correcto |
| Escrituras lentas | Demasiados √≠ndices | Revisa √≠ndices y elimina innecesarios |
| Estad√≠sticas desactualizadas | Mucha inserci√≥n o borrado | Reejecuta `ANALYZE` peri√≥dicamente |