"use strict";(self.webpackChunkDocuQuest_oslar_code=self.webpackChunkDocuQuest_oslar_code||[]).push([[8511],{8453:(e,a,n)=>{n.d(a,{R:()=>c,x:()=>i});var r=n(6540);const o={},s=r.createContext(o);function c(e){const a=r.useContext(s);return r.useMemo(function(){return"function"==typeof e?e(a):{...a,...e}},[a,e])}function i(e){let a;return a=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:c(e.components),r.createElement(s.Provider,{value:a},e.children)}},9740:(e,a,n)=>{n.r(a),n.d(a,{assets:()=>l,contentTitle:()=>i,default:()=>m,frontMatter:()=>c,metadata:()=>r,toc:()=>d});const r=JSON.parse('{"id":"poo/herencia&polimorfismo","title":"Herencia y polimorfismo en JavaScript","description":"En este m\xf3dulo, profundizaremos en los conceptos de Herencia y Polimorfismo en JavaScript, fundamentales en la Programaci\xf3n Orientada a Objetos (POO). Estos principios permiten crear estructuras de c\xf3digo m\xe1s organizadas, reutilizables y escalables.\ue206","source":"@site/docs/poo/herencia&polimorfismo.md","sourceDirName":"poo","slug":"/poo/herencia&polimorfismo","permalink":"/docuQuest/docs/poo/herencia&polimorfismo","draft":false,"unlisted":false,"editUrl":"https://github.com/OslarCode/OslarCode/docs/poo/herencia&polimorfismo.md","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Clases y m\xe9todos en JavaScript (ES6+)","permalink":"/docuQuest/docs/poo/clases&metodos"},"next":{"title":"POO aplicada al desarrollo web con JavaScript","permalink":"/docuQuest/docs/poo/POOAplicada"}}');var o=n(4848),s=n(8453);const c={},i="Herencia y polimorfismo en JavaScript",l={},d=[{value:"Herencia en JavaScript",id:"herencia-en-javascript",level:2},{value:"Uso de <code>extends</code> para herencia de clases",id:"uso-de-extends-para-herencia-de-clases",level:3},{value:"Llamado al constructor padre con <code>super()</code>",id:"llamado-al-constructor-padre-con-super",level:3},{value:"Sobreescritura de m\xe9todos",id:"sobreescritura-de-m\xe9todos",level:3},{value:"Polimorfismo en JavaScript",id:"polimorfismo-en-javascript",level:2},{value:"M\xe9todos sobrescritos (method overriding)",id:"m\xe9todos-sobrescritos-method-overriding",level:3},{value:"Uso de clases abstractas (simulaci\xf3n)",id:"uso-de-clases-abstractas-simulaci\xf3n",level:3}];function t(e){const a={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",p:"p",pre:"pre",strong:"strong",...(0,s.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(a.header,{children:(0,o.jsx)(a.h1,{id:"herencia-y-polimorfismo-en-javascript",children:"Herencia y polimorfismo en JavaScript"})}),"\n",(0,o.jsxs)(a.p,{children:["En este m\xf3dulo, profundizaremos en los conceptos de ",(0,o.jsx)(a.strong,{children:"Herencia y Polimorfismo en JavaScript"}),", fundamentales en la Programaci\xf3n Orientada a Objetos (POO). Estos principios permiten crear estructuras de c\xf3digo m\xe1s organizadas, reutilizables y escalables.\ue206"]}),"\n",(0,o.jsx)(a.h2,{id:"herencia-en-javascript",children:"Herencia en JavaScript"}),"\n",(0,o.jsxs)(a.p,{children:["La ",(0,o.jsx)(a.strong,{children:"herencia"})," es un mecanismo que permite a una clase derivar propiedades y m\xe9todos de otra clase. En JavaScript, a partir de ECMAScript 6 (ES6), se introdujo la sintaxis de clases que facilita la implementaci\xf3n de la herencia."]}),"\n",(0,o.jsxs)(a.h3,{id:"uso-de-extends-para-herencia-de-clases",children:["Uso de ",(0,o.jsx)(a.code,{children:"extends"})," para herencia de clases"]}),"\n",(0,o.jsxs)(a.p,{children:["La palabra clave ",(0,o.jsx)(a.code,{children:"extends"})," se utiliza para crear una clase que hereda de otra. Esto establece una relaci\xf3n de prototipo entre la clase hija y la clase padre."]}),"\n",(0,o.jsx)(a.p,{children:(0,o.jsx)(a.strong,{children:"Ejemplo:"})}),"\n",(0,o.jsx)(a.pre,{children:(0,o.jsx)(a.code,{className:"language-jsx",children:'class Animal {\n  constructor(nombre) {\n    this.nombre = nombre;\n  }\n\n  hacerSonido() {\n    console.log(`${this.nombre} hace un sonido.`);\n  }\n}\n\nclass Perro extends Animal {\n  constructor(nombre, raza) {\n    super(nombre);\n    this.raza = raza;\n  }\n\n  ladrar() {\n    console.log(`${this.nombre} ladra.`);\n  }\n}\n\nconst miPerro = new Perro("Rex", "Labrador");\nmiPerro.hacerSonido(); // Rex hace un sonido.\nmiPerro.ladrar(); // Rex ladra.\n'})}),"\n",(0,o.jsxs)(a.p,{children:["En este ejemplo, ",(0,o.jsx)(a.code,{children:"Perro"})," hereda de ",(0,o.jsx)(a.code,{children:"Animal"}),", adquiriendo sus propiedades y m\xe9todos. Adem\xe1s, ",(0,o.jsx)(a.code,{children:"Perro"})," a\xf1ade el m\xe9todo ",(0,o.jsx)(a.code,{children:"ladrar"}),"."]}),"\n",(0,o.jsxs)(a.h3,{id:"llamado-al-constructor-padre-con-super",children:["Llamado al constructor padre con ",(0,o.jsx)(a.code,{children:"super()"})]}),"\n",(0,o.jsxs)(a.p,{children:["Dentro del constructor de la clase hija, es necesario llamar a ",(0,o.jsx)(a.code,{children:"super()"})," para invocar el constructor de la clase padre. Esto asegura que las propiedades heredadas sean inicializadas correctamente."]}),"\n",(0,o.jsx)(a.p,{children:(0,o.jsx)(a.strong,{children:"Ejemplo:"})}),"\n",(0,o.jsx)(a.pre,{children:(0,o.jsx)(a.code,{className:"language-jsx",children:'class Vehiculo {\n  constructor(marca) {\n    this.marca = marca;\n  }\n}\n\nclass Coche extends Vehiculo {\n  constructor(marca, modelo) {\n    super(marca);\n    this.modelo = modelo;\n  }\n}\n\nconst miCoche = new Coche("Toyota", "Corolla");\nconsole.log(miCoche.marca); // Toyota\nconsole.log(miCoche.modelo); // Corolla\n'})}),"\n",(0,o.jsxs)(a.p,{children:["Aqu\xed, ",(0,o.jsx)(a.code,{children:"Coche"})," llama a ",(0,o.jsx)(a.code,{children:"super(marca)"})," para inicializar la propiedad ",(0,o.jsx)(a.code,{children:"marca"})," definida en ",(0,o.jsx)(a.code,{children:"Vehiculo"}),"."]}),"\n",(0,o.jsx)(a.h3,{id:"sobreescritura-de-m\xe9todos",children:"Sobreescritura de m\xe9todos"}),"\n",(0,o.jsxs)(a.p,{children:["La ",(0,o.jsx)(a.strong,{children:"sobreescritura de m\xe9todos"})," permite que una clase hija proporcione una implementaci\xf3n espec\xedfica de un m\xe9todo que ya est\xe1 definido en su clase padre."]}),"\n",(0,o.jsx)(a.p,{children:(0,o.jsx)(a.strong,{children:"Ejemplo:"})}),"\n",(0,o.jsx)(a.pre,{children:(0,o.jsx)(a.code,{className:"language-jsx",children:'class Animal {\n  hacerSonido() {\n    console.log("Sonido gen\xe9rico de animal.");\n  }\n}\n\nclass Gato extends Animal {\n  hacerSonido() {\n    console.log("El gato ma\xfalla.");\n  }\n}\n\nconst miGato = new Gato();\nmiGato.hacerSonido(); // El gato ma\xfalla.\n'})}),"\n",(0,o.jsxs)(a.p,{children:["En este caso, ",(0,o.jsx)(a.code,{children:"Gato"})," sobrescribe el m\xe9todo ",(0,o.jsx)(a.code,{children:"hacerSonido"})," de ",(0,o.jsx)(a.code,{children:"Animal"})," para proporcionar su propia implementaci\xf3n."]}),"\n",(0,o.jsx)(a.hr,{}),"\n",(0,o.jsx)(a.h2,{id:"polimorfismo-en-javascript",children:"Polimorfismo en JavaScript"}),"\n",(0,o.jsxs)(a.p,{children:["El ",(0,o.jsx)(a.strong,{children:"polimorfismo"})," es la capacidad de diferentes clases para ser tratadas como instancias de la misma clase a trav\xe9s de una interfaz com\xfan. Esto permite que m\xe9todos con el mismo nombre act\xfaen de manera diferente seg\xfan la clase que los implemente."]}),"\n",(0,o.jsx)(a.h3,{id:"m\xe9todos-sobrescritos-method-overriding",children:"M\xe9todos sobrescritos (method overriding)"}),"\n",(0,o.jsx)(a.p,{children:"Como se mostr\xf3 anteriormente, las clases hijas pueden sobrescribir m\xe9todos de sus clases padres para proporcionar comportamientos espec\xedficos."}),"\n",(0,o.jsx)(a.p,{children:(0,o.jsx)(a.strong,{children:"Ejemplo adicional:"})}),"\n",(0,o.jsx)(a.pre,{children:(0,o.jsx)(a.code,{className:"language-jsx",children:'class Ave {\n  volar() {\n    console.log("El ave vuela.");\n  }\n}\n\nclass Pinguino extends Ave {\n  volar() {\n    console.log("El ping\xfcino no puede volar.");\n  }\n}\n\nconst miAve = new Ave();\nconst miPinguino = new Pinguino();\n\nmiAve.volar(); // El ave vuela.\nmiPinguino.volar(); // El ping\xfcino no puede volar.\n'})}),"\n",(0,o.jsxs)(a.p,{children:["Aqu\xed, aunque ",(0,o.jsx)(a.code,{children:"Pinguino"})," es una subclase de ",(0,o.jsx)(a.code,{children:"Ave"}),", sobrescribe el m\xe9todo ",(0,o.jsx)(a.code,{children:"volar"})," para reflejar su incapacidad para volar."]}),"\n",(0,o.jsx)(a.h3,{id:"uso-de-clases-abstractas-simulaci\xf3n",children:"Uso de clases abstractas (simulaci\xf3n)"}),"\n",(0,o.jsxs)(a.p,{children:["JavaScript no tiene soporte nativo para ",(0,o.jsx)(a.strong,{children:"clases abstractas"}),", pero podemos simular este comportamiento lanzando errores en m\xe9todos que deben ser implementados por las clases derivadas."]}),"\n",(0,o.jsx)(a.p,{children:(0,o.jsx)(a.strong,{children:"Ejemplo:"})}),"\n",(0,o.jsx)(a.pre,{children:(0,o.jsx)(a.code,{className:"language-jsx",children:'class Figura {\n  constructor() {\n    if (new.target === Figura) {\n      throw new Error("No se puede instanciar una clase abstracta.");\n    }\n  }\n\n  calcularArea() {\n    throw new Error("El m\xe9todo calcularArea() debe ser implementado.");\n  }\n}\n\nclass Circulo extends Figura {\n  constructor(radio) {\n    super();\n    this.radio = radio;\n  }\n\n  calcularArea() {\n    return Math.PI * this.radio ** 2;\n  }\n}\n\nconst miCirculo = new Circulo(5);\nconsole.log(miCirculo.calcularArea()); // 78.53981633974483\n\nconst miFigura = new Figura(); // Error: No se puede instanciar una clase abstracta.\n'})}),"\n",(0,o.jsxs)(a.p,{children:["En este ejemplo, ",(0,o.jsx)(a.code,{children:"Figura"})," act\xfaa como una clase abstracta. Intentar instanciar ",(0,o.jsx)(a.code,{children:"Figura"})," directamente lanza un error, y cualquier subclase debe implementar el m\xe9todo ",(0,o.jsx)(a.code,{children:"calcularArea"}),"."]}),"\n",(0,o.jsx)(a.hr,{}),"\n",(0,o.jsxs)(a.p,{children:["Comprender y aplicar ",(0,o.jsx)(a.strong,{children:"herencia"})," y ",(0,o.jsx)(a.strong,{children:"polimorfismo"})," en JavaScript es esencial para desarrollar aplicaciones robustas y mantenibles. Estos conceptos permiten estructurar el c\xf3digo de manera que sea f\xe1cil de extender y reutilizar, facilitando la colaboraci\xf3n y el crecimiento del proyecto."]})]})}function m(e={}){const{wrapper:a}={...(0,s.R)(),...e.components};return a?(0,o.jsx)(a,{...e,children:(0,o.jsx)(t,{...e})}):t(e)}}}]);