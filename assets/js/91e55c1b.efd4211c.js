"use strict";(globalThis.webpackChunkDocuQuest_oslar_code=globalThis.webpackChunkDocuQuest_oslar_code||[]).push([[8246],{5107:(e,r,n)=>{n.r(r),n.d(r,{assets:()=>c,contentTitle:()=>i,default:()=>p,frontMatter:()=>a,metadata:()=>o,toc:()=>d});const o=JSON.parse('{"id":"backend/Node.js/manejoDeHTTP","title":"HTTP manejo de peticiones y respuestas ES Modules","description":"El m\xf3dulo http es el n\xfacleo para crear servidores web en Node.js. Permite construir servidores HTTP, hacer peticiones a otros servidores y manejar el protocolo HTTP completo.","source":"@site/docs/backend/Node.js/manejoDeHTTP.md","sourceDirName":"backend/Node.js","slug":"/backend/Node.js/manejoDeHTTP","permalink":"/docuQuest/docs/backend/Node.js/manejoDeHTTP","draft":false,"unlisted":false,"editUrl":"https://github.com/OslarCode/OslarCode/docs/backend/Node.js/manejoDeHTTP.md","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Gu\xeda de Manejo de Rutas en Node.js con ES Modules","permalink":"/docuQuest/docs/backend/Node.js/manejoDeRutas"},"next":{"title":"Manejo del sistema de archivos con Node.js ES Modules","permalink":"/docuQuest/docs/backend/Node.js/manejoDeArchivos"}}');var s=n(4848),t=n(8453);const a={},i="HTTP manejo de peticiones y respuestas ES Modules",c={},d=[{value:"Importaci\xf3n del M\xf3dulo HTTP",id:"importaci\xf3n-del-m\xf3dulo-http",level:2},{value:"An\xe1lisis del Objeto Request (req)",id:"an\xe1lisis-del-objeto-request-req",level:3},{value:"Manejo Avanzado de Respuestas",id:"manejo-avanzado-de-respuestas",level:3},{value:"Servidor HTTP con Enrutamiento Completo",id:"servidor-http-con-enrutamiento-completo",level:2},{value:"Cliente HTTP para Hacer Peticiones",id:"cliente-http-para-hacer-peticiones",level:2},{value:"Servidor HTTP con Manejo de Archivos Est\xe1ticos",id:"servidor-http-con-manejo-de-archivos-est\xe1ticos",level:2},{value:"Mejores Pr\xe1cticas y Configuraciones",id:"mejores-pr\xe1cticas-y-configuraciones",level:2},{value:"Manejo de Errores del Servidor",id:"manejo-de-errores-del-servidor",level:3},{value:"Configuraci\xf3n de Timeouts",id:"configuraci\xf3n-de-timeouts",level:3},{value:"Conclusi\xf3n",id:"conclusi\xf3n",level:2}];function l(e){const r={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,t.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(r.header,{children:(0,s.jsx)(r.h1,{id:"http-manejo-de-peticiones-y-respuestas-es-modules",children:"HTTP manejo de peticiones y respuestas ES Modules"})}),"\n",(0,s.jsxs)(r.p,{children:["El m\xf3dulo ",(0,s.jsx)(r.code,{children:"http"})," es el n\xfacleo para crear servidores web en Node.js. Permite construir servidores HTTP, hacer peticiones a otros servidores y manejar el protocolo HTTP completo."]}),"\n",(0,s.jsx)(r.h2,{id:"importaci\xf3n-del-m\xf3dulo-http",children:"Importaci\xf3n del M\xf3dulo HTTP"}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-jsx",children:'// M\xf3dulo nativo de Node.js para crear servidores HTTP\r\n// HTTP (HyperText Transfer Protocol) - protocolo no seguro\r\nimport http from "http";\r\n\r\n// M\xf3dulo nativo de Node.js para crear servidores HTTPS\r\n// HTTPS (HTTP Secure) - protocolo seguro con encriptaci\xf3n SSL/TLS\r\nimport https from "https";\r\n\r\n// DIFERENCIAS CLAVE ENTRE HTTP Y HTTPS:\r\n\r\n// HTTP:\r\n// - Puerto por defecto: 80\r\n// - Comunicaci\xf3n no encriptada\r\n// - M\xe1s r\xe1pido (sin overhead de encriptaci\xf3n)\r\n// - Adecuado para desarrollo y testing\r\n\r\n// HTTPS:\r\n// - Puerto por defecto: 443\r\n// - Comunicaci\xf3n encriptada con SSL/TLS\r\n// - M\xe1s seguro, protege datos sensibles\r\n// - Requisito para muchas funcionalidades modernas del navegador\r\n// - Necesita certificados SSL/TLS\r\n\r\n// EJEMPLO DE SERVIDOR HTTP B\xc1SICO:\r\n\r\nconst servidorHTTP = http.createServer((req, res) => {\r\n  res.writeHead(200, { "Content-Type": "text/plain" });\r\n  res.end("Servidor HTTP funcionando\\n");\r\n});\r\n\r\nservidorHTTP.listen(3000, () => {\r\n  console.log(\r\n    "Servidor HTTP en [http://localhost:3000](http://localhost:3000/)"\r\n  );\r\n});\r\n\r\n// EJEMPLO DE SERVIDOR HTTPS B\xc1SICO (REQUIERE CERTIFICADOS):\r\n\r\n// Para HTTPS necesitas un certificado SSL y una clave privada\r\n// En producci\xf3n, estos se obtienen de una autoridad certificadora\r\n// En desarrollo, puedes usar certificados auto-firmados\r\n\r\nconst opcionesHTTPS = {\r\n  key: "", // Clave privada SSL (generalmente desde un archivo .key)\r\n  cert: "", // Certificado SSL (generalmente desde un archivo .crt)\r\n};\r\n\r\nconst servidorHTTPS = https.createServer(opcionesHTTPS, (req, res) => {\r\n  res.writeHead(200, { "Content-Type": "text/plain" });\r\n  res.end("Servidor HTTPS funcionando\\n");\r\n});\r\n\r\nservidorHTTPS.listen(3443, () => {\r\n  console.log(\r\n    "Servidor HTTPS en [https://localhost:3443](https://localhost:3443/)"\r\n  );\r\n});\r\n\r\n// C\xd3MO CARGAR CERTIFICADOS DESDE ARCHIVOS:\r\n\r\nimport fs from "fs";\r\n\r\n// En un entorno real, los certificados se cargan desde archivos\r\nconst opcionesHTTPSReales = {\r\n  key: fs.readFileSync("ruta/al/privkey.pem"),\r\n  cert: fs.readFileSync("ruta/al/cert.pem"),\r\n  // Opcional: cadena de certificados\r\n  ca: fs.readFileSync("ruta/al/chain.pem"),\r\n};\r\n\r\n// USO EN APLICACIONES DEL MUNDO REAL:\r\n\r\n// Estrategia com\xfan: Redirigir HTTP a HTTPS en producci\xf3n\r\nfunction crearServidorSeguro(app) {\r\n  // En entornos de producci\xf3n, usar HTTPS\r\n  if (process.env.NODE_ENV === "production") {\r\n    const opciones = {\r\n      key: fs.readFileSync("/etc/ssl/private/privkey.pem"),\r\n      cert: fs.readFileSync("/etc/ssl/certs/cert.pem"),\r\n    };\r\n    return https.createServer(opciones, app);\r\n  } else {\r\n    // En desarrollo, usar HTTP para simplicidad\r\n    return http.createServer(app);\r\n  }\r\n}\r\n\r\n// SERVIDOR QUE MANEJA TANTO HTTP COMO HTTPS:\r\n\r\n// Escenario: Servidor que escucha en ambos puertos\r\n// HTTP (puerto 80) redirige a HTTPS (puerto 443)\r\n\r\nconst app = (req, res) => {\r\n  res.writeHead(200, { "Content-Type": "text/html" });\r\n  res.end("<h1>\xa1Hola desde servidor seguro!</h1>");\r\n};\r\n\r\n// Servidor HTTPS principal\r\nconst servidorPrincipal = https.createServer(opcionesHTTPS, app);\r\nservidorPrincipal.listen(443, () => {\r\n  console.log("Servidor HTTPS principal en puerto 443");\r\n});\r\n\r\n// Servidor HTTP que redirige a HTTPS\r\nconst servidorRedireccion = http.createServer((req, res) => {\r\n  // Redirigir todas las solicitudes HTTP a HTTPS\r\n  const urlSegura = `https://${req.headers.host}${req.url}`;\r\n  res.writeHead(301, { Location: urlSegura });\r\n  res.end();\r\n});\r\n\r\nservidorRedireccion.listen(80, () => {\r\n  console.log("Servidor de redirecci\xf3n HTTP en puerto 80");\r\n});\r\n\r\n// CONSIDERACIONES DE SEGURIDAD:\r\n\r\n// 1. Siempre usar HTTPS en producci\xf3n para:\r\n//    - Proteger datos sensibles (contrase\xf1as, informaci\xf3n personal)\r\n//    - Prevenir ataques man-in-the-middle\r\n//    - Cumplir con est\xe1ndares de seguridad modernos\r\n\r\n// 2. Configuraciones recomendadas para HTTPS:\r\nconst opcionesSeguras = {\r\n  key: fs.readFileSync("clave-privada.pem"),\r\n  cert: fs.readFileSync("certificado.pem"),\r\n  // Forzar versiones seguras de TLS\r\n  secureProtocol: "TLSv1_2_method",\r\n  // Configuraciones de cipher suites\r\n  ciphers: ["ECDHE-RSA-AES128-GCM-SHA256", "ECDHE-RSA-AES256-GCM-SHA384"].join(\r\n    ":"\r\n  ),\r\n  honorCipherOrder: true,\r\n};\r\n\r\n// USO CON EXPRESS.JS U OTROS FRAMEWORKS:\r\n\r\n// Aunque este ejemplo usa el m\xf3dulo http nativo,\r\n// la misma l\xf3gica aplica para frameworks:\r\n\r\nimport express from "express";\r\n\r\nconst appExpress = express();\r\n\r\nappExpress.get("/", (req, res) => {\r\n  res.send("\xa1Hola desde Express!");\r\n});\r\n\r\n// El servidor se crea de la misma manera\r\nconst servidorExpressHTTP = http.createServer(appExpress);\r\nconst servidorExpressHTTPS = https.createServer(opcionesHTTPS, appExpress);\r\n\r\n// CONSIDERACIONES DE RENDIMIENTO:\r\n\r\n// HTTPS tiene un impacto en el rendimiento debido a:\r\n// - Handshake inicial SSL/TLS\r\n// - Encriptaci\xf3n/desencriptaci\xf3n de datos\r\n// Sin embargo, con hardware moderno el impacto es m\xednimo\r\n\r\n// Para mejorar el rendimiento de HTTPS:\r\n// 1. Usar Session Resumption\r\n// 2. Implementar HTTP/2 (que requiere HTTPS)\r\n// 3. Usar certificados ECDSA (m\xe1s eficientes que RSA)\r\n\r\n// EJEMPLO DE HTTP/2 CON HTTPS:\r\n\r\n// Nota: Node.js tiene soporte experimental para HTTP/2\r\nimport http2 from "http2";\r\n\r\nconst servidorHTTP2 = http2.createSecureServer(opcionesHTTPS, (req, res) => {\r\n  res.writeHead(200);\r\n  res.end("\xa1Hola desde HTTP/2!");\r\n});\n'})}),"\n",(0,s.jsx)(r.p,{children:(0,s.jsx)(r.strong,{children:"RESUMEN DE USOS PR\xc1CTICOS:"})}),"\n",(0,s.jsxs)(r.ul,{children:["\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.strong,{children:"Desarrollo local"}),": Usar HTTP para simplicidad"]}),"\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.strong,{children:"Producci\xf3n"}),": Siempre usar HTTPS para seguridad"]}),"\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.strong,{children:"APIs"}),": HTTPS para proteger datos en tr\xe1nsito"]}),"\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.strong,{children:"Aplicaciones web"}),": HTTPS requerido para muchas APIs del navegador"]}),"\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.strong,{children:"Redirecci\xf3n"}),": Configurar redirecci\xf3n autom\xe1tica de HTTP a HTTPS"]}),"\n"]}),"\n",(0,s.jsx)(r.p,{children:"La importaci\xf3n de ambos m\xf3dulos es com\xfan en aplicaciones que necesitan soportar ambos protocolos o que implementan redirecci\xf3n de HTTP a HTTPS para garantizar que todas las conexiones sean seguras."}),"\n",(0,s.jsx)(r.h3,{id:"an\xe1lisis-del-objeto-request-req",children:"An\xe1lisis del Objeto Request (req)"}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-jsx",children:'import http from "http";\r\n\r\n// Crear servidor HTTP con una funci\xf3n callback que se ejecuta en cada solicitud\r\n// La funci\xf3n recibe dos objetos: req (solicitud) y res (respuesta)\r\nconst server = http.createServer((req, res) => {\r\n  // AN\xc1LISIS DE LA SOLICITUD HTTP\r\n\r\n  // M\xe9todo HTTP (GET, POST, PUT, DELETE, etc.)\r\n  // Indica la acci\xf3n que el cliente quiere realizar\r\n  console.log("M\xe9todo:", req.method);\r\n\r\n  // URL solicitada (ruta y query string)\r\n  // Ejemplo: \'/api/usuarios?pagina=1\' o \'/productos/123\'\r\n  console.log("URL:", req.url);\r\n\r\n  // Headers de la petici\xf3n\r\n  // Contienen metadatos sobre la solicitud como:\r\n  // - Content-Type: tipo de datos enviados\r\n  // - User-Agent: informaci\xf3n del cliente\r\n  // - Authorization: credenciales de autenticaci\xf3n\r\n  // - Accept: tipos de respuesta que el cliente puede entender\r\n  console.log("Headers:", req.headers);\r\n\r\n  // Informaci\xf3n de la conexi\xf3n del cliente\r\n  // req.socket.remoteAddress contiene la direcci\xf3n IP del cliente\r\n  console.log("Direcci\xf3n IP del cliente:", req.socket.remoteAddress);\r\n\r\n  // EJEMPLO DE RUTEO BASADO EN M\xc9TODO HTTP\r\n\r\n  // Manejar diferentes m\xe9todos HTTP con respuestas apropiadas\r\n  if (req.method === "GET") {\r\n    // GET - Solicitar datos (operaci\xf3n segura e idempotente)\r\n    res.writeHead(200, { "Content-Type": "text/plain" });\r\n    res.end("Recibida petici\xf3n GET");\r\n  } else if (req.method === "POST") {\r\n    // POST - Enviar datos para crear nuevos recursos\r\n    res.writeHead(200, { "Content-Type": "text/plain" });\r\n    res.end("Recibida petici\xf3n POST");\r\n  } else {\r\n    // M\xe9todo no soportado - retornar error 405 Method Not Allowed\r\n    res.writeHead(405, { "Content-Type": "text/plain" });\r\n    res.end("M\xe9todo no permitido");\r\n  }\r\n});\r\n\r\n// Iniciar el servidor en el puerto 3000\r\nserver.listen(3000, () => {\r\n  console.log(\r\n    "Servidor ejecut\xe1ndose en [http://localhost:3000](http://localhost:3000/)"\r\n  );\r\n});\r\n\r\n// AN\xc1LISIS DETALLADO DE LAS PROPIEDADES DEL OBJETO req:\r\n\r\n// Ejemplo de solicitud completa que se puede analizar:\r\n\r\nfunction analizarSolicitudCompleta(req, res) {\r\n  console.log("=== AN\xc1LISIS COMPLETO DE SOLICITUD ===");\r\n\r\n  // INFORMACI\xd3N B\xc1SICA\r\n  console.log("M\xe9todo HTTP:", req.method);\r\n  console.log("URL completa:", req.url);\r\n  console.log("Versi\xf3n HTTP:", req.httpVersion);\r\n\r\n  // INFORMACI\xd3N DE LA CONEXI\xd3N\r\n  console.log("IP del cliente:", req.socket.remoteAddress);\r\n  console.log("Puerto del cliente:", req.socket.remotePort);\r\n  console.log("IP local:", req.socket.localAddress);\r\n  console.log("Puerto local:", req.socket.localPort);\r\n\r\n  // HEADERS M\xc1S IMPORTANTES\r\n  console.log("User-Agent:", req.headers["user-agent"]);\r\n  console.log("Content-Type:", req.headers["content-type"]);\r\n  console.log("Content-Length:", req.headers["content-length"]);\r\n  console.log("Accept:", req.headers["accept"]);\r\n  console.log(\r\n    "Authorization:",\r\n    req.headers["authorization"] ? "Presente" : "No presente"\r\n  );\r\n\r\n  // INFORMACI\xd3N DE LA URL (usando el m\xf3dulo URL)\r\n  const url = new URL(req.url, `http://${req.headers.host}`);\r\n  console.log("Pathname:", url.pathname);\r\n  console.log("Query parameters:", url.searchParams.toString());\r\n  console.log("Hostname:", url.hostname);\r\n}\r\n\r\n// MANEJO AVANZADO DE DIFERENTES M\xc9TODOS HTTP:\r\n\r\nfunction manejoAvanzadoMetodos(req, res) {\r\n  switch (req.method) {\r\n    case "GET":\r\n      // Operaci\xf3n de lectura - no debe modificar datos\r\n      res.writeHead(200, {\r\n        "Content-Type": "application/json",\r\n        "Cache-Control": "public, max-age=3600",\r\n      });\r\n      res.end(JSON.stringify({ mensaje: "Datos obtenidos", metodo: "GET" }));\r\n      break;\r\n\r\n    case "POST":\r\n      // Operaci\xf3n de creaci\xf3n - procesar datos enviados\r\n      res.writeHead(201, {\r\n        "Content-Type": "application/json",\r\n        Location: "/nuevo-recurso/123",\r\n      });\r\n      res.end(JSON.stringify({ mensaje: "Recurso creado", metodo: "POST" }));\r\n      break;\r\n\r\n    case "PUT":\r\n      // Operaci\xf3n de actualizaci\xf3n completa\r\n      res.writeHead(200, { "Content-Type": "application/json" });\r\n      res.end(\r\n        JSON.stringify({ mensaje: "Recurso actualizado", metodo: "PUT" })\r\n      );\r\n      break;\r\n\r\n    case "PATCH":\r\n      // Operaci\xf3n de actualizaci\xf3n parcial\r\n      res.writeHead(200, { "Content-Type": "application/json" });\r\n      res.end(\r\n        JSON.stringify({\r\n          mensaje: "Recurso actualizado parcialmente",\r\n          metodo: "PATCH",\r\n        })\r\n      );\r\n      break;\r\n\r\n    case "DELETE":\r\n      // Operaci\xf3n de eliminaci\xf3n\r\n      res.writeHead(204); // No Content - \xe9xito sin cuerpo de respuesta\r\n      res.end();\r\n      break;\r\n\r\n    case "OPTIONS":\r\n      // Pre-flight request para CORS\r\n      res.writeHead(200, {\r\n        "Access-Control-Allow-Origin": "*",\r\n        "Access-Control-Allow-Methods": "GET, POST, PUT, DELETE, OPTIONS",\r\n        "Access-Control-Allow-Headers": "Content-Type, Authorization",\r\n      });\r\n      res.end();\r\n      break;\r\n\r\n    default:\r\n      res.writeHead(405, {\r\n        "Content-Type": "application/json",\r\n        Allow: "GET, POST, PUT, DELETE, OPTIONS",\r\n      });\r\n      res.end(JSON.stringify({ error: "M\xe9todo no permitido" }));\r\n  }\r\n}\r\n\r\n// EJEMPLO DE MANEJO DE DATOS DEL CUERPO EN POST/PUT:\r\n\r\nfunction manejarDatosCuerpo(req, res) {\r\n  if (req.method === "POST" || req.method === "PUT") {\r\n    let body = "";\r\n\r\n    // Acumular datos del cuerpo (pueden llegar en m\xfaltiples chunks)\r\n    req.on("data", (chunk) => {\r\n      body += chunk.toString();\r\n    });\r\n\r\n    // Cuando se reciben todos los datos\r\n    req.on("end", () => {\r\n      try {\r\n        const datos = JSON.parse(body);\r\n        console.log("Datos recibidos:", datos);\r\n\r\n        res.writeHead(200, { "Content-Type": "application/json" });\r\n        res.end(\r\n          JSON.stringify({\r\n            estado: "\xe9xito",\r\n            datosRecibidos: datos,\r\n          })\r\n        );\r\n      } catch (error) {\r\n        res.writeHead(400, { "Content-Type": "application/json" });\r\n        res.end(JSON.stringify({ error: "JSON inv\xe1lido" }));\r\n      }\r\n    });\r\n  } else {\r\n    res.writeHead(405, { "Content-Type": "application/json" });\r\n    res.end(\r\n      JSON.stringify({ error: "M\xe9todo no soportado para esta operaci\xf3n" })\r\n    );\r\n  }\r\n}\r\n\r\n// MIDDLEWARE DE LOGGING MEJORADO:\r\n\r\nfunction crearServidorConLogging() {\r\n  return http.createServer((req, res) => {\r\n    const timestamp = new Date().toISOString();\r\n    const ip = req.socket.remoteAddress;\r\n\r\n    console.log(`[${timestamp}] ${ip} - ${req.method} ${req.url}`);\r\n\r\n    // Medir tiempo de respuesta\r\n    const inicio = Date.now();\r\n\r\n    res.on("finish", () => {\r\n      const duracion = Date.now() - inicio;\r\n      console.log(\r\n        `[${timestamp}] Respuesta: ${res.statusCode} - ${duracion}ms`\r\n      );\r\n    });\r\n\r\n    // L\xf3gica principal del servidor\r\n    if (req.method === "GET") {\r\n      res.writeHead(200, { "Content-Type": "text/plain" });\r\n      res.end("OK");\r\n    } else {\r\n      res.writeHead(405, { "Content-Type": "text/plain" });\r\n      res.end("M\xe9todo no permitido");\r\n    }\r\n  });\r\n}\n'})}),"\n",(0,s.jsx)(r.p,{children:(0,s.jsxs)(r.strong,{children:["RESUMEN DE PROPIEDADES PRINCIPALES DEL OBJETO\xa0",(0,s.jsx)(r.code,{children:"req"}),":"]})}),"\n",(0,s.jsxs)(r.ul,{children:["\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.strong,{children:(0,s.jsx)(r.code,{children:"req.method"})}),": M\xe9todo HTTP (GET, POST, PUT, etc.)"]}),"\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.strong,{children:(0,s.jsx)(r.code,{children:"req.url"})}),": Ruta y par\xe1metros de consulta solicitados"]}),"\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.strong,{children:(0,s.jsx)(r.code,{children:"req.headers"})}),": Objeto con todos los headers de la solicitud"]}),"\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.strong,{children:(0,s.jsx)(r.code,{children:"req.socket"})}),": Informaci\xf3n de la conexi\xf3n TCP"]}),"\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.strong,{children:(0,s.jsx)(r.code,{children:"req.httpVersion"})}),": Versi\xf3n del protocolo HTTP"]}),"\n"]}),"\n",(0,s.jsx)(r.p,{children:"Este servidor demuestra los fundamentos del manejo de solicitudes HTTP en Node.js, proporcionando la base sobre la cual se construyen frameworks web m\xe1s complejos como Express.js."}),"\n",(0,s.jsx)(r.h3,{id:"manejo-avanzado-de-respuestas",children:"Manejo Avanzado de Respuestas"}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-jsx",children:'import http from "http";\r\n\r\nconst server = http.createServer((req, res) => {\r\n  // CONFIGURACI\xd3N DE HEADERS DE RESPUESTA\r\n\r\n  // Headers b\xe1sicos para todas las respuestas\r\n  // Content-Type indica el tipo de contenido que se env\xeda\r\n  res.setHeader("Content-Type", "application/json");\r\n\r\n  // Header personalizado que indica la tecnolog\xeda utilizada\r\n  res.setHeader("X-Powered-By", "Node.js HTTP");\r\n\r\n  // Header para control de CORS (permite solicitudes desde otros dominios)\r\n  res.setHeader("Access-Control-Allow-Origin", "*");\r\n\r\n  // MANEJO DE DIFERENTES RUTAS CON C\xd3DIGOS DE ESTADO HTTP\r\n\r\n  // Ruta: /success - C\xf3digo 200 OK\r\n  if (req.url === "/success") {\r\n    // 200 OK - Solicitud exitosa\r\n    // writeHead() establece el c\xf3digo de estado y puede sobrescribir headers\r\n    res.writeHead(200, { "Content-Type": "text/plain" });\r\n    res.end("\xc9xito: Operaci\xf3n completada");\r\n  }\r\n\r\n  // Ruta: /not-found - C\xf3digo 404 Not Found\r\n  else if (req.url === "/not-found") {\r\n    // 404 Not Found - Recurso solicitado no existe\r\n    res.writeHead(404, { "Content-Type": "text/plain" });\r\n    res.end("Error: Recurso no encontrado");\r\n  }\r\n\r\n  // Ruta: /server-error - C\xf3digo 500 Internal Server Error\r\n  else if (req.url === "/server-error") {\r\n    // 500 Internal Server Error - Error gen\xe9rico del servidor\r\n    res.writeHead(500, { "Content-Type": "text/plain" });\r\n    res.end("Error: Problema interno del servidor");\r\n  }\r\n\r\n  // Ruta: /redirect - C\xf3digo 302 Found (Redirecci\xf3n temporal)\r\n  else if (req.url === "/redirect") {\r\n    // 302 Found - Redirecci\xf3n temporal\r\n    // El header Location indica a d\xf3nde redirigir\r\n    res.writeHead(302, {\r\n      Location: "/success",\r\n      "Content-Type": "text/plain",\r\n    });\r\n    res.end("Redirigiendo...");\r\n  }\r\n\r\n  // Ruta por defecto - C\xf3digo 200 OK\r\n  else {\r\n    res.writeHead(200, { "Content-Type": "text/plain" });\r\n    res.end("P\xe1gina principal");\r\n  }\r\n});\r\n\r\nserver.listen(3000, () => {\r\n  console.log("Servidor ejecut\xe1ndose en http://localhost:3000");\r\n  console.log("Endpoints disponibles:");\r\n  console.log("  GET /success        - 200 OK");\r\n  console.log("  GET /not-found      - 404 Not Found");\r\n  console.log("  GET /server-error   - 500 Internal Server Error");\r\n  console.log("  GET /redirect       - 302 Redirect");\r\n  console.log("  GET /               - P\xe1gina principal");\r\n});\r\n\r\n// EXPLICACI\xd3N DETALLADA DE C\xd3DIGOS DE ESTADO HTTP:\r\n\r\nfunction explicacionCodigosEstado() {\r\n  // C\xd3DIGOS 2xx - \xc9XITO\r\n  // 200 OK: Solicitud exitosa, respuesta contiene los datos solicitados\r\n  // 201 Created: Recurso creado exitosamente (usado en POST)\r\n  // 204 No Content: \xc9xito pero sin contenido en la respuesta (usado en DELETE)\r\n  // C\xd3DIGOS 3xx - REDIRECCI\xd3N\r\n  // 301 Moved Permanently: Redirecci\xf3n permanente\r\n  // 302 Found: Redirecci\xf3n temporal\r\n  // 304 Not Modified: El recurso no ha cambiado (cach\xe9)\r\n  // C\xd3DIGOS 4xx - ERROR DEL CLIENTE\r\n  // 400 Bad Request: Solicitud mal formada\r\n  // 401 Unauthorized: No autenticado\r\n  // 403 Forbidden: Autenticado pero sin permisos\r\n  // 404 Not Found: Recurso no existe\r\n  // 405 Method Not Allowed: M\xe9todo HTTP no permitido\r\n  // C\xd3DIGOS 5xx - ERROR DEL SERVIDOR\r\n  // 500 Internal Server Error: Error gen\xe9rico del servidor\r\n  // 501 Not Implemented: Funcionalidad no implementada\r\n  // 503 Service Unavailable: Servicio no disponible\r\n}\r\n\r\n// EJEMPLO M\xc1S COMPLETO CON M\xc1S C\xd3DIGOS DE ESTADO:\r\n\r\nfunction servidorCompleto() {\r\n  return http.createServer((req, res) => {\r\n    // Headers base para todas las respuestas\r\n    res.setHeader("X-Powered-By", "Node.js");\r\n    res.setHeader("Access-Control-Allow-Origin", "*");\r\n\r\n    const url = req.url;\r\n    const method = req.method;\r\n\r\n    // RUTEO M\xc1S DETALLADO\r\n    if (url === "/") {\r\n      res.writeHead(200, { "Content-Type": "text/html" });\r\n      res.end(`\r\n                <html>\r\n                    <body>\r\n                        <h1>P\xe1gina Principal</h1>\r\n                        <ul>\r\n                            <li><a href="/success">/success (200)</a></li>\r\n                            <li><a href="/created">/created (201)</a></li>\r\n                            <li><a href="/no-content">/no-content (204)</a></li>\r\n                            <li><a href="/not-found">/not-found (404)</a></li>\r\n                            <li><a href="/server-error">/server-error (500)</a></li>\r\n                            <li><a href="/redirect">/redirect (302)</a></li>\r\n                            <li><a href="/bad-request">/bad-request (400)</a></li>\r\n                            <li><a href="/unauthorized">/unauthorized (401)</a></li>\r\n                        </ul>\r\n                    </body>\r\n                </html>\r\n            `);\r\n    } else if (url === "/success") {\r\n      res.writeHead(200, { "Content-Type": "application/json" });\r\n      res.end(JSON.stringify({ message: "Operaci\xf3n exitosa", status: 200 }));\r\n    } else if (url === "/created" && method === "POST") {\r\n      // 201 Created - Usado cuando se crea un nuevo recurso\r\n      res.writeHead(201, {\r\n        "Content-Type": "application/json",\r\n        Location: "/resources/123", // URI del nuevo recurso\r\n      });\r\n      res.end(\r\n        JSON.stringify({\r\n          message: "Recurso creado exitosamente",\r\n          id: 123,\r\n          status: 201,\r\n        })\r\n      );\r\n    } else if (url === "/no-content") {\r\n      // 204 No Content - \xc9xito sin contenido en el cuerpo\r\n      res.writeHead(204);\r\n      res.end(); // Sin cuerpo de respuesta\r\n    } else if (url === "/bad-request") {\r\n      // 400 Bad Request - Solicitud mal formada\r\n      res.writeHead(400, { "Content-Type": "application/json" });\r\n      res.end(\r\n        JSON.stringify({\r\n          error: "Solicitud inv\xe1lida",\r\n          details: "Faltan campos requeridos",\r\n          status: 400,\r\n        })\r\n      );\r\n    } else if (url === "/unauthorized") {\r\n      // 401 Unauthorized - No autenticado\r\n      res.writeHead(401, {\r\n        "Content-Type": "application/json",\r\n        "WWW-Authenticate": \'Basic realm="Acceso restringido"\',\r\n      });\r\n      res.end(\r\n        JSON.stringify({\r\n          error: "No autorizado",\r\n          message: "Se requiere autenticaci\xf3n",\r\n          status: 401,\r\n        })\r\n      );\r\n    } else if (url === "/method-not-allowed") {\r\n      // 405 Method Not Allowed\r\n      res.writeHead(405, {\r\n        "Content-Type": "application/json",\r\n        Allow: "GET, POST", // M\xe9todos permitidos para este endpoint\r\n      });\r\n      res.end(\r\n        JSON.stringify({\r\n          error: "M\xe9todo no permitido",\r\n          allowedMethods: ["GET", "POST"],\r\n          status: 405,\r\n        })\r\n      );\r\n    } else if (url === "/redirect-permanent") {\r\n      // 301 Moved Permanently - Redirecci\xf3n permanente\r\n      res.writeHead(301, {\r\n        Location: "/success",\r\n        "Content-Type": "text/plain",\r\n      });\r\n      res.end("Redirecci\xf3n permanente a /success");\r\n    } else if (url === "/not-found") {\r\n      res.writeHead(404, { "Content-Type": "application/json" });\r\n      res.end(\r\n        JSON.stringify({\r\n          error: "Recurso no encontrado",\r\n          requestedUrl: url,\r\n          status: 404,\r\n        })\r\n      );\r\n    } else if (url === "/server-error") {\r\n      // Simular un error del servidor\r\n      res.writeHead(500, { "Content-Type": "application/json" });\r\n      res.end(\r\n        JSON.stringify({\r\n          error: "Error interno del servidor",\r\n          message: "Algo sali\xf3 mal en el servidor",\r\n          status: 500,\r\n        })\r\n      );\r\n    } else {\r\n      // Ruta no encontrada\r\n      res.writeHead(404, { "Content-Type": "application/json" });\r\n      res.end(\r\n        JSON.stringify({\r\n          error: "Endpoint no encontrado",\r\n          availableEndpoints: [\r\n            "/",\r\n            "/success",\r\n            "/created",\r\n            "/no-content",\r\n            "/not-found",\r\n            "/server-error",\r\n            "/redirect",\r\n            "/bad-request",\r\n            "/unauthorized",\r\n            "/method-not-allowed",\r\n          ],\r\n          status: 404,\r\n        })\r\n      );\r\n    }\r\n  });\r\n}\r\n\r\n// DIFERENCIA ENTRE setHeader() Y writeHead():\r\n\r\nfunction diferenciaHeaders() {\r\n  const server = http.createServer((req, res) => {\r\n    // setHeader() - Establece un header individual\r\n    // Se puede llamar m\xfaltiples veces para diferentes headers\r\n    res.setHeader("Content-Type", "application/json");\r\n    res.setHeader("X-Custom-Header", "valor personalizado");\r\n\r\n    // writeHead() - Establece el c\xf3digo de estado y puede sobrescribir headers\r\n    // Debe llamarse antes de end() y despu\xe9s de setHeader()\r\n    // Los headers en writeHead() sobrescriben los establecidos con setHeader()\r\n    res.writeHead(200, {\r\n      "Content-Type": "text/plain", // Sobrescribe el Content-Type anterior\r\n      "X-Another-Header": "otro valor",\r\n    });\r\n\r\n    res.end("Respuesta con headers mixtos");\r\n  });\r\n}\n'})}),"\n",(0,s.jsx)(r.p,{children:(0,s.jsx)(r.strong,{children:"RESUMEN DE HEADERS COMUNES:"})}),"\n",(0,s.jsxs)(r.ul,{children:["\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.strong,{children:(0,s.jsx)(r.code,{children:"Content-Type"})}),": Tipo de contenido (text/html, application/json, etc.)"]}),"\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.strong,{children:(0,s.jsx)(r.code,{children:"Location"})}),": Para redirecciones (302, 301)"]}),"\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.strong,{children:(0,s.jsx)(r.code,{children:"Cache-Control"})}),": Control de cach\xe9"]}),"\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.strong,{children:(0,s.jsx)(r.code,{children:"Access-Control-Allow-Origin"})}),": Control CORS"]}),"\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.strong,{children:(0,s.jsx)(r.code,{children:"X-Powered-By"})}),": Header personalizado para informaci\xf3n del servidor"]}),"\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.strong,{children:(0,s.jsx)(r.code,{children:"WWW-Authenticate"})}),": Esquema de autenticaci\xf3n requerido"]}),"\n"]}),"\n",(0,s.jsx)(r.p,{children:"Este servidor demuestra el uso correcto de c\xf3digos de estado HTTP y headers, que es fundamental para construir APIs RESTful y aplicaciones web profesionales."}),"\n",(0,s.jsx)(r.h2,{id:"servidor-http-con-enrutamiento-completo",children:"Servidor HTTP con Enrutamiento Completo"}),"\n",(0,s.jsx)(r.p,{children:"Te explico este servidor HTTP completo con enrutamiento en partes:"}),"\n",(0,s.jsx)(r.p,{children:(0,s.jsx)(r.strong,{children:"PRIMERA PARTE: CONFIGURACI\xd3N INICIAL Y MANEJO DE CORS"})}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-jsx",children:'import http from "http";\r\nimport { URL } from "url";\r\n\r\nconst server = http.createServer(async (req, res) => {\r\n  // Parsear URL para obtener pathname y par\xe1metros de consulta\r\n  // Se construye la URL completa usando el host de los headers\r\n  const parsedUrl = new URL(req.url, `http://${req.headers.host}`);\r\n  const pathname = parsedUrl.pathname;\r\n  const queryParams = parsedUrl.searchParams;\r\n\r\n  // Configurar CORS para desarrollo\r\n  // Permite solicitudes desde cualquier origen (*)\r\n  res.setHeader("Access-Control-Allow-Origin", "*");\r\n  res.setHeader(\r\n    "Access-Control-Allow-Methods",\r\n    "GET, POST, PUT, DELETE, OPTIONS"\r\n  );\r\n  res.setHeader("Access-Control-Allow-Headers", "Content-Type, Authorization");\r\n\r\n  // Manejar preflight requests (CORS)\r\n  // Las solicitudes OPTIONS son enviadas por el navegador antes de requests complejos\r\n  if (req.method === "OPTIONS") {\r\n    res.writeHead(204); // No Content\r\n    res.end();\r\n    return; // Terminar la ejecuci\xf3n aqu\xed para preflight\r\n  }\r\n\r\n  try {\r\n    // Enrutamiento basado en m\xe9todo y ruta\r\n    // Se usa switch(true) para evaluar m\xfaltiples condiciones\r\n    switch (true) {\r\n      case req.method === "GET" && pathname === "/":\r\n        await handleHome(req, res);\r\n        break;\r\n\r\n      case req.method === "GET" && pathname === "/api/users":\r\n        await handleGetUsers(req, res, queryParams);\r\n        break;\r\n\r\n      case req.method === "GET" && pathname.startsWith("/api/users/"):\r\n        await handleGetUserById(req, res, pathname);\r\n        break;\r\n\r\n      case req.method === "POST" && pathname === "/api/users":\r\n        await handleCreateUser(req, res);\r\n        break;\r\n\r\n      case req.method === "PUT" && pathname.startsWith("/api/users/"):\r\n        await handleUpdateUser(req, res, pathname);\r\n        break;\r\n\r\n      case req.method === "DELETE" && pathname.startsWith("/api/users/"):\r\n        await handleDeleteUser(req, res, pathname);\r\n        break;\r\n\r\n      default:\r\n        handleNotFound(res);\r\n    }\r\n  } catch (error) {\r\n    handleServerError(res, error);\r\n  }\r\n});\n'})}),"\n",(0,s.jsx)(r.p,{children:(0,s.jsx)(r.strong,{children:"SEGUNDA PARTE: MANEJADOR DE LA P\xc1GINA PRINCIPAL Y DATOS"})}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-jsx",children:'// Manejador para la ruta ra\xedz\r\nasync function handleHome(req, res) {\r\n  const htmlResponse = `\r\n        <!DOCTYPE html>\r\n        <html>\r\n        <head>\r\n            <title>Servidor Node.js HTTP</title>\r\n        </head>\r\n        <body>\r\n            <h1>Bienvenido al Servidor HTTP</h1>\r\n            <p>Este es un servidor construido con el m\xf3dulo nativo HTTP de Node.js</p>\r\n            <ul>\r\n                <li><a href="/api/users">Ver usuarios (GET)</a></li>\r\n                <li>Crear usuario (POST) - Usar herramienta como Postman</li>\r\n            </ul>\r\n        </body>\r\n        </html>\r\n    `;\r\n\r\n  res.writeHead(200, { "Content-Type": "text/html" });\r\n  res.end(htmlResponse);\r\n}\r\n\r\n// Datos de ejemplo (simulando una base de datos)\r\nconst users = [\r\n  { id: 1, name: "Ana Garc\xeda", email: "ana@ejemplo.com", active: true },\r\n  { id: 2, name: "Carlos L\xf3pez", email: "carlos@ejemplo.com", active: true },\r\n  { id: 3, name: "Mar\xeda Rodr\xedguez", email: "maria@ejemplo.com", active: false },\r\n];\n'})}),"\n",(0,s.jsx)(r.p,{children:(0,s.jsx)(r.strong,{children:"TERCERA PARTE: MANEJADORES GET - LECTURA DE DATOS"})}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-jsx",children:'// Manejador para obtener todos los usuarios\r\nasync function handleGetUsers(req, res, queryParams) {\r\n  // Filtrar usuarios activos si se solicita mediante par\xe1metro de consulta\r\n  // Ejemplo: /api/users?active=true\r\n  const onlyActive = queryParams.get("active") === "true";\r\n  let usersToReturn = users;\r\n\r\n  if (onlyActive) {\r\n    usersToReturn = users.filter((user) => user.active);\r\n  }\r\n\r\n  res.writeHead(200, { "Content-Type": "application/json" });\r\n  res.end(\r\n    JSON.stringify({\r\n      success: true,\r\n      data: usersToReturn,\r\n      count: usersToReturn.length,\r\n    })\r\n  );\r\n}\r\n\r\n// Manejador para obtener usuario por ID\r\nasync function handleGetUserById(req, res, pathname) {\r\n  // Extraer el ID de la ruta: /api/users/123 \u2192 123\r\n  const userId = parseInt(pathname.split("/").pop());\r\n\r\n  // Validar que el ID sea un n\xfamero v\xe1lido\r\n  if (isNaN(userId)) {\r\n    res.writeHead(400, { "Content-Type": "application/json" });\r\n    res.end(\r\n      JSON.stringify({\r\n        success: false,\r\n        error: "ID de usuario inv\xe1lido",\r\n      })\r\n    );\r\n    return;\r\n  }\r\n\r\n  // Buscar usuario en el array\r\n  const user = users.find((u) => u.id === userId);\r\n\r\n  if (!user) {\r\n    res.writeHead(404, { "Content-Type": "application/json" });\r\n    res.end(\r\n      JSON.stringify({\r\n        success: false,\r\n        error: "Usuario no encontrado",\r\n      })\r\n    );\r\n    return;\r\n  }\r\n\r\n  res.writeHead(200, { "Content-Type": "application/json" });\r\n  res.end(\r\n    JSON.stringify({\r\n      success: true,\r\n      data: user,\r\n    })\r\n  );\r\n}\n'})}),"\n",(0,s.jsx)(r.p,{children:(0,s.jsx)(r.strong,{children:"CUARTA PARTE: MANEJADORES POST - CREACI\xd3N DE DATOS"})}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-jsx",children:'// Manejador para crear usuario\r\nasync function handleCreateUser(req, res) {\r\n  let body = "";\r\n\r\n  // Recibir datos del body en chunks (fragmentos)\r\n  // En HTTP, el cuerpo de la solicitud puede llegar en m\xfaltiples partes\r\n  req.on("data", (chunk) => {\r\n    body += chunk.toString();\r\n  });\r\n\r\n  // Cuando se reciben todos los datos\r\n  req.on("end", () => {\r\n    try {\r\n      // Parsear el JSON recibido\r\n      const userData = JSON.parse(body);\r\n\r\n      // Validaciones b\xe1sicas de campos requeridos\r\n      if (!userData.name || !userData.email) {\r\n        res.writeHead(400, { "Content-Type": "application/json" });\r\n        res.end(\r\n          JSON.stringify({\r\n            success: false,\r\n            error: "Nombre y email son requeridos",\r\n          })\r\n        );\r\n        return;\r\n      }\r\n\r\n      // Crear nuevo usuario con ID autoincremental\r\n      const newUser = {\r\n        id: users.length + 1,\r\n        name: userData.name,\r\n        email: userData.email,\r\n        active: userData.active !== undefined ? userData.active : true,\r\n      };\r\n\r\n      // Agregar al array (en producci\xf3n ser\xeda INSERT en base de datos)\r\n      users.push(newUser);\r\n\r\n      // Retornar 201 Created con el nuevo usuario\r\n      res.writeHead(201, { "Content-Type": "application/json" });\r\n      res.end(\r\n        JSON.stringify({\r\n          success: true,\r\n          data: newUser,\r\n          message: "Usuario creado exitosamente",\r\n        })\r\n      );\r\n    } catch (error) {\r\n      // Error al parsear JSON\r\n      res.writeHead(400, { "Content-Type": "application/json" });\r\n      res.end(\r\n        JSON.stringify({\r\n          success: false,\r\n          error: "JSON inv\xe1lido en el cuerpo de la petici\xf3n",\r\n        })\r\n      );\r\n    }\r\n  });\r\n}\n'})}),"\n",(0,s.jsx)(r.p,{children:(0,s.jsx)(r.strong,{children:"QUINTA PARTE: MANEJADORES PUT Y DELETE - ACTUALIZACI\xd3N Y ELIMINACI\xd3N"})}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-jsx",children:'// Manejador para actualizar usuario\r\nasync function handleUpdateUser(req, res, pathname) {\r\n  const userId = parseInt(pathname.split("/").pop());\r\n\r\n  if (isNaN(userId)) {\r\n    res.writeHead(400, { "Content-Type": "application/json" });\r\n    res.end(JSON.stringify({ success: false, error: "ID inv\xe1lido" }));\r\n    return;\r\n  }\r\n\r\n  let body = "";\r\n\r\n  req.on("data", (chunk) => {\r\n    body += chunk.toString();\r\n  });\r\n\r\n  req.on("end", () => {\r\n    try {\r\n      // Buscar \xedndice del usuario a actualizar\r\n      const userIndex = users.findIndex((u) => u.id === userId);\r\n\r\n      if (userIndex === -1) {\r\n        res.writeHead(404, { "Content-Type": "application/json" });\r\n        res.end(\r\n          JSON.stringify({ success: false, error: "Usuario no encontrado" })\r\n        );\r\n        return;\r\n      }\r\n\r\n      // Parsear datos de actualizaci\xf3n\r\n      const updateData = JSON.parse(body);\r\n\r\n      // Actualizar usuario manteniendo propiedades existentes y sobreescribiendo las nuevas\r\n      // El spread operator (...) combina los objetos\r\n      users[userIndex] = { ...users[userIndex], ...updateData };\r\n\r\n      res.writeHead(200, { "Content-Type": "application/json" });\r\n      res.end(\r\n        JSON.stringify({\r\n          success: true,\r\n          data: users[userIndex],\r\n          message: "Usuario actualizado exitosamente",\r\n        })\r\n      );\r\n    } catch (error) {\r\n      res.writeHead(400, { "Content-Type": "application/json" });\r\n      res.end(JSON.stringify({ success: false, error: "JSON inv\xe1lido" }));\r\n    }\r\n  });\r\n}\r\n\r\n// Manejador para eliminar usuario\r\nasync function handleDeleteUser(req, res, pathname) {\r\n  const userId = parseInt(pathname.split("/").pop());\r\n\r\n  if (isNaN(userId)) {\r\n    res.writeHead(400, { "Content-Type": "application/json" });\r\n    res.end(JSON.stringify({ success: false, error: "ID inv\xe1lido" }));\r\n    return;\r\n  }\r\n\r\n  // Buscar \xedndice del usuario\r\n  const userIndex = users.findIndex((u) => u.id === userId);\r\n\r\n  if (userIndex === -1) {\r\n    res.writeHead(404, { "Content-Type": "application/json" });\r\n    res.end(JSON.stringify({ success: false, error: "Usuario no encontrado" }));\r\n    return;\r\n  }\r\n\r\n  // Eliminar usuario del array (en producci\xf3n ser\xeda soft delete)\r\n  users.splice(userIndex, 1);\r\n\r\n  res.writeHead(200, { "Content-Type": "application/json" });\r\n  res.end(\r\n    JSON.stringify({\r\n      success: true,\r\n      message: "Usuario eliminado exitosamente",\r\n    })\r\n  );\r\n}\n'})}),"\n",(0,s.jsx)(r.p,{children:(0,s.jsx)(r.strong,{children:"SEXTA PARTE: MANEJADORES DE ERRORES Y CONFIGURACI\xd3N FINAL"})}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-jsx",children:'// Manejador para rutas no encontradas\r\nfunction handleNotFound(res) {\r\n  res.writeHead(404, { "Content-Type": "application/json" });\r\n  res.end(\r\n    JSON.stringify({\r\n      success: false,\r\n      error: "Endpoint no encontrado",\r\n      message: "La ruta solicitada no existe en este servidor",\r\n    })\r\n  );\r\n}\r\n\r\n// Manejador de errores del servidor\r\nfunction handleServerError(res, error) {\r\n  console.error("Error del servidor:", error);\r\n\r\n  res.writeHead(500, { "Content-Type": "application/json" });\r\n  res.end(\r\n    JSON.stringify({\r\n      success: false,\r\n      error: "Error interno del servidor",\r\n      // En desarrollo muestra el mensaje de error, en producci\xf3n mensaje gen\xe9rico\r\n      message:\r\n        process.env.NODE_ENV === "development"\r\n          ? error.message\r\n          : "Algo sali\xf3 mal",\r\n    })\r\n  );\r\n}\r\n\r\nconst PORT = process.env.PORT || 3000;\r\nserver.listen(PORT, () => {\r\n  console.log(`Servidor API REST ejecut\xe1ndose en <http://localhost>:${PORT}`);\r\n  console.log(`Entorno: ${process.env.NODE_ENV || "development"}`);\r\n});\n'})}),"\n",(0,s.jsx)(r.p,{children:(0,s.jsx)(r.strong,{children:"CARACTER\xcdSTICAS PRINCIPALES DEL SERVIDOR:"})}),"\n",(0,s.jsxs)(r.ul,{children:["\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.strong,{children:"Arquitectura RESTful"}),": Sigue convenciones REST para rutas y m\xe9todos HTTP"]}),"\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.strong,{children:"CRUD Completo"}),": Create, Read, Update, Delete para recursos de usuario"]}),"\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.strong,{children:"Manejo de CORS"}),": Configuraci\xf3n para desarrollo y preflight requests"]}),"\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.strong,{children:"Validaci\xf3n de Datos"}),": Validaci\xf3n b\xe1sica de entradas y JSON"]}),"\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.strong,{children:"Manejo de Errores"}),": Centralizado con c\xf3digos de estado HTTP apropiados"]}),"\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.strong,{children:"Parsing de Cuerpo"}),": Manejo de datos POST/PUT en formato JSON"]}),"\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.strong,{children:"Variables de Entorno"}),": Configuraci\xf3n flexible de puerto y entorno"]}),"\n"]}),"\n",(0,s.jsx)(r.p,{children:"Este servidor representa una implementaci\xf3n completa de una API REST usando solo el m\xf3dulo HTTP nativo de Node.js, sin dependencias externas."}),"\n",(0,s.jsx)(r.h2,{id:"cliente-http-para-hacer-peticiones",children:"Cliente HTTP para Hacer Peticiones"}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-jsx",children:'import http from "http";\r\nimport https from "https";\r\n\r\n// Funci\xf3n para hacer peticiones HTTP/HTTPS\r\n// Esta funci\xf3n envuelve el m\xf3dulo nativo en una Promise para usar async/await\r\nfunction httpRequest(options, data = null) {\r\n  return new Promise((resolve, reject) => {\r\n    // Determinar si es HTTP o HTTPS basado en el protocolo en las opciones\r\n    // options.protocol puede ser \'http:\' o \'https:\'\r\n    const protocol = options.protocol === "https:" ? https : http;\r\n\r\n    // Crear la solicitud HTTP/HTTPS\r\n    // protocol.request() retorna un objeto ClientRequest\r\n    const req = protocol.request(options, (res) => {\r\n      // res es un objeto IncomingMessage que representa la respuesta\r\n      let responseData = "";\r\n\r\n      // Evento \'data\': se dispara cuando llegan chunks de datos\r\n      // En HTTP, la respuesta puede llegar en m\xfaltiples fragmentos\r\n      res.on("data", (chunk) => {\r\n        responseData += chunk; // Acumular los chunks\r\n      });\r\n\r\n      // Evento \'end\': se dispara cuando se completa la recepci\xf3n de datos\r\n      res.on("end", () => {\r\n        // Resolver la Promise con un objeto que contiene:\r\n        resolve({\r\n          statusCode: res.statusCode, // C\xf3digo de estado HTTP (200, 404, etc.)\r\n          headers: res.headers, // Headers de la respuesta\r\n          data: responseData, // Datos acumulados como string\r\n        });\r\n      });\r\n    });\r\n\r\n    // Manejar errores de la solicitud\r\n    // Pueden ser errores de conexi\xf3n, timeout, DNS, etc.\r\n    req.on("error", (error) => {\r\n      reject(error); // Rechazar la Promise con el error\r\n    });\r\n\r\n    // Opcional: Si hay datos para enviar en el cuerpo (POST, PUT, PATCH)\r\n    if (data) {\r\n      req.write(data); // Escribir los datos en el cuerpo de la solicitud\r\n    }\r\n\r\n    // Finalizar la solicitud\r\n    // Esto env\xeda la solicitud al servidor\r\n    req.end();\r\n  });\r\n}\r\n\r\n// Ejemplos de uso del cliente HTTP\r\nasync function examples() {\r\n  try {\r\n    // EJEMPLO 1: PETICI\xd3N GET - Obtener datos\r\n    console.log("=== EJEMPLO 1: PETICI\xd3N GET ===");\r\n\r\n    const getResponse = await httpRequest({\r\n      hostname: "jsonplaceholder.typicode.com", // Dominio del servidor\r\n      port: 443, // Puerto HTTPS\r\n      path: "/posts/1", // Ruta del recurso\r\n      method: "GET", // M\xe9todo HTTP\r\n      protocol: "https:", // Protocolo a usar\r\n      headers: {\r\n        "Content-Type": "application/json", // Tipo de contenido esperado\r\n        "User-Agent": "Node.js-HTTP-Client/1.0", // Identificar nuestro cliente\r\n      },\r\n    });\r\n\r\n    console.log("Status Code:", getResponse.statusCode);\r\n    console.log("GET Response:", JSON.parse(getResponse.data));\r\n\r\n    // EJEMPLO 2: PETICI\xd3N POST - Crear nuevo recurso\r\n    console.log("\\n=== EJEMPLO 2: PETICI\xd3N POST ===");\r\n\r\n    // Datos a enviar en el cuerpo de la solicitud\r\n    const postData = JSON.stringify({\r\n      title: "Mi nuevo post",\r\n      body: "Contenido del post creado desde Node.js",\r\n      userId: 1,\r\n    });\r\n\r\n    const postResponse = await httpRequest(\r\n      {\r\n        hostname: "jsonplaceholder.typicode.com",\r\n        port: 443,\r\n        path: "/posts",\r\n        method: "POST",\r\n        protocol: "https:",\r\n        headers: {\r\n          "Content-Type": "application/json",\r\n          "Content-Length": Buffer.byteLength(postData), // Longitud del cuerpo en bytes\r\n          "User-Agent": "Node.js-HTTP-Client/1.0",\r\n        },\r\n      },\r\n      postData\r\n    ); // Pasar los datos como segundo par\xe1metro\r\n\r\n    console.log("Status Code:", postResponse.statusCode);\r\n    console.log("POST Response:", JSON.parse(postResponse.data));\r\n  } catch (error) {\r\n    console.error("Error en petici\xf3n HTTP:", error);\r\n  }\r\n}\r\n\r\n// M\xc1S EJEMPLOS DE USO PR\xc1CTICO:\r\n\r\nasync function ejemplosAvanzados() {\r\n  try {\r\n    // EJEMPLO 3: PETICI\xd3N CON TIMEOUT\r\n    console.log("\\n=== EJEMPLO 3: PETICI\xd3N CON TIMEOUT ===");\r\n\r\n    // Podemos agregar timeout manualmente con Promise.race()\r\n    const timeoutPromise = new Promise((_, reject) => {\r\n      setTimeout(\r\n        () => reject(new Error("Timeout despu\xe9s de 5 segundos")),\r\n        5000\r\n      );\r\n    });\r\n\r\n    const requestPromise = httpRequest({\r\n      hostname: "jsonplaceholder.typicode.com",\r\n      port: 443,\r\n      path: "/posts",\r\n      method: "GET",\r\n      protocol: "https:",\r\n    });\r\n\r\n    const response = await Promise.race([requestPromise, timeoutPromise]);\r\n    console.log("Petici\xf3n completada antes del timeout");\r\n\r\n    // EJEMPLO 4: PETICI\xd3N CON PAR\xc1METROS DE QUERY\r\n    console.log("\\n=== EJEMPLO 4: PETICI\xd3N CON QUERY PARAMS ===");\r\n\r\n    const queryParams = new URLSearchParams({\r\n      userId: 1,\r\n      _limit: 5,\r\n    }).toString();\r\n\r\n    const queryResponse = await httpRequest({\r\n      hostname: "jsonplaceholder.typicode.com",\r\n      port: 443,\r\n      path: `/posts?${queryParams}`, // Incluir par\xe1metros en la ruta\r\n      method: "GET",\r\n      protocol: "https:",\r\n    });\r\n\r\n    const posts = JSON.parse(queryResponse.data);\r\n    console.log(`Recibidos ${posts.length} posts del usuario 1`);\r\n\r\n    // EJEMPLO 5: MANEJO DE ERRORES ESPEC\xcdFICOS\r\n    console.log("\\n=== EJEMPLO 5: MANEJO DE ERRORES ===");\r\n\r\n    try {\r\n      // Intentar acceder a un recurso que no existe\r\n      await httpRequest({\r\n        hostname: "jsonplaceholder.typicode.com",\r\n        port: 443,\r\n        path: "/posts/9999", // Probablemente no exista\r\n        method: "GET",\r\n        protocol: "https:",\r\n      });\r\n    } catch (error) {\r\n      console.log("Error capturado:", error.message);\r\n    }\r\n  } catch (error) {\r\n    console.error("Error en ejemplos avanzados:", error);\r\n  }\r\n}\r\n\r\n// VERSI\xd3N MEJORADA DEL CLIENTE HTTP:\r\n\r\nfunction httpRequestMejorada(options, data = null) {\r\n  return new Promise((resolve, reject) => {\r\n    const protocol = options.protocol === "https:" ? https : http;\r\n\r\n    // Agregar timeout a la solicitud\r\n    const req = protocol.request(options, (res) => {\r\n      let responseData = "";\r\n      let statusCode = res.statusCode;\r\n\r\n      res.on("data", (chunk) => {\r\n        responseData += chunk;\r\n      });\r\n\r\n      res.on("end", () => {\r\n        // Determinar si fue exitoso basado en el c\xf3digo de estado\r\n        const esExitoso = statusCode >= 200 && statusCode < 300;\r\n\r\n        const resultado = {\r\n          exito: esExitoso,\r\n          statusCode: statusCode,\r\n          statusMessage: res.statusMessage,\r\n          headers: res.headers,\r\n          data: responseData,\r\n        };\r\n\r\n        if (esExitoso) {\r\n          resolve(resultado);\r\n        } else {\r\n          // Para c\xf3digos de error HTTP, a\xfan resolvemos pero con exito: false\r\n          resolve(resultado);\r\n        }\r\n      });\r\n    });\r\n\r\n    // Manejar timeout\r\n    req.setTimeout(10000, () => {\r\n      req.destroy(); // Destruir la solicitud\r\n      reject(new Error("Timeout de la solicitud HTTP"));\r\n    });\r\n\r\n    req.on("error", (error) => {\r\n      reject(error);\r\n    });\r\n\r\n    if (data) {\r\n      req.write(data);\r\n    }\r\n\r\n    req.end();\r\n  });\r\n}\r\n\r\n// EJEMPLO DE USO EN UNA APLICACI\xd3N REAL:\r\n\r\nclass APIClient {\r\n  constructor(baseURL, defaultHeaders = {}) {\r\n    this.baseURL = baseURL;\r\n    this.defaultHeaders = {\r\n      "User-Agent": "MiApp/1.0",\r\n      ...defaultHeaders,\r\n    };\r\n  }\r\n\r\n  async get(endpoint, headers = {}) {\r\n    const url = new URL(endpoint, this.baseURL);\r\n\r\n    return await httpRequestMejorada({\r\n      hostname: url.hostname,\r\n      port: url.port || (url.protocol === "https:" ? 443 : 80),\r\n      path: url.pathname + url.search,\r\n      method: "GET",\r\n      protocol: url.protocol,\r\n      headers: { ...this.defaultHeaders, ...headers },\r\n    });\r\n  }\r\n\r\n  async post(endpoint, data, headers = {}) {\r\n    const url = new URL(endpoint, this.baseURL);\r\n    const body = JSON.stringify(data);\r\n\r\n    return await httpRequestMejorada(\r\n      {\r\n        hostname: url.hostname,\r\n        port: url.port || (url.protocol === "https:" ? 443 : 80),\r\n        path: url.pathname,\r\n        method: "POST",\r\n        protocol: url.protocol,\r\n        headers: {\r\n          ...this.defaultHeaders,\r\n          "Content-Type": "application/json",\r\n          "Content-Length": Buffer.byteLength(body),\r\n          ...headers,\r\n        },\r\n      },\r\n      body\r\n    );\r\n  }\r\n}\r\n\r\n// USO DEL CLIENTE DE API:\r\n\r\nasync function usarAPIClient() {\r\n  const api = new APIClient("https://jsonplaceholder.typicode.com");\r\n\r\n  try {\r\n    // Usar los m\xe9todos simplificados\r\n    const usuarios = await api.get("/users");\r\n    console.log("Usuarios:", JSON.parse(usuarios.data));\r\n\r\n    const nuevoPost = await api.post("/posts", {\r\n      title: "Post desde APIClient",\r\n      body: "Contenido del post",\r\n      userId: 1,\r\n    });\r\n    console.log("Nuevo post creado:", JSON.parse(nuevoPost.data));\r\n  } catch (error) {\r\n    console.error("Error con APIClient:", error);\r\n  }\r\n}\r\n\r\n// Ejecutar todos los ejemplos\r\nasync function ejecutarTodosLosEjemplos() {\r\n  console.log("\ud83d\ude80 INICIANDO EJEMPLOS DE CLIENTE HTTP\\n");\r\n\r\n  await examples();\r\n  await ejemplosAvanzados();\r\n  await usarAPIClient();\r\n\r\n  console.log("\\n\u2705 TODOS LOS EJEMPLOS COMPLETADOS");\r\n}\r\n\r\n// Descomentar para ejecutar:\r\n// ejecutarTodosLosEjemplos();\r\n\r\n// RESUMEN DE CARACTER\xcdSTICAS PRINCIPALES:\r\n\r\n// 1. \u2705 Soporte para HTTP y HTTPS\r\n// 2. \u2705 Interface basada en Promises para async/await\r\n// 3. \u2705 Env\xedo de datos en solicitudes POST/PUT\r\n// 4. \u2705 Manejo de errores de conexi\xf3n y timeout\r\n// 5. \u2705 Configuraci\xf3n flexible de headers\r\n// 6. \u2705 Acumulaci\xf3n autom\xe1tica de datos de respuesta\r\n// 7. \u2705 Retorno de status code y headers de respuesta\r\n\r\n// CASOS DE USO COMUNES:\r\n\r\n// - Consumir APIs REST externas\r\n// - Hacer web scraping\r\n// - Comunicaci\xf3n entre microservicios\r\n// - Integraci\xf3n con servicios de terceros\r\n// - Testing de endpoints HTTP\n'})}),"\n",(0,s.jsx)(r.h2,{id:"servidor-http-con-manejo-de-archivos-est\xe1ticos",children:"Servidor HTTP con Manejo de Archivos Est\xe1ticos"}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-jsx",children:'// Importar m\xf3dulos necesarios\r\nimport http from "http"; // M\xf3dulo para crear servidor HTTP\r\nimport fs from "fs/promises"; // M\xf3dulo de sistema de archivos con Promises\r\nimport path from "path"; // M\xf3dulo para manejar rutas de archivos\r\nimport { fileURLToPath } from "url"; // Utilidad para obtener __dirname en ES Modules\r\n\r\n// Obtener __filename y __dirname equivalentes en ES Modules\r\n// En CommonJS estas variables est\xe1n disponibles globalmente, pero en ES Modules necesitamos crearlas\r\nconst __filename = fileURLToPath(import.meta.url);\r\nconst __dirname = path.dirname(__filename);\r\n\r\n// Crear servidor HTTP\r\nconst server = http.createServer(async (req, res) => {\r\n  // Este servidor solo sirve archivos est\xe1ticos, por eso solo acepta m\xe9todos GET\r\n  if (req.method === "GET") {\r\n    try {\r\n      // Determinar la ruta del archivo a servir\r\n      // Si la URL es \'/\' (ra\xedz), servir index.html por defecto\r\n      // Si la URL es otra (/about.html, /styles.css, etc.), usar esa ruta\r\n      let filePath = req.url === "/" ? "/index.html" : req.url;\r\n\r\n      // Construir la ruta completa al archivo\r\n      // path.join() es seguro y maneja autom\xe1ticamente las diferencias entre sistemas operativos\r\n      filePath = path.join(__dirname, "public", filePath);\r\n\r\n      // Leer el archivo del sistema de archivos\r\n      // fs.readFile() con await porque fs/promises retorna Promises\r\n      const content = await fs.readFile(filePath);\r\n\r\n      // Determinar el tipo MIME basado en la extensi\xf3n del archivo\r\n      // Esto es crucial para que el navegador sepa c\xf3mo interpretar el contenido\r\n      const extname = path.extname(filePath);\r\n\r\n      // Mapeo de extensiones a tipos MIME\r\n      const mimeTypes = {\r\n        ".html": "text/html", // P\xe1ginas HTML\r\n        ".css": "text/css", // Hojas de estilo\r\n        ".js": "application/javascript", // C\xf3digo JavaScript\r\n        ".png": "image/png", // Im\xe1genes PNG\r\n        ".jpg": "image/jpeg", // Im\xe1genes JPEG\r\n        ".gif": "image/gif", // Im\xe1genes GIF\r\n        ".json": "application/json", // Datos JSON\r\n      };\r\n\r\n      // Obtener el Content-Type apropiado o usar \'application/octet-stream\' como predeterminado\r\n      const contentType = mimeTypes[extname] || "application/octet-stream";\r\n\r\n      // Configurar respuesta exitosa\r\n      res.writeHead(200, { "Content-Type": contentType });\r\n\r\n      // Enviar el contenido del archivo\r\n      res.end(content);\r\n    } catch (error) {\r\n      // Manejo de errores al leer archivos\r\n\r\n      if (error.code === "ENOENT") {\r\n        // ENOENT = Error NO ENTity - El archivo no existe\r\n        res.writeHead(404, { "Content-Type": "text/html" });\r\n        res.end("<h1>404 - Archivo no encontrado</h1>");\r\n      } else {\r\n        // Cualquier otro error (permisos, archivo corrupto, etc.)\r\n        console.error("Error del servidor:", error);\r\n        res.writeHead(500, { "Content-Type": "text/html" });\r\n        res.end("<h1>500 - Error interno del servidor</h1>");\r\n      }\r\n    }\r\n  } else {\r\n    // Si el m\xe9todo no es GET, retornar error 405 Method Not Allowed\r\n    // Este servidor solo sirve para leer archivos, no acepta POST, PUT, etc.\r\n    res.writeHead(405, { "Content-Type": "text/plain" });\r\n    res.end("M\xe9todo no permitido");\r\n  }\r\n});\r\n\r\n// Iniciar el servidor en el puerto 3000\r\nserver.listen(3000, () => {\r\n  console.log("Servidor de archivos est\xe1ticos en http://localhost:3000");\r\n});\r\n\r\n// EJEMPLO DE ESTRUCTURA DE CARPETAS NECESARIA:\r\n\r\n/*\r\nmi-proyecto/\r\n\u251c\u2500\u2500 server.js (este archivo)\r\n\u2514\u2500\u2500 public/\r\n    \u251c\u2500\u2500 index.html\r\n    \u251c\u2500\u2500 about.html\r\n    \u251c\u2500\u2500 styles/\r\n    \u2502   \u2514\u2500\u2500 main.css\r\n    \u251c\u2500\u2500 js/\r\n    \u2502   \u2514\u2500\u2500 app.js\r\n    \u2514\u2500\u2500 images/\r\n        \u251c\u2500\u2500 logo.png\r\n        \u2514\u2500\u2500 background.jpg\r\n*/\r\n\r\n// EJEMPLO DE ARCHIVOS QUE PODR\xcdA CONTENER LA CARPETA PUBLIC:\r\n\r\n// public/index.html\r\nconst ejemploIndexHTML = `\r\n<!DOCTYPE html>\r\n<html>\r\n<head>\r\n    <title>Mi Sitio Est\xe1tico</title>\r\n    <link rel="stylesheet" href="/styles/main.css">\r\n</head>\r\n<body>\r\n    <h1>Bienvenido a mi sitio</h1>\r\n    <img src="/images/logo.png" alt="Logo">\r\n    <p>Este es un sitio servido con Node.js HTTP</p>\r\n    <script src="/js/app.js"><\/script>\r\n</body>\r\n</html>\r\n`;\r\n\r\n// public/styles/main.css\r\nconst ejemploCSS = `\r\nbody {\r\n    font-family: Arial, sans-serif;\r\n    margin: 0;\r\n    padding: 20px;\r\n    background-color: #f0f0f0;\r\n}\r\n\r\nh1 {\r\n    color: #333;\r\n}\r\n`;\r\n\r\n// public/js/app.js\r\nconst ejemploJS = `\r\nconsole.log(\'JavaScript cargado correctamente\');\r\ndocument.addEventListener(\'DOMContentLoaded\', function() {\r\n    console.log(\'P\xe1gina completamente cargada\');\r\n});\r\n`;\r\n\r\n// VERSI\xd3N MEJORADA CON M\xc1S CARACTER\xcdSTICAS:\r\n\r\nclass StaticFileServer {\r\n  constructor(publicFolder = "public", port = 3000) {\r\n    this.publicFolder = publicFolder;\r\n    this.port = port;\r\n    this.mimeTypes = {\r\n      ".html": "text/html",\r\n      ".css": "text/css",\r\n      ".js": "application/javascript",\r\n      ".png": "image/png",\r\n      ".jpg": "image/jpeg",\r\n      ".jpeg": "image/jpeg",\r\n      ".gif": "image/gif",\r\n      ".svg": "image/svg+xml",\r\n      ".json": "application/json",\r\n      ".txt": "text/plain",\r\n      ".ico": "image/x-icon",\r\n    };\r\n  }\r\n\r\n  async start() {\r\n    const server = http.createServer(async (req, res) => {\r\n      await this.handleRequest(req, res);\r\n    });\r\n\r\n    server.listen(this.port, () => {\r\n      console.log(\r\n        `Servidor de archivos est\xe1ticos en http://localhost:${this.port}`\r\n      );\r\n    });\r\n  }\r\n\r\n  async handleRequest(req, res) {\r\n    // Solo permitir m\xe9todos GET y HEAD\r\n    if (req.method !== "GET" && req.method !== "HEAD") {\r\n      res.writeHead(405, { "Content-Type": "text/plain" });\r\n      res.end("M\xe9todo no permitido");\r\n      return;\r\n    }\r\n\r\n    try {\r\n      // Prevenir directory traversal attacks\r\n      const safePath = this.getSafePath(req.url);\r\n\r\n      // Construir ruta completa\r\n      const filePath = path.join(__dirname, this.publicFolder, safePath);\r\n\r\n      // Verificar que el archivo est\xe9 dentro del directorio p\xfablico\r\n      if (!this.isPathSafe(filePath)) {\r\n        res.writeHead(403, { "Content-Type": "text/html" });\r\n        res.end("<h1>403 - Acceso prohibido</h1>");\r\n        return;\r\n      }\r\n\r\n      // Leer estad\xedsticas del archivo\r\n      const stats = await fs.stat(filePath);\r\n\r\n      if (stats.isDirectory()) {\r\n        // Si es directorio, servir index.html\r\n        const indexFilePath = path.join(filePath, "index.html");\r\n        await this.serveFile(indexFilePath, res);\r\n      } else {\r\n        // Si es archivo, servirlo directamente\r\n        await this.serveFile(filePath, res);\r\n      }\r\n    } catch (error) {\r\n      this.handleError(error, res);\r\n    }\r\n  }\r\n\r\n  getSafePath(url) {\r\n    // Limpiar la URL y prevenir directory traversal\r\n    let safePath = url.split("?")[0]; // Remover query parameters\r\n    safePath = safePath.split("#")[0]; // Remover fragmentos\r\n\r\n    // Si la ruta es vac\xeda o solo \'/\', servir index.html\r\n    if (safePath === "" || safePath === "/") {\r\n      return "/index.html";\r\n    }\r\n\r\n    return safePath;\r\n  }\r\n\r\n  isPathSafe(filePath) {\r\n    // Verificar que la ruta resuelta est\xe9 dentro del directorio p\xfablico\r\n    const publicDir = path.join(__dirname, this.publicFolder);\r\n    const resolvedPath = path.resolve(filePath);\r\n\r\n    return resolvedPath.startsWith(publicDir);\r\n  }\r\n\r\n  async serveFile(filePath, res) {\r\n    const content = await fs.readFile(filePath);\r\n    const extname = path.extname(filePath).toLowerCase();\r\n    const contentType = this.mimeTypes[extname] || "application/octet-stream";\r\n\r\n    res.writeHead(200, {\r\n      "Content-Type": contentType,\r\n      "Content-Length": content.length,\r\n    });\r\n\r\n    res.end(content);\r\n  }\r\n\r\n  handleError(error, res) {\r\n    if (error.code === "ENOENT") {\r\n      res.writeHead(404, { "Content-Type": "text/html" });\r\n      res.end(`\r\n                <!DOCTYPE html>\r\n                <html>\r\n                <head>\r\n                    <title>404 - No encontrado</title>\r\n                    <style>\r\n                        body { font-family: Arial, sans-serif; text-align: center; padding: 50px; }\r\n                        h1 { color: #d32f2f; }\r\n                    </style>\r\n                </head>\r\n                <body>\r\n                    <h1>404 - Archivo no encontrado</h1>\r\n                    <p>El recurso solicitado no existe en este servidor.</p>\r\n                    <a href="/">Volver al inicio</a>\r\n                </body>\r\n                </html>\r\n            `);\r\n    } else {\r\n      console.error("Error del servidor:", error);\r\n      res.writeHead(500, { "Content-Type": "text/html" });\r\n      res.end(`\r\n                <!DOCTYPE html>\r\n                <html>\r\n                <head>\r\n                    <title>500 - Error del servidor</title>\r\n                </head>\r\n                <body>\r\n                    <h1>500 - Error interno del servidor</h1>\r\n                    <p>Ha ocurrido un error inesperado.</p>\r\n                </body>\r\n                </html>\r\n            `);\r\n    }\r\n  }\r\n}\r\n\r\n// USO DE LA VERSI\xd3N MEJORADA:\r\n\r\n// Crear y iniciar servidor\r\n// const fileServer = new StaticFileServer(\'public\', 3000);\r\n// fileServer.start();\r\n\r\n// CARACTER\xcdSTICAS DE LA VERSI\xd3N MEJORADA:\r\n\r\n// 1. \u2705 Prevenci\xf3n de directory traversal attacks\r\n// 2. \u2705 Soporte para directorios (sirve index.html autom\xe1ticamente)\r\n// 3. \u2705 Manejo de m\xe9todos HEAD\r\n// 4. \u2705 P\xe1ginas de error m\xe1s informativas\r\n// 5. \u2705 Configuraci\xf3n flexible de carpeta p\xfablica y puerto\r\n// 6. \u2705 Validaci\xf3n de rutas seguras\r\n// 7. \u2705 Headers Content-Length para mejor performance\r\n\r\n// USOS PR\xc1CTICOS DE ESTE SERVIDOR:\r\n\r\n// 1. Desarrollo frontend: Servir archivos HTML, CSS, JS durante el desarrollo\r\n// 2. Prototipado r\xe1pido: Crear prototipos de sitios web est\xe1ticos\r\n// 3. Documentaci\xf3n: Servir documentaci\xf3n HTML est\xe1tica\r\n// 4. Aplicaciones SPA: Servir Single Page Applications\r\n// 5. Archivos de descarga: Servir archivos para descarga\r\n\r\n// EJEMPLO DE CONFIGURACI\xd3N PARA DIFERENTES ENTORNOS:\r\n\r\nfunction createServerForEnvironment() {\r\n  const environment = process.env.NODE_ENV || "development";\r\n  const publicFolder = environment === "production" ? "dist" : "public";\r\n  const port = process.env.PORT || 3000;\r\n\r\n  const server = new StaticFileServer(publicFolder, port);\r\n  server.start();\r\n\r\n  return server;\r\n}\r\n\r\n// Descomentar para usar:\r\n// createServerForEnvironment();\n'})}),"\n",(0,s.jsx)(r.p,{children:(0,s.jsx)(r.strong,{children:"CARACTER\xcdSTICAS PRINCIPALES DEL SERVIDOR:"})}),"\n",(0,s.jsxs)(r.ol,{children:["\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.strong,{children:"Servicio de Archivos Est\xe1ticos"}),": Sirve HTML, CSS, JS, im\xe1genes, etc."]}),"\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.strong,{children:"Detecci\xf3n Autom\xe1tica de MIME Types"}),": Configura el Content-Type correcto"]}),"\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.strong,{children:"Manejo de Errores"}),": 404 para archivos no encontrados, 500 para errores del servidor"]}),"\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.strong,{children:"Seguridad B\xe1sica"}),": Solo acepta m\xe9todos GET"]}),"\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.strong,{children:"Ruta por Defecto"}),":\xa0",(0,s.jsx)(r.code,{children:"/"}),"\xa0sirve\xa0",(0,s.jsx)(r.code,{children:"index.html"}),"\xa0autom\xe1ticamente"]}),"\n"]}),"\n",(0,s.jsx)(r.p,{children:(0,s.jsx)(r.strong,{children:"FLUJO DE UNA SOLICITUD:"})}),"\n",(0,s.jsxs)(r.ol,{children:["\n",(0,s.jsxs)(r.li,{children:["Cliente solicita\xa0",(0,s.jsx)(r.code,{children:"http://localhost:3000/styles/main.css"})]}),"\n",(0,s.jsxs)(r.li,{children:["Servidor busca\xa0",(0,s.jsx)(r.code,{children:"public/styles/main.css"})]}),"\n",(0,s.jsxs)(r.li,{children:["Detecta extensi\xf3n\xa0",(0,s.jsx)(r.code,{children:".css"}),"\xa0\u2192 Content-Type:\xa0",(0,s.jsx)(r.code,{children:"text/css"})]}),"\n",(0,s.jsx)(r.li,{children:"Lee el archivo y lo env\xeda al cliente"}),"\n",(0,s.jsx)(r.li,{children:"Si no existe, retorna error 404"}),"\n"]}),"\n",(0,s.jsx)(r.p,{children:"Este servidor es ideal para desarrollo frontend y aplicaciones est\xe1ticas, proporcionando una base s\xf3lida que puede extenderse con m\xe1s funcionalidades seg\xfan sea necesario."}),"\n",(0,s.jsx)(r.h2,{id:"mejores-pr\xe1cticas-y-configuraciones",children:"Mejores Pr\xe1cticas y Configuraciones"}),"\n",(0,s.jsx)(r.h3,{id:"manejo-de-errores-del-servidor",children:"Manejo de Errores del Servidor"}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-jsx",children:'import http from "http";\r\n\r\n// Crear servidor HTTP b\xe1sico\r\nconst server = http.createServer((req, res) => {\r\n  // L\xf3gica principal del servidor para manejar solicitudes HTTP\r\n  // Esta funci\xf3n se ejecuta cada vez que llega una nueva solicitud\r\n  res.writeHead(200, { "Content-Type": "text/plain" });\r\n  res.end("OK - Solicitud procesada correctamente");\r\n});\r\n\r\n// ============================================================================\r\n// MANEJO DE EVENTOS DEL SERVIDOR\r\n// ============================================================================\r\n\r\n// 1. EVENTO \'error\' - Maneja errores del servidor\r\nserver.on("error", (error) => {\r\n  console.error("Error del servidor:", error);\r\n\r\n  // Manejar espec\xedficamente el error de puerto ocupado\r\n  if (error.code === "EADDRINUSE") {\r\n    console.log("El puerto ya est\xe1 en uso. Intentando con otro puerto...");\r\n\r\n    // Estrategias para manejar puerto ocupado:\r\n    // a) Intentar con otro puerto autom\xe1ticamente\r\n    const newPort = parseInt(process.env.PORT || "3000") + 1;\r\n    console.log(`Intentando con puerto ${newPort}...`);\r\n    server.listen(newPort);\r\n\r\n    // b) En producci\xf3n, podr\xedas registrar el error y salir\r\n    // console.error(\'Puerto ocupado. Saliendo...\');\r\n    // process.exit(1);\r\n  }\r\n\r\n  // Manejar otros errores comunes\r\n  else if (error.code === "EACCES") {\r\n    console.error(\r\n      "Error de permisos: No tienes permisos para usar este puerto"\r\n    );\r\n  } else if (error.code === "EADDRNOTAVAIL") {\r\n    console.error("Error: La direcci\xf3n no est\xe1 disponible");\r\n  }\r\n});\r\n\r\n// 2. EVENTO \'connection\' - Se dispara cuando un cliente se conecta\r\nserver.on("connection", (socket) => {\r\n  // socket es un objeto net.Socket que representa la conexi\xf3n TCP\r\n  console.log(\r\n    "Nueva conexi\xf3n desde:",\r\n    socket.remoteAddress + ":" + socket.remotePort\r\n  );\r\n\r\n  // Podemos agregar m\xe1s informaci\xf3n sobre la conexi\xf3n\r\n  console.log("Conexi\xf3n local:", socket.localAddress + ":" + socket.localPort);\r\n  console.log("Tiempo de conexi\xf3n:", new Date().toISOString());\r\n\r\n  // Tambi\xe9n podemos manejar eventos en el socket individual\r\n  socket.on("close", () => {\r\n    console.log("Conexi\xf3n cerrada desde:", socket.remoteAddress);\r\n  });\r\n\r\n  socket.on("error", (error) => {\r\n    console.error(\r\n      "Error en conexi\xf3n con",\r\n      socket.remoteAddress,\r\n      ":",\r\n      error.message\r\n    );\r\n  });\r\n});\r\n\r\n// 3. EVENTO \'close\' - Se dispara cuando el servidor se cierra\r\nserver.on("close", () => {\r\n  console.log("Servidor cerrado - Ya no acepta nuevas conexiones");\r\n  console.log("Todas las conexiones existentes han sido finalizadas");\r\n});\r\n\r\n// 4. EVENTO \'listening\' - Se dispara cuando el servidor comienza a escuchar\r\nserver.on("listening", () => {\r\n  const address = server.address();\r\n  console.log("Servidor escuchando en:", address.address + ":" + address.port);\r\n});\r\n\r\n// ============================================================================\r\n// MANEJO DE SE\xd1ALES DEL SISTEMA OPERATIVO (Graceful Shutdown)\r\n// ============================================================================\r\n\r\n// 1. SIGTERM - Se\xf1al de terminaci\xf3n (usada por Docker, Kubernetes, etc.)\r\nprocess.on("SIGTERM", () => {\r\n  console.log("\\nRecibida se\xf1al SIGTERM. Cerrando servidor gracefulmente...");\r\n  console.log("No se aceptar\xe1n nuevas conexiones...");\r\n\r\n  // server.close() detiene el servidor de aceptar nuevas conexiones\r\n  // pero permite terminar las conexiones existentes\r\n  server.close(() => {\r\n    console.log("\u2705 Servidor cerrado exitosamente");\r\n    console.log("\u2705 Todas las conexiones existentes fueron completadas");\r\n    process.exit(0); // Salir con c\xf3digo 0 (\xe9xito)\r\n  });\r\n\r\n  // Timeout para forzar cierre si toma demasiado tiempo\r\n  setTimeout(() => {\r\n    console.log("\u26a0\ufe0f  Timeout de cierre graceful. Forzando salida...");\r\n    process.exit(1);\r\n  }, 10000); // 10 segundos\r\n});\r\n\r\n// 2. SIGINT - Se\xf1al de interrupci\xf3n (Ctrl+C en terminal)\r\nprocess.on("SIGINT", () => {\r\n  console.log("\\nRecibida se\xf1al SIGINT (Ctrl+C). Cerrando servidor...");\r\n\r\n  server.close(() => {\r\n    console.log("\u2705 Servidor cerrado por interrupci\xf3n del usuario");\r\n    process.exit(0);\r\n  });\r\n});\r\n\r\n// 3. SIGUSR2 - Se\xf1al usada por nodemon para reinicio\r\nprocess.on("SIGUSR2", () => {\r\n  console.log("Recibida se\xf1al SIGUSR2 (nodemon). Cerrando para reinicio...");\r\n\r\n  server.close(() => {\r\n    console.log("Servidor cerrado para reinicio");\r\n    process.exit(0);\r\n  });\r\n});\r\n\r\n// ============================================================================\r\n// MANEJO DE EXCEPCIONES NO CAPTURADAS\r\n// ============================================================================\r\n\r\n// Manejar excepciones no capturadas en Promises\r\nprocess.on("unhandledRejection", (reason, promise) => {\r\n  console.error("\u26a0\ufe0f  Promise rechazada no manejada:", reason);\r\n  console.error("En la promise:", promise);\r\n  // En producci\xf3n, podr\xedas registrar esto y continuar\r\n  // process.exit(1); // O salir en entornos cr\xedticos\r\n});\r\n\r\n// Manejar excepciones s\xedncronas no capturadas\r\nprocess.on("uncaughtException", (error) => {\r\n  console.error("\ud83d\udca5 Excepci\xf3n no capturada:", error);\r\n  // Cerrar el servidor gracefulmente antes de salir\r\n  server.close(() => {\r\n    console.log("Servidor cerrado debido a error no manejado");\r\n    process.exit(1); // Salir con c\xf3digo de error\r\n  });\r\n});\r\n\r\n// ============================================================================\r\n// INICIAR EL SERVIDOR CON MANEJO DE ERRORES\r\n// ============================================================================\r\n\r\nconst PORT = process.env.PORT || 3000;\r\n\r\n// Intentar iniciar el servidor con manejo de errores\r\ntry {\r\n  server.listen(PORT, () => {\r\n    // Esta callback se ejecuta cuando el servidor inicia correctamente\r\n    console.log(`\ud83d\ude80 Servidor ejecut\xe1ndose en http://localhost:${PORT}`);\r\n    console.log(`\ud83d\udcca Entorno: ${process.env.NODE_ENV || "development"}`);\r\n    console.log(`\ud83c\udd94 PID: ${process.pid}`);\r\n  });\r\n} catch (error) {\r\n  console.error("Error al iniciar el servidor:", error);\r\n  process.exit(1);\r\n}\r\n\r\n// ============================================================================\r\n// EJEMPLOS ADICIONALES DE USO PR\xc1CTICO\r\n// ============================================================================\r\n\r\n// EJEMPLO 1: MONITOREO DE CONEXIONES ACTIVAS\r\nlet activeConnections = 0;\r\n\r\nserver.on("connection", (socket) => {\r\n  activeConnections++;\r\n  console.log(`Conexi\xf3n establecida. Activas: ${activeConnections}`);\r\n\r\n  socket.on("close", () => {\r\n    activeConnections--;\r\n    console.log(`Conexi\xf3n cerrada. Activas: ${activeConnections}`);\r\n  });\r\n});\r\n\r\n// EJEMPLO 2: HEALTH CHECK ENDPOINT\r\nconst healthServer = http.createServer((req, res) => {\r\n  if (req.url === "/health") {\r\n    res.writeHead(200, { "Content-Type": "application/json" });\r\n    res.end(\r\n      JSON.stringify({\r\n        status: "healthy",\r\n        timestamp: new Date().toISOString(),\r\n        uptime: process.uptime(),\r\n        connections: activeConnections,\r\n        memory: process.memoryUsage(),\r\n      })\r\n    );\r\n  } else {\r\n    res.writeHead(404);\r\n    res.end("Not Found");\r\n  }\r\n});\r\n\r\n// EJEMPLO 3: GRACEFUL SHUTDOWN MEJORADO\r\nfunction gracefulShutdown(signal) {\r\n  console.log(`\\n\ud83d\udcde Recibida se\xf1al ${signal}. Iniciando shutdown graceful...`);\r\n\r\n  // 1. Detener aceptar nuevas conexiones\r\n  server.close(() => {\r\n    console.log("\u2705 Servidor HTTP cerrado");\r\n  });\r\n\r\n  // 2. Cerrar conexiones de base de datos, etc.\r\n  // await database.close();\r\n\r\n  // 3. Timeout forzado\r\n  const forceShutdown = setTimeout(() => {\r\n    console.log("\u26a0\ufe0f  Shutdown forzado despu\xe9s de timeout");\r\n    process.exit(1);\r\n  }, 10000);\r\n\r\n  // 4. Limpiar timeout si se cierra gracefulmente\r\n  server.close(() => {\r\n    clearTimeout(forceShutdown);\r\n    console.log("\u2705 Shutdown completado gracefulmente");\r\n    process.exit(0);\r\n  });\r\n}\r\n\r\n// Registrar m\xfaltiples se\xf1ales para shutdown\r\n["SIGTERM", "SIGINT", "SIGUSR2"].forEach((signal) => {\r\n  process.on(signal, () => gracefulShutdown(signal));\r\n});\r\n\r\n// EJEMPLO 4: MANEJO DE CONFIGURACI\xd3N DE PUERTO\r\nfunction startServer(port = 3000, maxRetries = 3) {\r\n  let retries = 0;\r\n\r\n  function attemptStart(currentPort) {\r\n    server\r\n      .listen(currentPort, () => {\r\n        console.log(`\u2705 Servidor iniciado en puerto ${currentPort}`);\r\n      })\r\n      .on("error", (error) => {\r\n        if (error.code === "EADDRINUSE" && retries < maxRetries) {\r\n          retries++;\r\n          console.log(\r\n            `\ud83d\udd04 Puerto ${currentPort} ocupado. Intentando ${currentPort + 1}...`\r\n          );\r\n          setTimeout(() => attemptStart(currentPort + 1), 1000);\r\n        } else {\r\n          console.error(\r\n            "\u274c No se pudo iniciar el servidor despu\xe9s de varios intentos"\r\n          );\r\n          process.exit(1);\r\n        }\r\n      });\r\n  }\r\n\r\n  attemptStart(port);\r\n}\r\n\r\n// Para usar la versi\xf3n con reintentos autom\xe1ticos:\r\n// startServer(3000, 5);\n'})}),"\n",(0,s.jsx)(r.p,{children:(0,s.jsx)(r.strong,{children:"RESUMEN DE EVENTOS PRINCIPALES:"})}),"\n",(0,s.jsxs)(r.ol,{children:["\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.strong,{children:(0,s.jsx)(r.code,{children:"error"})}),": Errores del servidor (puerto ocupado, permisos, etc.)"]}),"\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.strong,{children:(0,s.jsx)(r.code,{children:"connection"})}),": Nuevas conexiones de clientes"]}),"\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.strong,{children:(0,s.jsx)(r.code,{children:"close"})}),": Servidor cerrado"]}),"\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.strong,{children:(0,s.jsx)(r.code,{children:"listening"})}),": Servidor iniciado y escuchando"]}),"\n",(0,s.jsxs)(r.li,{children:[(0,s.jsxs)(r.strong,{children:[(0,s.jsx)(r.code,{children:"SIGTERM"}),"/",(0,s.jsx)(r.code,{children:"SIGINT"})]}),": Se\xf1ales de terminaci\xf3n del sistema operativo"]}),"\n"]}),"\n",(0,s.jsx)(r.p,{children:(0,s.jsx)(r.strong,{children:"BENEFICIOS DE ESTE ENFOQUE:"})}),"\n",(0,s.jsxs)(r.ul,{children:["\n",(0,s.jsxs)(r.li,{children:["\u2705\xa0",(0,s.jsx)(r.strong,{children:"Shutdown Graceful"}),": Cierra conexiones limpiamente"]}),"\n",(0,s.jsxs)(r.li,{children:["\u2705\xa0",(0,s.jsx)(r.strong,{children:"Manejo de Errores"}),": Recuperaci\xf3n autom\xe1tica de puertos ocupados"]}),"\n",(0,s.jsxs)(r.li,{children:["\u2705\xa0",(0,s.jsx)(r.strong,{children:"Monitoreo"}),": Seguimiento de conexiones activas"]}),"\n",(0,s.jsxs)(r.li,{children:["\u2705\xa0",(0,s.jsx)(r.strong,{children:"Robustez"}),": Manejo de excepciones no capturadas"]}),"\n",(0,s.jsxs)(r.li,{children:["\u2705\xa0",(0,s.jsx)(r.strong,{children:"Portabilidad"}),": Funciona en diferentes entornos (Docker, Kubernetes, etc.)"]}),"\n"]}),"\n",(0,s.jsx)(r.p,{children:"Este servidor est\xe1 preparado para entornos de producci\xf3n con manejo profesional de errores, se\xf1ales del sistema operativo y cierre graceful que es esencial para mantener la disponibilidad del servicio."}),"\n",(0,s.jsx)(r.h3,{id:"configuraci\xf3n-de-timeouts",children:"Configuraci\xf3n de Timeouts"}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-jsx",children:'import http from "http";\r\n\r\nconst server = http.createServer((req, res) => {\r\n  // Simular una operaci\xf3n que toma mucho tiempo (10 segundos)\r\n  // Esto podr\xeda ser: procesamiento de datos, consulta a base de datos, llamada a API externa, etc.\r\n  setTimeout(() => {\r\n    res.writeHead(200, { "Content-Type": "text/plain" });\r\n    res.end("Operaci\xf3n completada despu\xe9s de 10 segundos");\r\n  }, 10000); // 10 segundos de delay\r\n\r\n  // EJEMPLOS DE OPERACIONES QUE PODR\xcdAN TARDAR MUCHO TIEMPO:\r\n  // - Procesamiento de archivos grandes\r\n  // - Consultas complejas a bases de datos\r\n  // - Integraciones con APIs lentas\r\n  // - Generaci\xf3n de reportes complejos\r\n  // - Procesamiento de im\xe1genes/videos\r\n});\r\n\r\n// ============================================================================\r\n// CONFIGURACI\xd3N DE TIMEOUTS DEL SERVIDOR\r\n// ============================================================================\r\n\r\n// 1. server.timeout = 15000 (15 segundos)\r\n// Tiempo m\xe1ximo de inactividad en una conexi\xf3n\r\n// Si no hay actividad por 15 segundos, el servidor cierra la conexi\xf3n autom\xe1ticamente\r\nserver.timeout = 15000; // 15 segundos en milisegundos\r\n\r\n// 2. server.keepAliveTimeout = 5000 (5 segundos)\r\n// Tiempo que el servidor mantiene la conexi\xf3n keep-alive abierta despu\xe9s de la \xfaltima respuesta\r\n// Conexiones persistentes para m\xfaltiples requests en la misma conexi\xf3n TCP\r\nserver.keepAliveTimeout = 5000; // 5 segundos\r\n\r\n// 3. server.headersTimeout = 10000 (10 segundos)\r\n// Tiempo m\xe1ximo para que el cliente env\xede los headers completos de la solicitud\r\n// Si el cliente no env\xeda todos los headers en 10 segundos, se cierra la conexi\xf3n\r\nserver.headersTimeout = 10000; // 10 segundos\r\n\r\n// ============================================================================\r\n// EXPLICACI\xd3N DETALLADA DE CADA TIMEOUT\r\n// ============================================================================\r\n\r\n// SERVER.TIMEOUT (15 segundos)\r\n// - Se refiere al tiempo m\xe1ximo de inactividad en el socket\r\n// - Comienza a contar despu\xe9s de que se establece la conexi\xf3n\r\n// - Se reinicia cada vez que hay actividad (datos enviados/recibidos)\r\n// - Si se supera el timeout, el servidor emite un evento \'timeout\' y cierra la conexi\xf3n\r\n\r\nserver.on("timeout", (socket) => {\r\n  console.log("\u23f0 Timeout de conexi\xf3n alcanzado");\r\n  console.log("Cliente:", socket.remoteAddress);\r\n  console.log("Tiempo inactivo super\xf3 los 15 segundos");\r\n});\r\n\r\n// SERVER.KEEPALIVETIMEOUT (5 segundos)\r\n// - Espec\xedfico para conexiones keep-alive (HTTP persistent connections)\r\n// - Tiempo que el servidor mantiene la conexi\xf3n abierta para pr\xf3ximas solicitudes\r\n// - Reduce overhead de establecer nuevas conexiones TCP\r\n// - Mejora performance para clientes que hacen m\xfaltiples requests\r\n\r\n// SERVER.HEADERSTIMEOUT (10 segundos)\r\n// - Tiempo m\xe1ximo para recibir los headers HTTP completos\r\n// - Previene ataques de Slowloris (clientes que env\xedan headers muy lentamente)\r\n// - Comienza cuando se establece la conexi\xf3n\r\n// - Se detiene cuando se recibe el final de los headers (\\r\\n\\r\\n)\r\n\r\n// ============================================================================\r\n// EJEMPLO PR\xc1CTICO: QU\xc9 SUCEDE CON ESTA CONFIGURACI\xd3N\r\n// ============================================================================\r\n\r\n/*\r\nESCENARIO: Cliente hace una solicitud que tarda 10 segundos en procesarse\r\n\r\n1. Cliente se conecta \u2192 Env\xeda headers inmediatamente\r\n   - headersTimeout: 10 segundos \u2705 (headers llegan r\xe1pido)\r\n   \r\n2. Servidor procesa por 10 segundos\r\n   - Durante este tiempo, el socket est\xe1 activo (procesando)\r\n   - server.timeout: 15 segundos \u2705 (no se supera porque hay actividad)\r\n\r\n3. Servidor responde a los 10 segundos\r\n   - Cliente recibe respuesta\r\n\r\n4. Si el cliente hace otra solicitud en 3 segundos:\r\n   - keepAliveTimeout: 5 segundos \u2705 (la conexi\xf3n sigue abierta)\r\n\r\n5. Si el cliente espera 6 segundos para la siguiente solicitud:\r\n   - keepAliveTimeout: 5 segundos \u274c (la conexi\xf3n se cierra)\r\n   - El cliente debe establecer nueva conexi\xf3n\r\n*/\r\n\r\n// ============================================================================\r\n// VERSI\xd3N MEJORADA CON MANEJO DE TIMEOUTS PERSONALIZADO\r\n// ============================================================================\r\n\r\nconst advancedServer = http.createServer((req, res) => {\r\n  console.log(`Solicitud recibida: ${req.method} ${req.url}`);\r\n\r\n  // Configurar timeout espec\xedfico para esta solicitud\r\n  req.socket.setTimeout(30000); // 30 segundos para esta conexi\xf3n espec\xedfica\r\n\r\n  // Manejar timeout espec\xedfico de esta solicitud\r\n  req.socket.on("timeout", () => {\r\n    console.log("Timeout de socket para solicitud espec\xedfica");\r\n    if (!res.headersSent) {\r\n      res.writeHead(408, { "Content-Type": "application/json" });\r\n      res.end(\r\n        JSON.stringify({\r\n          error: "Request Timeout",\r\n          message: "La operaci\xf3n tom\xf3 demasiado tiempo",\r\n        })\r\n      );\r\n    }\r\n  });\r\n\r\n  // Simular diferentes tipos de operaciones con diferentes tiempos\r\n  const url = req.url;\r\n  let processingTime = 10000; // 10 segundos por defecto\r\n\r\n  if (url === "/fast") {\r\n    processingTime = 1000; // 1 segundo\r\n  } else if (url === "/slow") {\r\n    processingTime = 20000; // 20 segundos (superar\xe1 el timeout)\r\n  } else if (url === "/very-slow") {\r\n    processingTime = 40000; // 40 segundos (superar\xe1 timeout personalizado)\r\n  }\r\n\r\n  console.log(`Procesando por ${processingTime}ms...`);\r\n\r\n  setTimeout(() => {\r\n    if (!res.headersSent) {\r\n      res.writeHead(200, { "Content-Type": "application/json" });\r\n      res.end(\r\n        JSON.stringify({\r\n          message: "Operaci\xf3n completada",\r\n          processingTime: processingTime,\r\n          timestamp: new Date().toISOString(),\r\n        })\r\n      );\r\n    }\r\n  }, processingTime);\r\n});\r\n\r\n// Configurar timeouts para el servidor mejorado\r\nadvancedServer.timeout = 15000; // 15 segundos\r\nadvancedServer.keepAliveTimeout = 5000; // 5 segundos\r\nadvancedServer.headersTimeout = 10000; // 10 segundos\r\n\r\n// ============================================================================\r\n// MONITOREO Y LOGGING DE TIMEOUTS\r\n// ============================================================================\r\n\r\nadvancedServer.on("timeout", (socket) => {\r\n  const clientInfo = `${socket.remoteAddress}:${socket.remotePort}`;\r\n  console.warn(`\ud83d\udd52 TIMEOUT GLOBAL: Cliente ${clientInfo}`);\r\n  console.warn(`   Tiempo inactivo super\xf3 ${advancedServer.timeout}ms`);\r\n});\r\n\r\nadvancedServer.on("connection", (socket) => {\r\n  const clientInfo = `${socket.remoteAddress}:${socket.remotePort}`;\r\n  console.log(`\ud83d\udd17 NUEVA CONEXI\xd3N: ${clientInfo}`);\r\n\r\n  socket.on("timeout", () => {\r\n    console.warn(`\u23f0 TIMEOUT DE SOCKET: ${clientInfo}`);\r\n  });\r\n\r\n  socket.on("close", (hadError) => {\r\n    console.log(\r\n      `\u274c CONEXI\xd3N CERRADA: ${clientInfo} ${hadError ? "(con error)" : ""}`\r\n    );\r\n  });\r\n});\r\n\r\n// ============================================================================\r\n// RECOMENDACIONES DE CONFIGURACI\xd3N POR ENTORNO\r\n// ============================================================================\r\n\r\nfunction createServerWithOptimalTimeouts() {\r\n  const server = http.createServer((req, res) => {\r\n    // L\xf3gica de la aplicaci\xf3n...\r\n    setTimeout(() => {\r\n      res.end("OK");\r\n    }, 10000);\r\n  });\r\n\r\n  const env = process.env.NODE_ENV || "development";\r\n\r\n  if (env === "development") {\r\n    // Desarrollo: timeouts m\xe1s largos para debugging\r\n    server.timeout = 30000; // 30 segundos\r\n    server.keepAliveTimeout = 10000; // 10 segundos\r\n    server.headersTimeout = 15000; // 15 segundos\r\n    console.log("\u2699\ufe0f  Configuraci\xf3n de timeouts: DESARROLLO");\r\n  } else if (env === "production") {\r\n    // Producci\xf3n: timeouts m\xe1s agresivos para seguridad y performance\r\n    server.timeout = 10000; // 10 segundos\r\n    server.keepAliveTimeout = 5000; // 5 segundos\r\n    server.headersTimeout = 5000; // 5 segundos\r\n    console.log("\u2699\ufe0f  Configuraci\xf3n de timeouts: PRODUCCI\xd3N");\r\n  } else {\r\n    // Por defecto\r\n    server.timeout = 15000;\r\n    server.keepAliveTimeout = 5000;\r\n    server.headersTimeout = 10000;\r\n  }\r\n\r\n  return server;\r\n}\r\n\r\n// ============================================================================\r\n// MANEJO DE ERRORES RELACIONADOS CON TIMEOUTS\r\n// ============================================================================\r\n\r\nadvancedServer.on("clientError", (err, socket) => {\r\n  if (err.code === "ECONNRESET" || err.code === "EPIPE") {\r\n    // Errores comunes cuando el cliente cierra la conexi\xf3n durante timeout\r\n    console.log("Cliente cerr\xf3 la conexi\xf3n anticipadamente");\r\n  } else {\r\n    console.error("Error de cliente:", err);\r\n  }\r\n\r\n  if (!socket.destroyed) {\r\n    socket.end("HTTP/1.1 400 Bad Request\\r\\n\\r\\n");\r\n  }\r\n});\r\n\r\n// ============================================================================\r\n// INICIAR SERVIDOR DE EJEMPLO\r\n// ============================================================================\r\n\r\nconst PORT = 3001;\r\nadvancedServer.listen(PORT, () => {\r\n  console.log(`\ud83d\ude80 Servidor con timeouts avanzados en http://localhost:${PORT}`);\r\n  console.log(`\u23f0 Timeout global: ${advancedServer.timeout}ms`);\r\n  console.log(`\ud83d\udd17 Keep-alive timeout: ${advancedServer.keepAliveTimeout}ms`);\r\n  console.log(`\ud83d\udccb Headers timeout: ${advancedServer.headersTimeout}ms`);\r\n  console.log("\\nEndpoints de prueba:");\r\n  console.log("  GET /fast     - 1 segundo (\xe9xito)");\r\n  console.log("  GET /         - 10 segundos (\xe9xito)");\r\n  console.log("  GET /slow     - 20 segundos (timeout)");\r\n  console.log("  GET /very-slow - 40 segundos (timeout personalizado)");\r\n});\r\n\r\n// Para usar el servidor original (comentar el anterior y descomentar este):\r\n// server.listen(3000, () => {\r\n//     console.log(\'Servidor b\xe1sico con timeouts en http://localhost:3000\');\r\n// });\n'})}),"\n",(0,s.jsx)(r.p,{children:(0,s.jsx)(r.strong,{children:"RESUMEN DE LOS TIMEOUTS CONFIGURADOS:"})}),"\n",(0,s.jsxs)(r.ol,{children:["\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.strong,{children:(0,s.jsx)(r.code,{children:"server.timeout = 15000"})}),"\xa0(15 segundos)","\n",(0,s.jsxs)(r.ul,{children:["\n",(0,s.jsx)(r.li,{children:"Tiempo m\xe1ximo de inactividad en la conexi\xf3n"}),"\n",(0,s.jsx)(r.li,{children:"Se reinicia con cada actividad del socket"}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.strong,{children:(0,s.jsx)(r.code,{children:"server.keepAliveTimeout = 5000"})}),"\xa0(5 segundos)","\n",(0,s.jsxs)(r.ul,{children:["\n",(0,s.jsx)(r.li,{children:"Tiempo que se mantiene la conexi\xf3n keep-alive abierta"}),"\n",(0,s.jsx)(r.li,{children:"Para m\xfaltiples requests en la misma conexi\xf3n TCP"}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.strong,{children:(0,s.jsx)(r.code,{children:"server.headersTimeout = 10000"})}),"\xa0(10 segundos)","\n",(0,s.jsxs)(r.ul,{children:["\n",(0,s.jsx)(r.li,{children:"Tiempo m\xe1ximo para recibir los headers completos"}),"\n",(0,s.jsx)(r.li,{children:"Protecci\xf3n contra ataques de Slowloris"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(r.p,{children:(0,s.jsx)(r.strong,{children:"BENEFICIOS DE CONFIGURAR TIMEOUTS:"})}),"\n",(0,s.jsxs)(r.ul,{children:["\n",(0,s.jsxs)(r.li,{children:["\u2705\xa0",(0,s.jsx)(r.strong,{children:"Prevenci\xf3n de recursos colgados"}),": Cierra conexiones inactivas"]}),"\n",(0,s.jsxs)(r.li,{children:["\u2705\xa0",(0,s.jsx)(r.strong,{children:"Protecci\xf3n contra ataques"}),": Mitiga Slowloris y DoS"]}),"\n",(0,s.jsxs)(r.li,{children:["\u2705\xa0",(0,s.jsx)(r.strong,{children:"Mejor uso de recursos"}),": Libera sockets r\xe1pidamente"]}),"\n",(0,s.jsxs)(r.li,{children:["\u2705\xa0",(0,s.jsx)(r.strong,{children:"Experiencia de usuario"}),": Respuestas predecibles"]}),"\n",(0,s.jsxs)(r.li,{children:["\u2705\xa0",(0,s.jsx)(r.strong,{children:"Estabilidad del servidor"}),": Evita acumulaci\xf3n de conexiones"]}),"\n"]}),"\n",(0,s.jsx)(r.p,{children:"Esta configuraci\xf3n es esencial para servidores en producci\xf3n para mantener la estabilidad y seguridad del servicio."}),"\n",(0,s.jsx)(r.h2,{id:"conclusi\xf3n",children:"Conclusi\xf3n"}),"\n",(0,s.jsx)(r.p,{children:"El m\xf3dulo HTTP de Node.js es extremadamente poderoso y flexible. Con ES Modules, el uso es similar pero con sintaxis de importaci\xf3n moderna. Las claves para dominar este m\xf3dulo son:"}),"\n",(0,s.jsxs)(r.ul,{children:["\n",(0,s.jsxs)(r.li,{children:["Entender los objetos ",(0,s.jsx)(r.code,{children:"req"})," (request) y ",(0,s.jsx)(r.code,{children:"res"})," (response)"]}),"\n",(0,s.jsx)(r.li,{children:"Manejar correctamente los streams de datos"}),"\n",(0,s.jsx)(r.li,{children:"Implementar un buen sistema de enrutamiento"}),"\n",(0,s.jsx)(r.li,{children:"Gestionar adecuadamente los errores y timeouts"}),"\n",(0,s.jsx)(r.li,{children:"Configurar correctamente los headers y c\xf3digos de estado"}),"\n",(0,s.jsx)(r.li,{children:"Utilizar el cliente HTTP para consumir APIs externas"}),"\n"]}),"\n",(0,s.jsx)(r.p,{children:"Este conocimiento fundamental te permitir\xe1 entender c\xf3mo funcionan los frameworks web como Express.js y te dar\xe1 la base para construir aplicaciones web robustas y eficientes."})]})}function p(e={}){const{wrapper:r}={...(0,t.R)(),...e.components};return r?(0,s.jsx)(r,{...e,children:(0,s.jsx)(l,{...e})}):l(e)}},8453:(e,r,n)=>{n.d(r,{R:()=>a,x:()=>i});var o=n(6540);const s={},t=o.createContext(s);function a(e){const r=o.useContext(t);return o.useMemo(function(){return"function"==typeof e?e(r):{...r,...e}},[r,e])}function i(e){let r;return r=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:a(e.components),o.createElement(t.Provider,{value:r},e.children)}}}]);