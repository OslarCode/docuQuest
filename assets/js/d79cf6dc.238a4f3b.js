"use strict";(globalThis.webpackChunkDocuQuest_oslar_code=globalThis.webpackChunkDocuQuest_oslar_code||[]).push([[2151],{1564:(r,n,e)=>{e.r(n),e.d(n,{assets:()=>c,contentTitle:()=>t,default:()=>u,frontMatter:()=>i,metadata:()=>o,toc:()=>l});const o=JSON.parse('{"id":"backend/Node.js/manejoDeArchivos","title":"Manejo del sistema de archivos con Node.js ES Modules","description":"Node.js proporciona capacidades completas para interactuar con el sistema de archivos a trav\xe9s del m\xf3dulo fs (file system). Este m\xf3dulo permite realizar operaciones como lectura, escritura, modificaci\xf3n y eliminaci\xf3n de archivos y directorios.","source":"@site/docs/backend/Node.js/manejoDeArchivos.md","sourceDirName":"backend/Node.js","slug":"/backend/Node.js/manejoDeArchivos","permalink":"/docuQuest/docs/backend/Node.js/manejoDeArchivos","draft":false,"unlisted":false,"editUrl":"https://github.com/OslarCode/OslarCode/docs/backend/Node.js/manejoDeArchivos.md","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"HTTP manejo de peticiones y respuestas ES Modules","permalink":"/docuQuest/docs/backend/Node.js/manejoDeHTTP"},"next":{"title":"Manejo de procesos del sistema en Node.js ES Modules","permalink":"/docuQuest/docs/backend/Node.js/manejoDeProcesos"}}');var a=e(4848),s=e(8453);const i={},t="Manejo del sistema de archivos con Node.js ES Modules",c={},l=[{value:"Configuraci\xf3n Inicial para ES Modules",id:"configuraci\xf3n-inicial-para-es-modules",level:2},{value:"Importaci\xf3n del M\xf3dulo fs",id:"importaci\xf3n-del-m\xf3dulo-fs",level:2},{value:"Operaciones B\xe1sicas con Archivos",id:"operaciones-b\xe1sicas-con-archivos",level:2},{value:"Lectura de Archivos de Texto",id:"lectura-de-archivos-de-texto",level:3},{value:"Lectura de Archivos Binarios",id:"lectura-de-archivos-binarios",level:3},{value:"Escritura de Archivos",id:"escritura-de-archivos",level:3},{value:"A\xf1adir Contenido a un Archivo Existente",id:"a\xf1adir-contenido-a-un-archivo-existente",level:3},{value:"Verificaci\xf3n y Informaci\xf3n de Archivos",id:"verificaci\xf3n-y-informaci\xf3n-de-archivos",level:2},{value:"Verificar Existencia de Archivos",id:"verificar-existencia-de-archivos",level:3},{value:"Obtener Informaci\xf3n Detallada de Archivos",id:"obtener-informaci\xf3n-detallada-de-archivos",level:3},{value:"Operaciones con Directorios",id:"operaciones-con-directorios",level:2},{value:"Creaci\xf3n de Directorios",id:"creaci\xf3n-de-directorios",level:3},{value:"Listar Contenido de Directorios",id:"listar-contenido-de-directorios",level:3},{value:"Eliminaci\xf3n de Archivos y Directorios",id:"eliminaci\xf3n-de-archivos-y-directorios",level:3},{value:"Operaciones de Copia y Movimiento",id:"operaciones-de-copia-y-movimiento",level:2},{value:"Copiar Archivos",id:"copiar-archivos",level:3},{value:"Renombrar y Mover Archivos",id:"renombrar-y-mover-archivos",level:3},{value:"Manejo de Archivos Grandes con Streams",id:"manejo-de-archivos-grandes-con-streams",level:2},{value:"Lectura con Streams",id:"lectura-con-streams",level:3},{value:"Escritura con Streams",id:"escritura-con-streams",level:3},{value:"Conclusi\xf3n",id:"conclusi\xf3n",level:2}];function d(r){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...r.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.header,{children:(0,a.jsx)(n.h1,{id:"manejo-del-sistema-de-archivos-con-nodejs-es-modules",children:"Manejo del sistema de archivos con Node.js ES Modules"})}),"\n",(0,a.jsxs)(n.p,{children:["Node.js proporciona capacidades completas para interactuar con el sistema de archivos a trav\xe9s del m\xf3dulo ",(0,a.jsx)(n.code,{children:"fs"})," (file system). Este m\xf3dulo permite realizar operaciones como lectura, escritura, modificaci\xf3n y eliminaci\xf3n de archivos y directorios."]}),"\n",(0,a.jsx)(n.h2,{id:"configuraci\xf3n-inicial-para-es-modules",children:"Configuraci\xf3n Inicial para ES Modules"}),"\n",(0,a.jsx)(n.p,{children:"Para utilizar ES Modules en Node.js, es necesario configurar el proyecto adecuadamente:"}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"package.json"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-json",children:'{\r\n  "type": "module",\r\n  "name": "proyecto-fs",\r\n  "version": "1.0.0"\r\n}\n'})}),"\n",(0,a.jsx)(n.h2,{id:"importaci\xf3n-del-m\xf3dulo-fs",children:"Importaci\xf3n del M\xf3dulo fs"}),"\n",(0,a.jsx)(n.p,{children:"El m\xf3dulo fs ofrece dos APIs: la basada en callbacks y la basada en promesas. Para ES Modules, utilizaremos la versi\xf3n de promesas:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-jsx",children:'// Importar la versi\xf3n basada en promesas de fs\r\nimport fs from "fs/promises";\n'})}),"\n",(0,a.jsx)(n.h2,{id:"operaciones-b\xe1sicas-con-archivos",children:"Operaciones B\xe1sicas con Archivos"}),"\n",(0,a.jsx)(n.h3,{id:"lectura-de-archivos-de-texto",children:"Lectura de Archivos de Texto"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-jsx",children:"// Importar el m\xf3dulo de sistema de archivos con soporte para Promises\r\n// fs/promises proporciona versiones as\xedncronas basadas en Promises de las funciones de fs\r\n// Esto permite usar async/await en lugar de callbacks\r\nimport fs from 'fs/promises';\r\n\r\n// Funci\xf3n as\xedncrona para leer un archivo de texto\r\n// Se declara como async para poder usar await dentro de ella\r\nasync function leerArchivoTexto() {\r\ntry {\r\n// Leer un archivo de texto con codificaci\xf3n UTF-8\r\n// fs.readFile() retorna una Promise que se resuelve con el contenido del archivo\r\n// Par\xe1metros:\r\n// 1. './documento.txt' - Ruta del archivo a leer (relativa al directorio actual)\r\n// 2. 'utf8' - Codificaci\xf3n del archivo (opcional, pero recomendado para texto)\r\nconst contenido = await fs.readFile('./documento.txt', 'utf8');\r\n\r\n// Mostrar el contenido del archivo en la consola\r\nconsole.log('Contenido del archivo:');\r\nconsole.log(contenido);\r\n\r\n} catch (error) {\r\n// Manejo de errores: captura cualquier error que ocurra durante la lectura\r\nconsole.error('Error al leer el archivo:', error.message);\r\n}\r\n}\r\n\r\n// Ejecutar la funci\xf3n\r\nleerArchivoTexto();\r\n\r\n// ============================================================================\r\n// EJEMPLOS ADICIONALES Y EXPLICACIONES DETALLADAS\r\n// ============================================================================\r\n\r\n// EJEMPLO 1: LECTURA DE ARCHIVO SIN CODIFICACI\xd3N (Buffer)\r\nasync function leerArchivoComoBuffer() {\r\ntry {\r\n// Si no se especifica codificaci\xf3n, readFile retorna un Buffer\r\n// Buffer es un objeto que representa datos binarios en crudo\r\nconst buffer = await fs.readFile('./documento.txt');\r\nconsole.log('Contenido como Buffer:', buffer);\r\nconsole.log('Buffer convertido a string:', buffer.toString('utf8'));\r\n\r\n} catch (error) {\r\nconsole.error('Error:', error.message);\r\n}\r\n}\r\n\r\n// EJEMPLO 2: LECTURA CON RUTA ABSOLUTA\r\nasync function leerConRutaAbsoluta() {\r\ntry {\r\n// Usando path para construir rutas absolutas (m\xe1s seguras)\r\nimport path from 'path';\r\nimport { fileURLToPath } from 'url';\r\n\r\nconst __filename = fileURLToPath(import.meta.url);\r\nconst __dirname = path.dirname(__filename);\r\n\r\nconst rutaAbsoluta = path.join(__dirname, 'documento.txt');\r\nconst contenido = await fs.readFile(rutaAbsoluta, 'utf8');\r\nconsole.log('Archivo le\xeddo desde ruta absoluta:', contenido);\r\n\r\n} catch (error) {\r\nconsole.error('Error:', error.message);\r\n}\r\n}\r\n\r\n// EJEMPLO 3: LECTURA CON DIFERENTES CODIFICACIONES\r\nasync function leerConDiferentesCodificaciones() {\r\ntry {\r\n// UTF-8 (recomendado para texto)\r\nconst utf8 = await fs.readFile('./archivo.txt', 'utf8');\r\n\r\n// ASCII (caracteres b\xe1sicos en ingl\xe9s)\r\nconst ascii = await fs.readFile('./archivo.txt', 'ascii');\r\n\r\n// Base64 (\xfatil para im\xe1genes o datos binarios)\r\nconst base64 = await fs.readFile('./archivo.txt', 'base64');\r\n\r\n// Hex (representaci\xf3n hexadecimal)\r\nconst hex = await fs.readFile('./archivo.txt', 'hex');\r\n\r\nconsole.log('UTF-8:', utf8);\r\nconsole.log('ASCII:', ascii);\r\nconsole.log('Base64:', base64);\r\nconsole.log('Hex:', hex);\r\n\r\n} catch (error) {\r\nconsole.error('Error:', error.message);\r\n}\r\n}\r\n\r\n// EJEMPLO 4: LECTURA CON OPCIONES ADICIONALES\r\nasync function leerConOpciones() {\r\ntry {\r\n// Usando objeto de opciones en lugar de par\xe1metros simples\r\nconst contenido = await fs.readFile('./documento.txt', {\r\nencoding: 'utf8',\r\nflag: 'r' // 'r' = lectura (read)\r\n});\r\nconsole.log('Contenido con opciones:', contenido);\r\n\r\n} catch (error) {\r\nconsole.error('Error:', error.message);\r\n}\r\n}\r\n\r\n// EJEMPLO 5: MANEJO ESPEC\xcdFICO DE DIFERENTES ERRORES\r\nasync function leerConManejoEspecificoDeErrores() {\r\ntry {\r\nconst contenido = await fs.readFile('./documento.txt', 'utf8');\r\nconsole.log('Contenido:', contenido);\r\n\r\n} catch (error) {\r\n// Manejar diferentes tipos de errores espec\xedficamente\r\nif (error.code === 'ENOENT') {\r\nconsole.error('\u274c El archivo no existe:', error.path);\r\n} else if (error.code === 'EACCES') {\r\nconsole.error('\u274c Permisos insuficientes para leer el archivo');\r\n} else if (error.code === 'EISDIR') {\r\nconsole.error('\u274c La ruta especificada es un directorio, no un archivo');\r\n} else {\r\nconsole.error('\u274c Error desconocido:', error.message);\r\n}\r\n}\r\n}\r\n\r\n// EJEMPLO 6: LECTURA DE ARCHIVOS JSON\r\nasync function leerArchivoJSON() {\r\ntry {\r\n// Leer y parsear autom\xe1ticamente un archivo JSON\r\nconst contenido = await fs.readFile('./config.json', 'utf8');\r\nconst datosJSON = JSON.parse(contenido);\r\nconsole.log('Datos JSON:', datosJSON);\r\n\r\n} catch (error) {\r\nif (error.code === 'ENOENT') {\r\nconsole.error('Archivo JSON no encontrado');\r\n} else if (error instanceof SyntaxError) {\r\nconsole.error('Error de sintaxis en el JSON:', error.message);\r\n} else {\r\nconsole.error('Error al leer JSON:', error.message);\r\n}\r\n}\r\n}\r\n\r\n// EJEMPLO 7: LECTURA EN LOTE DE M\xdaLTIPLES ARCHIVOS\r\nasync function leerMultiplesArchivos() {\r\ntry {\r\n// Leer varios archivos simult\xe1neamente usando Promise.all()\r\nconst [archivo1, archivo2, archivo3] = await Promise.all([\r\nfs.readFile('./archivo1.txt', 'utf8'),\r\nfs.readFile('./archivo2.txt', 'utf8'),\r\nfs.readFile('./archivo3.txt', 'utf8')\r\n]);\r\n\r\nconsole.log('Archivo 1:', archivo1);\r\nconsole.log('Archivo 2:', archivo2);\r\nconsole.log('Archivo 3:', archivo3);\r\n\r\n} catch (error) {\r\nconsole.error('Error al leer archivos m\xfaltiples:', error.message);\r\n}\r\n}\r\n\r\n// EJEMPLO 8: LECTURA CON VALIDACI\xd3N DE EXISTENCIA PREVIA\r\nasync function leerConValidacion() {\r\ntry {\r\n// Verificar si el archivo existe antes de intentar leerlo\r\ntry {\r\nawait fs.access('./documento.txt');\r\nconsole.log('\u2705 El archivo existe, procediendo a leer...');\r\n\r\nconst contenido = await fs.readFile('./documento.txt', 'utf8');\r\nconsole.log('Contenido:', contenido);\r\n\r\n} catch (accessError) {\r\nif (accessError.code === 'ENOENT') {\r\nconsole.log('\u26a0\ufe0f  El archivo no existe, creando uno por defecto...');\r\n\r\n// Crear archivo por defecto si no existe\r\nawait fs.writeFile('./documento.txt', 'Contenido por defecto\\n', 'utf8');\r\nconsole.log('\u2705 Archivo creado exitosamente');\r\n} else {\r\nthrow accessError; // Relanzar otros errores\r\n}\r\n}\r\n\r\n} catch (error) {\r\nconsole.error('Error en validaci\xf3n:', error.message);\r\n}\r\n}\r\n\r\n// EJEMPLO 9: LECTURA CON PROCESAMIENTO DE L\xcdNEAS\r\nasync function leerYProcesarLineas() {\r\ntry {\r\nconst contenido = await fs.readFile('./documento.txt', 'utf8');\r\n\r\n// Dividir el contenido en l\xedneas\r\nconst lineas = contenido.split('\\n');\r\n\r\nconsole.log(\ud83d\udcc4 El archivo tiene ${lineas.length} l\xedneas:);\r\n\r\n// Procesar cada l\xednea\r\nlineas.forEach((linea, indice) => {\r\nif (linea.trim() !== '') { // Ignorar l\xedneas vac\xedas\r\nconsole.log(L\xednea ${indice + 1}: ${linea.trim()});\r\n}\r\n});\r\n\r\n} catch (error) {\r\nconsole.error('Error al procesar l\xedneas:', error.message);\r\n}\r\n}\r\n\r\n// EJEMPLO 10: FUNCI\xd3N REUTILIZABLE PARA LECTURA DE ARCHIVOS\r\nclass LectorArchivos {\r\nconstructor(directorioBase = './') {\r\nthis.directorioBase = directorioBase;\r\n}\r\n\r\nasync leer(nombreArchivo, codificacion = 'utf8') {\r\ntry {\r\nconst rutaCompleta = ${this.directorioBase}/${nombreArchivo};\r\nconst contenido = await fs.readFile(rutaCompleta, codificacion);\r\nreturn {\r\nexito: true,\r\ncontenido: contenido,\r\nlongitud: contenido.length\r\n};\r\n} catch (error) {\r\nreturn {\r\nexito: false,\r\nerror: error.message,\r\ncodigoError: error.code\r\n};\r\n}\r\n}\r\n\r\nasync leerJSON(nombreArchivo) {\r\nconst resultado = await this.leer(nombreArchivo, 'utf8');\r\n\r\nif (resultado.exito) {\r\ntry {\r\nconst datos = JSON.parse(resultado.contenido);\r\nreturn { ...resultado, datos: datos };\r\n} catch (parseError) {\r\nreturn {\r\nexito: false,\r\nerror: Error parseando JSON: ${parseError.message}\r\n};\r\n}\r\n}\r\n\r\nreturn resultado;\r\n}\r\n}\r\n\r\n// USO DE LA CLASE LECTOR ARCHIVOS\r\nasync function usarLectorArchivos() {\r\nconst lector = new LectorArchivos('./');\r\n\r\n// Leer archivo de texto normal\r\nconst resultadoTexto = await lector.leer('documento.txt');\r\nif (resultadoTexto.exito) {\r\nconsole.log('\ud83d\udcd6 Texto le\xeddo:', resultadoTexto.contenido);\r\n} else {\r\nconsole.error('\u274c Error:', resultadoTexto.error);\r\n}\r\n\r\n// Leer archivo JSON\r\nconst resultadoJSON = await lector.leerJSON('config.json');\r\nif (resultadoJSON.exito) {\r\nconsole.log('\ud83d\udcca JSON le\xeddo:', resultadoJSON.datos);\r\n} else {\r\nconsole.error('\u274c Error JSON:', resultadoJSON.error);\r\n}\r\n}\r\n\r\n// ============================================================================\r\n// EJECUTAR TODOS LOS EJEMPLOS\r\n// ============================================================================\r\n\r\nasync function ejecutarEjemplos() {\r\nconsole.log('\ud83d\ude80 INICIANDO EJEMPLOS DE LECTURA DE ARCHIVOS\\n');\r\n\r\nconsole.log('1. \ud83d\udcc4 Ejemplo b\xe1sico:');\r\nawait leerArchivoTexto();\r\n\r\nconsole.log('\\n2. \ud83d\udd27 Ejemplo con manejo espec\xedfico de errores:');\r\nawait leerConManejoEspecificoDeErrores();\r\n\r\nconsole.log('\\n3. \ud83d\udcca Ejemplo con JSON:');\r\nawait leerArchivoJSON();\r\n\r\nconsole.log('\\n4. \ud83d\udcda Ejemplo con procesamiento de l\xedneas:');\r\nawait leerYProcesarLineas();\r\n\r\nconsole.log('\\n5. \ud83d\udee0\ufe0f  Ejemplo con clase LectorArchivos:');\r\nawait usarLectorArchivos();\r\n\r\nconsole.log('\\n\u2705 TODOS LOS EJEMPLOS COMPLETADOS');\r\n}\r\n\r\n// Descomentar para ejecutar todos los ejemplos:\r\n// ejecutarEjemplos();\n"})}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"CARACTER\xcdSTICAS PRINCIPALES EXPLICADAS:"})}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:(0,a.jsx)(n.code,{children:"fs/promises"})}),": Versi\xf3n moderna con soporte para Promises/async-await"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:(0,a.jsx)(n.code,{children:"readFile()"})}),": Funci\xf3n as\xedncrona para leer archivos completos"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Codificaci\xf3n 'utf8'"}),": Especifica que el archivo es texto con codificaci\xf3n UTF-8"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Manejo de errores con try/catch"}),": Captura errores de forma elegante"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Await"}),": Espera a que la operaci\xf3n de lectura se complete"]}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"ERRORES COMUNES MANEJADOS:"})}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"ENOENT"}),": Archivo no existe"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"EACCES"}),": Permisos insuficientes"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"EISDIR"}),": La ruta es un directorio"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"SyntaxError"}),": JSON mal formado"]}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:"Este c\xf3digo proporciona una base s\xf3lida para trabajar con archivos en Node.js de manera moderna y eficiente usando async/await."}),"\n",(0,a.jsx)(n.h3,{id:"lectura-de-archivos-binarios",children:"Lectura de Archivos Binarios"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-jsx",children:'// Importar el m\xf3dulo de sistema de archivos con soporte para Promises\r\n// fs/promises permite trabajar con archivos de manera as\xedncrona usando async/await\r\nimport fs from "fs/promises";\r\n\r\n// Funci\xf3n as\xedncrona para leer un archivo binario\r\n// Los archivos binarios son: im\xe1genes, videos, PDFs, ejecutables, etc.\r\nasync function leerArchivoBinario() {\r\n  try {\r\n    // Leer archivo sin especificar codificaci\xf3n (devuelve Buffer)\r\n    // Cuando no se especifica codificaci\xf3n, fs.readFile() retorna un Buffer\r\n    // Buffer es un objeto de Node.js que representa datos binarios en crudo\r\n    const buffer = await fs.readFile("./imagen.jpg");\r\n\r\n    // Mostrar informaci\xf3n sobre el buffer\r\n    console.log("Tama\xf1o del archivo:", buffer.length, "bytes");\r\n    console.log("Primeros bytes:", buffer.slice(0, 10));\r\n  } catch (error) {\r\n    console.error("Error al leer el archivo binario:", error.message);\r\n  }\r\n}\r\n\r\n// Ejecutar la funci\xf3n\r\nleerArchivoBinario();\r\n\r\n// ============================================================================\r\n// EXPLICACI\xd3N DETALLADA SOBRE BUFFERS Y ARCHIVOS BINARIOS\r\n// ============================================================================\r\n\r\n// \xbfQU\xc9 ES UN BUFFER?\r\n// - Un Buffer es una representaci\xf3n de datos binarios en memoria\r\n// - Similar a un array de bytes, pero optimizado para operaciones I/O\r\n// - Cada elemento es un n\xfamero entre 0-255 (1 byte)\r\n// - No tiene codificaci\xf3n de caracteres\r\n\r\n// EJEMPLO 1: AN\xc1LISIS DETALLADO DEL BUFFER\r\nasync function analizarBufferDetalladamente() {\r\n  try {\r\n    const buffer = await fs.readFile("./imagen.jpg");\r\n\r\n    console.log("\\n=== AN\xc1LISIS DETALLADO DEL BUFFER ===");\r\n    console.log("Longitud total:", buffer.length, "bytes");\r\n    console.log("Longitud en KB:", (buffer.length / 1024).toFixed(2), "KB");\r\n    console.log(\r\n      "Longitud en MB:",\r\n      (buffer.length / (1024 * 1024)).toFixed(2),\r\n      "MB"\r\n    );\r\n\r\n    // Verificar si es una imagen JPEG (empieza con FF D8 FF)\r\n    const signature = buffer.slice(0, 3);\r\n    console.log("Firma hexadecimal:", signature.toString("hex"));\r\n\r\n    if (signature.toString("hex") === "ffd8ff") {\r\n      console.log("\u2705 Es un archivo JPEG v\xe1lido");\r\n    }\r\n\r\n    // Mostrar diferentes representaciones de los primeros bytes\r\n    console.log("\\nPrimeros 10 bytes en diferentes formatos:");\r\n    console.log("Hexadecimal:", buffer.slice(0, 10).toString("hex"));\r\n    console.log("Decimal:", Array.from(buffer.slice(0, 10)));\r\n    console.log("Base64:", buffer.slice(0, 10).toString("base64"));\r\n  } catch (error) {\r\n    console.error("Error en an\xe1lisis detallado:", error.message);\r\n  }\r\n}\r\n\r\n// EJEMPLO 2: DETECCI\xd3N DE TIPO DE ARCHIVO POR FIRMA\r\nasync function detectarTipoArchivo() {\r\n  try {\r\n    const buffer = await fs.readFile("./imagen.jpg");\r\n    const primerosBytes = buffer.slice(0, 8); // Primeros 8 bytes para la firma\r\n\r\n    const firmasConocidas = {\r\n      ffd8ffe0: "JPEG",\r\n      "89504e47": "PNG",\r\n      47494638: "GIF",\r\n      25504446: "PDF",\r\n      "504b0304": "ZIP",\r\n      52494646: "WEBP",\r\n      "49492a00": "TIFF",\r\n      "4d4d002a": "TIFF (big-endian)",\r\n    };\r\n\r\n    const hexSignature = primerosBytes.toString("hex");\r\n    console.log("\\n=== DETECCI\xd3N DE TIPO DE ARCHIVO ===");\r\n    console.log("Firma encontrada:", hexSignature);\r\n\r\n    const tipo = firmasConocidas[hexSignature] || "Desconocido";\r\n    console.log("Tipo detectado:", tipo);\r\n  } catch (error) {\r\n    console.error("Error en detecci\xf3n de tipo:", error.message);\r\n  }\r\n}\r\n\r\n// EJEMPLO 3: LECTURA DE DIFERENTES TIPOS DE ARCHIVOS BINARIOS\r\nasync function leerDiferentesTiposBinarios() {\r\n  const archivos = [\r\n    "./imagen.jpg",\r\n    "./documento.pdf",\r\n    "./video.mp4",\r\n    "./audio.mp3",\r\n    "./archivo.zip",\r\n  ];\r\n\r\n  for (const archivo of archivos) {\r\n    try {\r\n      console.log(`\\n=== PROCESANDO: ${archivo} ===`);\r\n\r\n      // Verificar si el archivo existe antes de leerlo\r\n      await fs.access(archivo);\r\n\r\n      const buffer = await fs.readFile(archivo);\r\n      console.log(\r\n        `Tama\xf1o: ${buffer.length} bytes (${(\r\n          buffer.length /\r\n          1024 /\r\n          1024\r\n        ).toFixed(2)} MB)`\r\n      );\r\n\r\n      // Mostrar firma m\xe1gica\r\n      const signature = buffer.slice(0, 4).toString("hex");\r\n      console.log(`Firma: ${signature}`);\r\n    } catch (error) {\r\n      if (error.code === "ENOENT") {\r\n        console.log(`\u274c ${archivo} no existe`);\r\n      } else {\r\n        console.error(`Error con ${archivo}:`, error.message);\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\n// EJEMPLO 4: CONVERSI\xd3N DE BUFFER A DIFERENTES FORMATOS\r\nasync function convertirBufferFormatos() {\r\n  try {\r\n    const buffer = await fs.readFile("./imagen.jpg");\r\n\r\n    console.log("\\n=== CONVERSIONES DE BUFFER ===");\r\n\r\n    // A Base64 (\xfatil para Data URLs en web)\r\n    const base64 = buffer.toString("base64");\r\n    console.log(\r\n      "Base64 (primeros 100 chars):",\r\n      base64.substring(0, 100) + "..."\r\n    );\r\n\r\n    // A Hexadecimal\r\n    const hex = buffer.toString("hex");\r\n    console.log(\r\n      "Hexadecimal (primeros 20 chars):",\r\n      hex.substring(0, 20) + "..."\r\n    );\r\n\r\n    // A String (puede no ser legible para binario)\r\n    const asString = buffer.toString("utf8");\r\n    console.log(\r\n      "Como string UTF-8 (primeros 50 chars):",\r\n      asString.substring(0, 50)\r\n    );\r\n\r\n    // Array de n\xfameros\r\n    const array = Array.from(buffer.slice(0, 5));\r\n    console.log("Como array de n\xfameros:", array);\r\n  } catch (error) {\r\n    console.error("Error en conversiones:", error.message);\r\n  }\r\n}\r\n\r\n// EJEMPLO 5: LECTURA POR PARTES (CHUNKS) - PARA ARCHIVOS MUY GRANDES\r\nasync function leerArchivoGrande() {\r\n  try {\r\n    // Para archivos muy grandes, es mejor leer por partes\r\n    // Pero para este ejemplo, simulamos con un archivo normal\r\n\r\n    const buffer = await fs.readFile("./imagen.jpg");\r\n\r\n    console.log("\\n=== LECTURA POR PARTES SIMULADA ===");\r\n    console.log("Tama\xf1o total:", buffer.length, "bytes");\r\n\r\n    const chunkSize = 1024; // 1KB por chunk\r\n    let offset = 0;\r\n    let chunkNumber = 1;\r\n\r\n    while (offset < buffer.length) {\r\n      const chunk = buffer.slice(offset, offset + chunkSize);\r\n      console.log(`Chunk ${chunkNumber}: ${chunk.length} bytes`);\r\n\r\n      offset += chunkSize;\r\n      chunkNumber++;\r\n\r\n      // Solo mostrar primeros 5 chunks para no saturar la consola\r\n      if (chunkNumber > 5) {\r\n        console.log(\r\n          `... y ${Math.ceil((buffer.length - offset) / chunkSize)} chunks m\xe1s`\r\n        );\r\n        break;\r\n      }\r\n    }\r\n  } catch (error) {\r\n    console.error("Error en lectura por partes:", error.message);\r\n  }\r\n}\r\n\r\n// EJEMPLO 6: COMPARACI\xd3N DE ARCHIVOS BINARIOS\r\nasync function compararArchivos() {\r\n  try {\r\n    const [buffer1, buffer2] = await Promise.all([\r\n      fs.readFile("./imagen1.jpg"),\r\n      fs.readFile("./imagen2.jpg"),\r\n    ]);\r\n\r\n    console.log("\\n=== COMPARACI\xd3N DE ARCHIVOS ===");\r\n    console.log("Archivo 1:", buffer1.length, "bytes");\r\n    console.log("Archivo 2:", buffer2.length, "bytes");\r\n\r\n    if (buffer1.length === buffer2.length) {\r\n      console.log("\u2705 Mismo tama\xf1o");\r\n\r\n      // Comparar contenido byte por byte\r\n      let diferencias = 0;\r\n      for (let i = 0; i < buffer1.length; i++) {\r\n        if (buffer1[i] !== buffer2[i]) {\r\n          diferencias++;\r\n        }\r\n      }\r\n\r\n      console.log(`Bytes diferentes: ${diferencias}`);\r\n      console.log(\r\n        `Similitud: ${((1 - diferencias / buffer1.length) * 100).toFixed(2)}%`\r\n      );\r\n    } else {\r\n      console.log("\u274c Tama\xf1os diferentes");\r\n    }\r\n  } catch (error) {\r\n    console.error("Error en comparaci\xf3n:", error.message);\r\n  }\r\n}\r\n\r\n// EJEMPLO 7: MANIPULACI\xd3N DE BUFFER\r\nasync function manipularBuffer() {\r\n  try {\r\n    const buffer = await fs.readFile("./imagen.jpg");\r\n\r\n    console.log("\\n=== MANIPULACI\xd3N DE BUFFER ===");\r\n\r\n    // Crear un nuevo buffer con modificaci\xf3n\r\n    const nuevoBuffer = Buffer.alloc(buffer.length);\r\n    buffer.copy(nuevoBuffer);\r\n\r\n    // Modificar algunos bytes (esto podr\xeda corromper la imagen)\r\n    nuevoBuffer[0] = 0x00; // Modificar primer byte\r\n\r\n    console.log("Buffer original (primer byte):", buffer[0].toString(16));\r\n    console.log(\r\n      "Buffer modificado (primer byte):",\r\n      nuevoBuffer[0].toString(16)\r\n    );\r\n\r\n    // Guardar el buffer modificado\r\n    await fs.writeFile("./imagen_modificada.jpg", nuevoBuffer);\r\n    console.log("\u2705 Archivo modificado guardado");\r\n  } catch (error) {\r\n    console.error("Error en manipulaci\xf3n:", error.message);\r\n  }\r\n}\r\n\r\n// EJEMPLO 8: USO PR\xc1CTICO - CONVERSI\xd3N A DATA URL\r\nasync function crearDataURL() {\r\n  try {\r\n    const buffer = await fs.readFile("./imagen.jpg");\r\n\r\n    // Convertir a Base64 para Data URL\r\n    const base64 = buffer.toString("base64");\r\n    const dataURL = `data:image/jpeg;base64,${base64}`;\r\n\r\n    console.log("\\n=== DATA URL GENERADA ===");\r\n    console.log(\r\n      "Data URL (primeros 100 chars):",\r\n      dataURL.substring(0, 100) + "..."\r\n    );\r\n    console.log("Longitud total Data URL:", dataURL.length, "caracteres");\r\n\r\n    // Esto ser\xeda \xfatil para:\r\n    // - Incrustar im\xe1genes en HTML\r\n    // - Enviar im\xe1genes via APIs\r\n    // - Almacenar en bases de datos\r\n  } catch (error) {\r\n    console.error("Error creando Data URL:", error.message);\r\n  }\r\n}\r\n\r\n// EJEMPLO 9: CLASE PARA MANEJO DE ARCHIVOS BINARIOS\r\nclass ManejadorBinarios {\r\n  constructor() {\r\n    this.firmas = {\r\n      ffd8ff: "image/jpeg",\r\n      "89504e47": "image/png",\r\n      47494638: "image/gif",\r\n      25504446: "application/pdf",\r\n      "504b0304": "application/zip",\r\n    };\r\n  }\r\n\r\n  async analizarArchivo(ruta) {\r\n    try {\r\n      const buffer = await fs.readFile(ruta);\r\n      const signature = buffer.slice(0, 4).toString("hex");\r\n\r\n      return {\r\n        ruta: ruta,\r\n        tama\xf1o: buffer.length,\r\n        tipo: this.firmas[signature] || "desconocido",\r\n        firma: signature,\r\n        buffer: buffer,\r\n      };\r\n    } catch (error) {\r\n      throw new Error(`Error analizando ${ruta}: ${error.message}`);\r\n    }\r\n  }\r\n\r\n  async esMismoArchivo(ruta1, ruta2) {\r\n    try {\r\n      const [buffer1, buffer2] = await Promise.all([\r\n        fs.readFile(ruta1),\r\n        fs.readFile(ruta2),\r\n      ]);\r\n\r\n      return buffer1.equals(buffer2);\r\n    } catch (error) {\r\n      return false;\r\n    }\r\n  }\r\n}\r\n\r\n// USO DE LA CLASE MANEJADOR BINARIOS\r\nasync function usarManejadorBinarios() {\r\n  const manejador = new ManejadorBinarios();\r\n\r\n  try {\r\n    const analisis = await manejador.analizarArchivo("./imagen.jpg");\r\n    console.log("\\n=== AN\xc1LISIS CON CLASE ===");\r\n    console.log("Ruta:", analisis.ruta);\r\n    console.log("Tama\xf1o:", analisis.tama\xf1o, "bytes");\r\n    console.log("Tipo:", analisis.tipo);\r\n    console.log("Firma:", analisis.firma);\r\n  } catch (error) {\r\n    console.error("Error con manejador:", error.message);\r\n  }\r\n}\r\n\r\n// ============================================================================\r\n// EJECUTAR TODOS LOS EJEMPLOS\r\n// ============================================================================\r\n\r\nasync function ejecutarTodosLosEjemplos() {\r\n  console.log("\ud83d\ude80 INICIANDO EJEMPLOS DE ARCHIVOS BINARIOS\\n");\r\n\r\n  await analizarBufferDetalladamente();\r\n  await detectarTipoArchivo();\r\n  await convertirBufferFormatos();\r\n  await leerArchivoGrande();\r\n  await crearDataURL();\r\n  await usarManejadorBinarios();\r\n\r\n  console.log("\\n\u2705 TODOS LOS EJEMPLOS COMPLETADOS");\r\n}\r\n\r\n// Descomentar para ejecutar todos los ejemplos:\r\n// ejecutarTodosLosEjemplos();\n'})}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"CARACTER\xcdSTICAS PRINCIPALES EXPLICADAS:"})}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:(0,a.jsx)(n.code,{children:"Buffer"})}),": Objeto que representa datos binarios en memoria"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Sin codificaci\xf3n"}),": Cuando no se especifica encoding, retorna Buffer"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Operaciones binarias"}),": Ideal para im\xe1genes, PDFs, archivos comprimidos, etc."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"M\xe9todos \xfatiles"}),":\xa0",(0,a.jsx)(n.code,{children:"length"}),",\xa0",(0,a.jsx)(n.code,{children:"slice()"}),",\xa0",(0,a.jsx)(n.code,{children:"toString('hex')"}),",\xa0",(0,a.jsx)(n.code,{children:"toString('base64')"})]}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"DIFERENCIAS CLAVE ENTRE TEXTO Y BINARIO:"})}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Texto"}),": Usa codificaci\xf3n (UTF-8, ASCII), retorna string"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Binario"}),": Sin codificaci\xf3n, retorna Buffer"]}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"USOS COMUNES DE ARCHIVOS BINARIOS:"})}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Im\xe1genes (JPEG, PNG, GIF)"}),"\n",(0,a.jsx)(n.li,{children:"Documentos (PDF, DOCX)"}),"\n",(0,a.jsx)(n.li,{children:"Archivos comprimidos (ZIP, RAR)"}),"\n",(0,a.jsx)(n.li,{children:"Ejecutables y librer\xedas"}),"\n",(0,a.jsx)(n.li,{children:"Bases de datos"}),"\n",(0,a.jsx)(n.li,{children:"Archivos de audio/video"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:"Este c\xf3digo proporciona una base s\xf3lida para trabajar con archivos binarios en Node.js, esencial para aplicaciones que manejan uploads de archivos, procesamiento de im\xe1genes, o cualquier operaci\xf3n que involucre datos no textuales."}),"\n",(0,a.jsx)(n.h3,{id:"escritura-de-archivos",children:"Escritura de Archivos"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-jsx",children:'// Importar el m\xf3dulo de sistema de archivos con soporte para Promises\r\n// fs/promises proporciona m\xe9todos as\xedncronos basados en Promises\r\nimport fs from "fs/promises";\r\n\r\n// Funci\xf3n as\xedncrona para crear un archivo\r\n// Se declara como async para poder usar await\r\nasync function crearArchivo() {\r\n  try {\r\n    // Escribir contenido en un nuevo archivo\r\n    // fs.writeFile() crea un archivo nuevo o sobrescribe uno existente\r\n    const contenido = "Este es el contenido del archivo creado con Node.js";\r\n\r\n    // Par\xe1metros de fs.writeFile():\r\n    // 1. \'./nuevo-archivo.txt\' - Ruta del archivo a crear\r\n    // 2. contenido - Datos a escribir en el archivo\r\n    // 3. encoding (opcional) - Por defecto es \'utf8\' para strings\r\n    await fs.writeFile("./nuevo-archivo.txt", contenido);\r\n\r\n    console.log("\u2705 Archivo creado exitosamente");\r\n  } catch (error) {\r\n    console.error("\u274c Error al crear el archivo:", error.message);\r\n  }\r\n}\r\n\r\n// Ejecutar la funci\xf3n\r\ncrearArchivo();\r\n\r\n// ============================================================================\r\n// EJEMPLOS ADICIONALES Y EXPLICACIONES DETALLADAS\r\n// ============================================================================\r\n\r\n// EJEMPLO 1: CREAR ARCHIVO CON CODIFICACI\xd3N EXPL\xcdCITA\r\nasync function crearArchivoConCodificacion() {\r\n  try {\r\n    const contenido = "Contenido con codificaci\xf3n UTF-8 expl\xedcita";\r\n\r\n    // Especificar codificaci\xf3n UTF-8 expl\xedcitamente\r\n    await fs.writeFile("./archivo-utf8.txt", contenido, "utf8");\r\n    console.log("\u2705 Archivo UTF-8 creado");\r\n  } catch (error) {\r\n    console.error("Error:", error.message);\r\n  }\r\n}\r\n\r\n// EJEMPLO 2: CREAR ARCHIVO CON OPCIONES ADICIONALES\r\nasync function crearArchivoConOpciones() {\r\n  try {\r\n    const contenido = "Contenido con opciones adicionales";\r\n\r\n    // Usar objeto de opciones\r\n    await fs.writeFile("./archivo-opciones.txt", contenido, {\r\n      encoding: "utf8",\r\n      mode: 0o666, // Permisos del archivo (lectura/escritura para todos)\r\n      flag: "w", // \'w\' = write (escritura, crea o sobrescribe)\r\n    });\r\n\r\n    console.log("\u2705 Archivo con opciones creado");\r\n  } catch (error) {\r\n    console.error("Error:", error.message);\r\n  }\r\n}\r\n\r\n// EJEMPLO 3: CREAR ARCHIVO EN DIRECTORIO QUE NO EXISTE (CON ERROR)\r\nasync function crearArchivoEnDirectorioInexistente() {\r\n  try {\r\n    // Intentar crear archivo en directorio que no existe\r\n    await fs.writeFile("./directorio-inexistente/archivo.txt", "contenido");\r\n  } catch (error) {\r\n    console.log("\u274c Error esperado:", error.message);\r\n    console.log("C\xf3digo de error:", error.code); // ENOENT\r\n  }\r\n}\r\n\r\n// EJEMPLO 4: CREAR DIRECTORIO PRIMERO Y LUEGO ARCHIVO\r\nasync function crearDirectorioYArchivo() {\r\n  try {\r\n    const directorio = "./mi-directorio";\r\n    const archivo = `${directorio}/mi-archivo.txt`;\r\n    const contenido = "Archivo creado despu\xe9s del directorio";\r\n\r\n    // Crear directorio primero (con recursive: true para crear m\xfaltiples niveles)\r\n    await fs.mkdir(directorio, { recursive: true });\r\n    console.log("\u2705 Directorio creado");\r\n\r\n    // Luego crear el archivo\r\n    await fs.writeFile(archivo, contenido);\r\n    console.log("\u2705 Archivo creado en el directorio");\r\n  } catch (error) {\r\n    console.error("Error:", error.message);\r\n  }\r\n}\r\n\r\n// EJEMPLO 5: CREAR ARCHIVOS EN LOTE\r\nasync function crearMultiplesArchivos() {\r\n  try {\r\n    const archivos = [\r\n      { nombre: "./archivo1.txt", contenido: "Contenido del archivo 1" },\r\n      { nombre: "./archivo2.txt", contenido: "Contenido del archivo 2" },\r\n      { nombre: "./archivo3.txt", contenido: "Contenido del archivo 3" },\r\n    ];\r\n\r\n    // Usar Promise.all() para crear m\xfaltiples archivos simult\xe1neamente\r\n    const promesas = archivos.map((archivo) =>\r\n      fs.writeFile(archivo.nombre, archivo.contenido)\r\n    );\r\n\r\n    await Promise.all(promesas);\r\n    console.log(`\u2705 ${archivos.length} archivos creados exitosamente`);\r\n  } catch (error) {\r\n    console.error("Error creando archivos m\xfaltiples:", error.message);\r\n  }\r\n}\r\n\r\n// EJEMPLO 6: CREAR ARCHIVO CON CONTENIDO DIN\xc1MICO\r\nasync function crearArchivoConContenidoDinamico() {\r\n  try {\r\n    const timestamp = new Date().toISOString();\r\n    const contenido = `\r\n# Archivo generado autom\xe1ticamente\r\nFecha de creaci\xf3n: ${timestamp}\r\nUsuario: ${process.env.USER || "desconocido"}\r\nDirectorio: ${process.cwd()}\r\n\r\nEste archivo fue generado por un script de Node.js.\r\n        `.trim();\r\n\r\n    await fs.writeFile("./archivo-generado.md", contenido);\r\n    console.log("\u2705 Archivo Markdown creado con contenido din\xe1mico");\r\n  } catch (error) {\r\n    console.error("Error:", error.message);\r\n  }\r\n}\r\n\r\n// EJEMPLO 7: CREAR ARCHIVO CON DATOS JSON\r\nasync function crearArchivoJSON() {\r\n  try {\r\n    const datos = {\r\n      usuario: {\r\n        nombre: "Ana Garc\xeda",\r\n        email: "ana@ejemplo.com",\r\n        activo: true,\r\n        preferencias: {\r\n          tema: "oscuro",\r\n          idioma: "es",\r\n        },\r\n      },\r\n      fechaCreacion: new Date().toISOString(),\r\n      version: "1.0.0",\r\n    };\r\n\r\n    // Convertir objeto a JSON con formato legible\r\n    const contenidoJSON = JSON.stringify(datos, null, 2);\r\n\r\n    await fs.writeFile("./configuracion.json", contenidoJSON);\r\n    console.log("\u2705 Archivo JSON creado con formato legible");\r\n  } catch (error) {\r\n    console.error("Error:", error.message);\r\n  }\r\n}\r\n\r\n// EJEMPLO 8: CREAR ARCHIVO BINARIO\r\nasync function crearArchivoBinario() {\r\n  try {\r\n    // Crear un Buffer con datos binarios\r\n    const buffer = Buffer.from([0x48, 0x65, 0x6c, 0x6c, 0x6f]); // "Hello" en ASCII\r\n\r\n    // Para archivos binarios, no especificar encoding\r\n    await fs.writeFile("./archivo-binario.dat", buffer);\r\n    console.log("\u2705 Archivo binario creado");\r\n\r\n    // Verificar el contenido\r\n    const contenidoLeido = await fs.readFile("./archivo-binario.dat");\r\n    console.log("Contenido le\xeddo:", contenidoLeido.toString()); // "Hello"\r\n  } catch (error) {\r\n    console.error("Error:", error.message);\r\n  }\r\n}\r\n\r\n// EJEMPLO 9: CREAR ARCHIVO CON MODOS DE ESCRITURA DIFERENTES\r\nasync function crearArchivoConDiferentesFlags() {\r\n  try {\r\n    const archivo = "./archivo-flags.txt";\r\n\r\n    // \'w\' - Write: Crea nuevo o sobrescribe existente (por defecto)\r\n    await fs.writeFile(archivo, "Contenido inicial\\n", { flag: "w" });\r\n\r\n    // \'a\' - Append: A\xf1ade al final del archivo (no sobrescribe)\r\n    await fs.writeFile(archivo, "L\xednea a\xf1adida\\n", { flag: "a" });\r\n    await fs.writeFile(archivo, "Otra l\xednea m\xe1s\\n", { flag: "a" });\r\n\r\n    console.log("\u2705 Archivo con append creado");\r\n\r\n    // Leer para verificar\r\n    const contenido = await fs.readFile(archivo, "utf8");\r\n    console.log("Contenido final:");\r\n    console.log(contenido);\r\n  } catch (error) {\r\n    console.error("Error:", error.message);\r\n  }\r\n}\r\n\r\n// EJEMPLO 10: CREAR ARCHIVO CON MANEJO DE ERRORES ESPEC\xcdFICOS\r\nasync function crearArchivoConManejoErrores() {\r\n  try {\r\n    const archivo = "./archivo-protegido.txt";\r\n\r\n    // Intentar crear archivo\r\n    await fs.writeFile(archivo, "contenido");\r\n    console.log("\u2705 Archivo creado exitosamente");\r\n  } catch (error) {\r\n    // Manejar diferentes tipos de errores espec\xedficamente\r\n    switch (error.code) {\r\n      case "EACCES":\r\n        console.error(\r\n          "\u274c Error de permisos: No tienes acceso para escribir en esta ubicaci\xf3n"\r\n        );\r\n        break;\r\n      case "ENOENT":\r\n        console.error("\u274c Error de ruta: El directorio no existe");\r\n        break;\r\n      case "EISDIR":\r\n        console.error(\r\n          "\u274c Error de tipo: La ruta especificada es un directorio"\r\n        );\r\n        break;\r\n      case "ENOSPC":\r\n        console.error(\r\n          "\u274c Error de espacio: No hay espacio disponible en el disco"\r\n        );\r\n        break;\r\n      default:\r\n        console.error("\u274c Error desconocido:", error.message);\r\n    }\r\n  }\r\n}\r\n\r\n// EJEMPLO 11: CREAR ARCHIVO DE LOG CON TIMESTAMP\r\nasync function crearArchivoLog() {\r\n  try {\r\n    const logEntry = `[${new Date().toISOString()}] - Mensaje de log generado\\n`;\r\n\r\n    // Usar append para a\xf1adir al archivo de log\r\n    await fs.writeFile("./app.log", logEntry, { flag: "a" });\r\n    console.log("\u2705 Entrada de log a\xf1adida");\r\n  } catch (error) {\r\n    console.error("Error en log:", error.message);\r\n  }\r\n}\r\n\r\n// EJEMPLO 12: CLASE PARA MANEJO DE ARCHIVOS DE TEXTO\r\nclass ManejadorArchivos {\r\n  constructor(directorioBase = "./") {\r\n    this.directorioBase = directorioBase;\r\n  }\r\n\r\n  async crear(nombreArchivo, contenido, opciones = {}) {\r\n    try {\r\n      const rutaCompleta = `${this.directorioBase}/${nombreArchivo}`;\r\n      await fs.writeFile(rutaCompleta, contenido, {\r\n        encoding: "utf8",\r\n        ...opciones,\r\n      });\r\n\r\n      return {\r\n        exito: true,\r\n        ruta: rutaCompleta,\r\n        tama\xf1o: contenido.length,\r\n      };\r\n    } catch (error) {\r\n      return {\r\n        exito: false,\r\n        error: error.message,\r\n        codigo: error.code,\r\n      };\r\n    }\r\n  }\r\n\r\n  async crearJSON(nombreArchivo, datos, opciones = {}) {\r\n    const contenido = JSON.stringify(datos, null, 2);\r\n    return await this.crear(nombreArchivo, contenido, opciones);\r\n  }\r\n\r\n  async crearDesdeTemplate(nombreArchivo, template, variables = {}) {\r\n    let contenido = template;\r\n\r\n    // Reemplazar variables en el template\r\n    Object.keys(variables).forEach((key) => {\r\n      const valor = variables[key];\r\n      contenido = contenido.replace(new RegExp(`{{${key}}}`, "g"), valor);\r\n    });\r\n\r\n    return await this.crear(nombreArchivo, contenido);\r\n  }\r\n}\r\n\r\n// USO DE LA CLASE MANEJADOR ARCHIVOS\r\nasync function usarManejadorArchivos() {\r\n  const manejador = new ManejadorArchivos("./archivos-generados");\r\n\r\n  // Crear directorio primero\r\n  await fs.mkdir("./archivos-generados", { recursive: true });\r\n\r\n  // 1. Crear archivo de texto normal\r\n  const resultado1 = await manejador.crear(\r\n    "mi-archivo.txt",\r\n    "Contenido de ejemplo"\r\n  );\r\n  console.log("Resultado 1:", resultado1.exito ? "\u2705 \xc9xito" : "\u274c Error");\r\n\r\n  // 2. Crear archivo JSON\r\n  const resultado2 = await manejador.crearJSON("config.json", {\r\n    app: "Mi Aplicaci\xf3n",\r\n    version: "1.0.0",\r\n    config: { tema: "oscuro" },\r\n  });\r\n  console.log("Resultado 2:", resultado2.exito ? "\u2705 \xc9xito" : "\u274c Error");\r\n\r\n  // 3. Crear archivo desde template\r\n  const template = `\r\n# {{nombre}}\r\nBienvenido a {{appName}}\r\n\r\nFecha: {{fecha}}\r\nUsuario: {{usuario}}\r\n    `.trim();\r\n\r\n  const resultado3 = await manejador.crearDesdeTemplate("readme.md", template, {\r\n    nombre: "Mi Proyecto",\r\n    appName: "Aplicaci\xf3n Node.js",\r\n    fecha: new Date().toISOString(),\r\n    usuario: process.env.USER || "invitado",\r\n  });\r\n  console.log("Resultado 3:", resultado3.exito ? "\u2705 \xc9xito" : "\u274c Error");\r\n}\r\n\r\n// EJEMPLO 13: CREAR ARCHIVO CON VALIDACI\xd3N DE SEGURIDAD\r\nasync function crearArchivoSeguro(ruta, contenido) {\r\n  try {\r\n    // Validar que la ruta no contenga patrones peligrosos\r\n    const patronesPeligrosos = ["../", "~/", "/etc/", "/bin/"];\r\n    const esSegura = !patronesPeligrosos.some((patron) =>\r\n      ruta.includes(patron)\r\n    );\r\n\r\n    if (!esSegura) {\r\n      throw new Error("Ruta no permitida por seguridad");\r\n    }\r\n\r\n    // Validar tama\xf1o m\xe1ximo del contenido (ej: 10MB)\r\n    const maxTama\xf1o = 10 * 1024 * 1024; // 10MB\r\n    if (contenido.length > maxTama\xf1o) {\r\n      throw new Error("El contenido excede el tama\xf1o m\xe1ximo permitido");\r\n    }\r\n\r\n    await fs.writeFile(ruta, contenido);\r\n    console.log("\u2705 Archivo creado de forma segura");\r\n  } catch (error) {\r\n    console.error("\u274c Error de seguridad:", error.message);\r\n  }\r\n}\r\n\r\n// ============================================================================\r\n// EJECUTAR TODOS LOS EJEMPLOS\r\n// ============================================================================\r\n\r\nasync function ejecutarTodosLosEjemplos() {\r\n  console.log("INICIANDO EJEMPLOS DE CREACI\xd3N DE ARCHIVOS\\n");\r\n\r\n  await crearArchivoConCodificacion();\r\n  await crearArchivoConOpciones();\r\n  await crearDirectorioYArchivo();\r\n  await crearMultiplesArchivos();\r\n  await crearArchivoConContenidoDinamico();\r\n  await crearArchivoJSON();\r\n  await crearArchivoBinario();\r\n  await crearArchivoConDiferentesFlags();\r\n  await crearArchivoLog();\r\n  await usarManejadorArchivos();\r\n  await crearArchivoSeguro("./archivo-seguro.txt", "Contenido seguro");\r\n\r\n  console.log("\\nTODOS LOS EJEMPLOS COMPLETADOS");\r\n}\r\n\r\n// Descomentar para ejecutar todos los ejemplos:\r\n// ejecutarTodosLosEjemplos();\n'})}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"CARACTER\xcdSTICAS PRINCIPALES EXPLICADAS:"})}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:(0,a.jsx)(n.code,{children:"fs.writeFile()"})}),": Crea archivos nuevos o sobrescribe existentes"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Comportamiento por defecto"}),": Crea el archivo si no existe, lo sobrescribe si existe"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Codificaci\xf3n autom\xe1tica"}),": Strings se escriben como UTF-8 por defecto"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Manejo de errores"}),": Captura errores de permisos, rutas, etc."]}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"MODOS DE ESCRITURA (FLAGS):"})}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"'w'"}),": Write - Crea o sobrescribe (por defecto)"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"'a'"}),": Append - A\xf1ade al final del archivo"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"'wx'"}),": Write exclusive - Falla si el archivo existe"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"'ax'"}),": Append exclusive - Falla si el archivo existe"]}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"USOS COMUNES:"})}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Generaci\xf3n de archivos de configuraci\xf3n"}),"\n",(0,a.jsx)(n.li,{children:"Creaci\xf3n de logs"}),"\n",(0,a.jsx)(n.li,{children:"Exportaci\xf3n de datos"}),"\n",(0,a.jsx)(n.li,{children:"Generaci\xf3n de reportes"}),"\n",(0,a.jsx)(n.li,{children:"Guardado de archivos subidos por usuarios"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:"Este c\xf3digo proporciona una base s\xf3lida para trabajar con archivos en Node.js, desde operaciones simples hasta manejo avanzado con templates, JSON y validaciones de seguridad."}),"\n",(0,a.jsx)(n.h3,{id:"a\xf1adir-contenido-a-un-archivo-existente",children:"A\xf1adir Contenido a un Archivo Existente"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-jsx",children:'// Importar el m\xf3dulo de sistema de archivos con soporte para Promises\r\n// fs/promises permite trabajar con archivos de manera as\xedncrona usando async/await\r\nimport fs from "fs/promises";\r\n\r\n// Funci\xf3n as\xedncrona para a\xf1adir contenido a un archivo existente\r\n// appendFile() es espec\xedficamente para a\xf1adir contenido al final sin sobrescribir\r\nasync function a\xf1adirLinea() {\r\n  try {\r\n    // A\xf1adir contenido al final del archivo sin borrar el existente\r\n    // fs.appendFile() autom\xe1ticamente abre el archivo en modo "append"\r\n    const nuevaLinea = "\\nEsta l\xednea se a\xf1adi\xf3 despu\xe9s";\r\n\r\n    // Par\xe1metros de fs.appendFile():\r\n    // 1. \'./nuevo-archivo.txt\' - Ruta del archivo\r\n    // 2. nuevaLinea - Contenido a a\xf1adir al final\r\n    // 3. encoding (opcional) - Por defecto es \'utf8\' para strings\r\n    await fs.appendFile("./nuevo-archivo.txt", nuevaLinea);\r\n\r\n    console.log("\u2705 L\xednea a\xf1adida al archivo");\r\n  } catch (error) {\r\n    console.error("\u274c Error al a\xf1adir contenido:", error.message);\r\n  }\r\n}\r\n\r\n// Ejecutar la funci\xf3n\r\na\xf1adirLinea();\r\n\r\n// ============================================================================\r\n// EJEMPLOS ADICIONALES Y EXPLICACIONES DETALLADAS\r\n// ============================================================================\r\n\r\n// EJEMPLO 1: A\xd1ADIR CONTENIDO CON TIMESTAMP\r\nasync function a\xf1adirConTimestamp() {\r\n  try {\r\n    const timestamp = new Date().toISOString();\r\n    const linea = `[${timestamp}] - Evento registrado\\n`;\r\n\r\n    await fs.appendFile("./registro.log", linea);\r\n    console.log("Evento registrado con timestamp");\r\n  } catch (error) {\r\n    console.error("Error:", error.message);\r\n  }\r\n}\r\n\r\n// EJEMPLO 2: A\xd1ADIR M\xdaLTIPLES L\xcdNEAS\r\nasync function a\xf1adirMultiplesLineas() {\r\n  try {\r\n    const lineas = [\r\n      "\\n=== NUEVA SECCI\xd3N ===",\r\n      "L\xednea 1 del nuevo contenido",\r\n      "L\xednea 2 del nuevo contenido",\r\n      "L\xednea 3 del nuevo contenido",\r\n      "=== FIN SECCI\xd3N ===\\n",\r\n    ];\r\n\r\n    // Unir todas las l\xedneas con saltos de l\xednea\r\n    const contenido = lineas.join("\\n");\r\n    await fs.appendFile("./archivo-multilinea.txt", contenido);\r\n\r\n    console.log("M\xfaltiples l\xedneas a\xf1adidas");\r\n  } catch (error) {\r\n    console.error("Error:", error.message);\r\n  }\r\n}\r\n\r\n// EJEMPLO 3: A\xd1ADIR CONTENIDO CON CODIFICACI\xd3N ESPEC\xcdFICA\r\nasync function a\xf1adirConCodificacion() {\r\n  try {\r\n    const contenido = "\\nContenido con codificaci\xf3n espec\xedfica";\r\n\r\n    // Especificar codificaci\xf3n expl\xedcitamente\r\n    await fs.appendFile("./archivo-codificado.txt", contenido, "utf8");\r\n    console.log("Contenido a\xf1adido con codificaci\xf3n UTF-8");\r\n  } catch (error) {\r\n    console.error("Error:", error.message);\r\n  }\r\n}\r\n\r\n// EJEMPLO 4: A\xd1ADIR CONTENIDO CON OPCIONES\r\nasync function a\xf1adirConOpciones() {\r\n  try {\r\n    const contenido = "\\nL\xednea a\xf1adida con opciones";\r\n\r\n    // Usar objeto de opciones (aunque appendFile tiene pocas opciones)\r\n    await fs.appendFile("./archivo-opciones.txt", contenido, {\r\n      encoding: "utf8",\r\n      // Nota: appendFile no soporta \'flag\' ya que siempre usa \'a\'\r\n    });\r\n\r\n    console.log("Contenido a\xf1adido con opciones");\r\n  } catch (error) {\r\n    console.error("Error:", error.message);\r\n  }\r\n}\r\n\r\n// EJEMPLO 5: CREAR ARCHIVO SI NO EXISTE CON APPEND\r\nasync function crearSiNoExiste() {\r\n  try {\r\n    // appendFile crea el archivo autom\xe1ticamente si no existe\r\n    const contenido = "Este es el primer contenido del archivo\\n";\r\n    await fs.appendFile("./archivo-nuevo.txt", contenido);\r\n\r\n    console.log("Archivo creado (si no exist\xeda) y contenido a\xf1adido");\r\n  } catch (error) {\r\n    console.error("Error:", error.message);\r\n  }\r\n}\r\n\r\n// EJEMPLO 6: SISTEMA DE LOGGING CON APPEND\r\nasync function sistemaLogging() {\r\n  try {\r\n    const niveles = ["INFO", "WARN", "ERROR"];\r\n    const nivel = niveles[Math.floor(Math.random() * niveles.length)];\r\n    const mensaje = "Este es un mensaje de log de ejemplo";\r\n    const timestamp = new Date().toISOString();\r\n\r\n    const entradaLog = `[${timestamp}] [${nivel}] ${mensaje}\\n`;\r\n\r\n    await fs.appendFile("./app.log", entradaLog);\r\n    console.log(`Log ${nivel} registrado`);\r\n  } catch (error) {\r\n    console.error("Error en sistema de logging:", error.message);\r\n  }\r\n}\r\n\r\n// EJEMPLO 7: A\xd1ADIR CONTENIDO A ARCHIVO CSV\r\nasync function a\xf1adirDatosCSV() {\r\n  try {\r\n    const datos = [\r\n      { nombre: "Ana Garc\xeda", edad: 28, ciudad: "Madrid" },\r\n      { nombre: "Carlos L\xf3pez", edad: 32, ciudad: "Barcelona" },\r\n      { nombre: "Mar\xeda Rodr\xedguez", edad: 25, ciudad: "Valencia" },\r\n    ];\r\n\r\n    for (const persona of datos) {\r\n      const lineaCSV = `\\n${persona.nombre},${persona.edad},${persona.ciudad}`;\r\n      await fs.appendFile("./datos.csv", lineaCSV);\r\n    }\r\n\r\n    console.log("Datos CSV a\xf1adidos al archivo");\r\n  } catch (error) {\r\n    console.error("Error:", error.message);\r\n  }\r\n}\r\n\r\n// EJEMPLO 8: A\xd1ADIR CONTENIDO CON VERIFICACI\xd3N PREVIA\r\nasync function a\xf1adirConVerificacion() {\r\n  try {\r\n    const archivo = "./archivo-verificado.txt";\r\n    const nuevoContenido = "\\nL\xednea verificada antes de a\xf1adir";\r\n\r\n    // Verificar si el archivo existe antes de a\xf1adir\r\n    try {\r\n      await fs.access(archivo);\r\n      console.log("Archivo existe, a\xf1adiendo contenido...");\r\n    } catch (error) {\r\n      if (error.code === "ENOENT") {\r\n        console.log("Archivo no existe, creando con contenido inicial...");\r\n        // Crear archivo con contenido inicial\r\n        await fs.writeFile(archivo, "Contenido inicial\\n");\r\n      } else {\r\n        throw error; // Relanzar otros errores\r\n      }\r\n    }\r\n\r\n    // A\xf1adir el nuevo contenido\r\n    await fs.appendFile(archivo, nuevoContenido);\r\n    console.log("Contenido a\xf1adido despu\xe9s de verificaci\xf3n");\r\n  } catch (error) {\r\n    console.error("Error en verificaci\xf3n:", error.message);\r\n  }\r\n}\r\n\r\n// EJEMPLO 9: A\xd1ADIR CONTENIDO EN LOTE (BATCH)\r\nasync function a\xf1adirEnLote() {\r\n  try {\r\n    const archivo = "./archivo-lote.txt";\r\n    const lineas = Array.from({ length: 10 }, (_, i) => `L\xednea ${i + 1}\\n`);\r\n\r\n    console.log("A\xf1adiendo 10 l\xedneas en operaci\xf3n \xfanica...");\r\n\r\n    // A\xf1adir todas las l\xedneas en una sola operaci\xf3n\r\n    const contenidoLote = lineas.join("");\r\n    await fs.appendFile(archivo, contenidoLote);\r\n\r\n    console.log("\u2705 10 l\xedneas a\xf1adidas en lote");\r\n  } catch (error) {\r\n    console.error("Error en lote:", error.message);\r\n  }\r\n}\r\n\r\n// EJEMPLO 10: A\xd1ADIR CONTENIDO CON L\xcdMITE DE TAMA\xd1O\r\nasync function a\xf1adirConLimiteTama\xf1o() {\r\n  try {\r\n    const archivo = "./archivo-limitado.txt";\r\n    const nuevoContenido = "\\nNueva l\xednea de contenido";\r\n    const maxTama\xf1o = 1024; // 1KB m\xe1ximo\r\n\r\n    // Verificar tama\xf1o actual del archivo\r\n    let stats;\r\n    try {\r\n      stats = await fs.stat(archivo);\r\n    } catch (error) {\r\n      if (error.code === "ENOENT") {\r\n        // Archivo no existe, est\xe1 bien\r\n        stats = { size: 0 };\r\n      } else {\r\n        throw error;\r\n      }\r\n    }\r\n\r\n    // Verificar que no exceda el l\xedmite\r\n    const tama\xf1oDespues =\r\n      stats.size + Buffer.byteLength(nuevoContenido, "utf8");\r\n\r\n    if (tama\xf1oDespues > maxTama\xf1o) {\r\n      console.log("L\xedmite de tama\xf1o alcanzado, no se a\xf1ade contenido");\r\n      return;\r\n    }\r\n\r\n    await fs.appendFile(archivo, nuevoContenido);\r\n    console.log("Contenido a\xf1adido (dentro del l\xedmite de tama\xf1o)");\r\n  } catch (error) {\r\n    console.error("Error con l\xedmite:", error.message);\r\n  }\r\n}\r\n\r\n// EJEMPLO 11: CLASE PARA MANEJO DE ARCHIVOS CON APPEND\r\nclass ManejadorAppend {\r\n  constructor(archivoBase) {\r\n    this.archivo = archivoBase;\r\n  }\r\n\r\n  async a\xf1adirLinea(contenido, addNewLine = true) {\r\n    try {\r\n      const texto = addNewLine ? `\\n${contenido}` : contenido;\r\n      await fs.appendFile(this.archivo, texto);\r\n\r\n      return {\r\n        exito: true,\r\n        mensaje: "L\xednea a\xf1adida exitosamente",\r\n      };\r\n    } catch (error) {\r\n      return {\r\n        exito: false,\r\n        error: error.message,\r\n        codigo: error.code,\r\n      };\r\n    }\r\n  }\r\n\r\n  async a\xf1adirLineaConTimestamp(contenido) {\r\n    const timestamp = new Date().toISOString();\r\n    const lineaConTimestamp = `[${timestamp}] ${contenido}`;\r\n    return await this.a\xf1adirLinea(lineaConTimestamp);\r\n  }\r\n\r\n  async a\xf1adirJSON(datos) {\r\n    try {\r\n      const lineaJSON = `\\n${JSON.stringify(datos)}`;\r\n      await fs.appendFile(this.archivo, lineaJSON);\r\n\r\n      return { exito: true };\r\n    } catch (error) {\r\n      return {\r\n        exito: false,\r\n        error: error.message,\r\n      };\r\n    }\r\n  }\r\n\r\n  async obtenerEstadisticas() {\r\n    try {\r\n      const stats = await fs.stat(this.archivo);\r\n      const contenido = await fs.readFile(this.archivo, "utf8");\r\n      const lineas = contenido.split("\\n").filter((line) => line.trim() !== "");\r\n\r\n      return {\r\n        tama\xf1o: stats.size,\r\n        lineas: lineas.length,\r\n        ultimaModificacion: stats.mtime,\r\n      };\r\n    } catch (error) {\r\n      if (error.code === "ENOENT") {\r\n        return { tama\xf1o: 0, lineas: 0, ultimaModificacion: null };\r\n      }\r\n      throw error;\r\n    }\r\n  }\r\n}\r\n\r\n// USO DE LA CLASE MANEJADOR APPEND\r\nasync function usarManejadorAppend() {\r\n  const manejador = new ManejadorAppend("./archivo-manejado.txt");\r\n\r\n  // A\xf1adir algunas l\xedneas\r\n  await manejador.a\xf1adirLinea("Primera l\xednea");\r\n  await manejador.a\xf1adirLineaConTimestamp("Evento importante");\r\n  await manejador.a\xf1adirJSON({ usuario: "ana", accion: "login" });\r\n\r\n  // Obtener estad\xedsticas\r\n  const stats = await manejador.obtenerEstadisticas();\r\n  console.log("Estad\xedsticas del archivo:");\r\n  console.log("- Tama\xf1o:", stats.tama\xf1o, "bytes");\r\n  console.log("- L\xedneas:", stats.lineas);\r\n  console.log("- \xdaltima modificaci\xf3n:", stats.ultimaModificacion);\r\n}\r\n\r\n// EJEMPLO 12: COMPARACI\xd3N ENTRE APPENDFILE Y WRITEFILE CON FLAG \'a\'\r\nasync function comparacionAppendVsWrite() {\r\n  try {\r\n    const contenido = "\\nL\xednea de prueba";\r\n\r\n    // M\xe9todo 1: Usando appendFile (recomendado para a\xf1adir)\r\n    await fs.appendFile("./archivo-append.txt", contenido);\r\n    console.log("\u2705 appendFile completado");\r\n\r\n    // M\xe9todo 2: Usando writeFile con flag \'a\' (mismo resultado)\r\n    await fs.writeFile("./archivo-write-flag.txt", contenido, { flag: "a" });\r\n    console.log(\'\u2705 writeFile con flag "a" completado\');\r\n\r\n    console.log(\r\n      "Ambos m\xe9todos producen el mismo resultado para a\xf1adir contenido"\r\n    );\r\n  } catch (error) {\r\n    console.error("Error en comparaci\xf3n:", error.message);\r\n  }\r\n}\r\n\r\n// EJEMPLO 13: SISTEMA DE REGISTRO DE ACTIVIDAD\r\nasync function sistemaRegistroActividad() {\r\n  try {\r\n    const actividades = [\r\n      "Usuario inici\xf3 sesi\xf3n",\r\n      "Archivo subido exitosamente",\r\n      "Configuraci\xf3n actualizada",\r\n      "Reporte generado",\r\n      "Usuario cerr\xf3 sesi\xf3n",\r\n    ];\r\n\r\n    for (const actividad of actividades) {\r\n      const timestamp = new Date().toLocaleString("es-ES");\r\n      const registro = `[${timestamp}] ${actividad}\\n`;\r\n\r\n      await fs.appendFile("./actividad.log", registro);\r\n\r\n      // Simular delay entre actividades\r\n      await new Promise((resolve) => setTimeout(resolve, 100));\r\n    }\r\n\r\n    console.log("Registro de actividades completado");\r\n\r\n    // Mostrar el contenido del log\r\n    const contenido = await fs.readFile("./actividad.log", "utf8");\r\n    console.log("\\nContenido del log de actividades:");\r\n    console.log(contenido);\r\n  } catch (error) {\r\n    console.error("Error en registro de actividades:", error.message);\r\n  }\r\n}\r\n\r\n// ============================================================================\r\n// EJECUTAR TODOS LOS EJEMPLOS\r\n// ============================================================================\r\n\r\nasync function ejecutarTodosLosEjemplos() {\r\n  console.log("INICIANDO EJEMPLOS DE APPEND FILE\\n");\r\n\r\n  await a\xf1adirConTimestamp();\r\n  await a\xf1adirMultiplesLineas();\r\n  await crearSiNoExiste();\r\n  await sistemaLogging();\r\n  await a\xf1adirDatosCSV();\r\n  await a\xf1adirConVerificacion();\r\n  await a\xf1adirEnLote();\r\n  await a\xf1adirConLimiteTama\xf1o();\r\n  await usarManejadorAppend();\r\n  await comparacionAppendVsWrite();\r\n  await sistemaRegistroActividad();\r\n\r\n  console.log("\\nTODOS LOS EJEMPLOS COMPLETADOS");\r\n}\r\n\r\n// Descomentar para ejecutar todos los ejemplos:\r\n// ejecutarTodosLosEjemplos();\n'})}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"CARACTER\xcdSTICAS PRINCIPALES EXPLICADAS:"})}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:(0,a.jsx)(n.code,{children:"fs.appendFile()"})}),": A\xf1ade contenido al final del archivo sin borrar lo existente"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Creaci\xf3n autom\xe1tica"}),": Si el archivo no existe, lo crea autom\xe1ticamente"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Modo append"}),": Siempre trabaja en modo \"a\xf1adir\" (equivalente a flag 'a')"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Eficiente"}),": Ideal para logs y registros donde se acumula informaci\xf3n"]}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsxs)(n.strong,{children:["DIFERENCIAS CLAVE CON\xa0",(0,a.jsx)(n.code,{children:"writeFile()"}),":"]})}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:(0,a.jsx)(n.code,{children:"appendFile"})}),": A\xf1ade al final, preserva contenido existente"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:(0,a.jsx)(n.code,{children:"writeFile"})}),": Sobrescribe todo el contenido (a menos que uses flag 'a')"]}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"USOS COMUNES DE APPENDFILE:"})}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Sistemas de logging"}),": A\xf1adir entradas de log"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Registros de actividad"}),": Trackear eventos en tiempo real"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Recolecci\xf3n de datos"}),": Acumular datos de sensores o m\xe9tricas"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Archivos de configuraci\xf3n"}),": A\xf1adir nuevas configuraciones"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Archivos CSV"}),": A\xf1adir nuevas filas de datos"]}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"VENTAJAS:"})}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"No destructivo"}),": Preserva el contenido existente"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Autom\xe1tico"}),": Crea el archivo si no existe"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Simple"}),": Una funci\xf3n para a\xf1adir contenido"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Eficiente"}),": Buen performance para operaciones de a\xf1adir"]}),"\n"]}),"\n",(0,a.jsxs)(n.p,{children:["Este c\xf3digo muestra c\xf3mo usar\xa0",(0,a.jsx)(n.code,{children:"appendFile()"}),"\xa0efectivamente para escenarios donde necesitas acumular informaci\xf3n en archivos sin perder el contenido previo."]}),"\n",(0,a.jsx)(n.h2,{id:"verificaci\xf3n-y-informaci\xf3n-de-archivos",children:"Verificaci\xf3n y Informaci\xf3n de Archivos"}),"\n",(0,a.jsx)(n.h3,{id:"verificar-existencia-de-archivos",children:"Verificar Existencia de Archivos"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-jsx",children:'// Importar el m\xf3dulo de sistema de archivos con soporte para Promises\r\n// fs/promises proporciona m\xe9todos as\xedncronos basados en Promises\r\nimport fs from "fs/promises";\r\n\r\n// Funci\xf3n as\xedncrona para verificar la existencia y accesibilidad de un archivo\r\n// fs.access() verifica los permisos del proceso actual para el archivo/directorio\r\nasync function verificarArchivo(ruta) {\r\n  try {\r\n    // Verificar si se puede acceder al archivo\r\n    // fs.access() lanza un error si el archivo no existe o no se puede acceder\r\n    // Por defecto verifica el permiso de lectura (fs.constants.R_OK)\r\n    await fs.access(ruta);\r\n\r\n    console.log(`El archivo ${ruta} existe y es accesible`);\r\n    return true;\r\n  } catch (error) {\r\n    // Si fs.access() lanza un error, significa que el archivo no existe o no es accesible\r\n    console.log(`El archivo ${ruta} no existe o no es accesible`);\r\n    return false;\r\n  }\r\n}\r\n\r\n// Ejecutar la funci\xf3n con un archivo que probablemente no existe\r\nverificarArchivo("./archivo-inexistente.txt");\r\n\r\n// EJEMPLOS ADICIONALES Y EXPLICACIONES DETALLADAS:\r\n\r\n// EJEMPLO 1: VERIFICACI\xd3N CON DIFERENTES PERMISOS\r\nasync function verificarPermisosDetallados(ruta) {\r\n  try {\r\n    // Verificar permisos espec\xedficos usando fs.constants\r\n    // F_OK - Verifica que el archivo existe\r\n    // R_OK - Verifica que el archivo puede ser le\xeddo\r\n    // W_OK - Verifica que el archivo puede ser escrito\r\n    // X_OK - Verifica que el archivo puede ser ejecutado\r\n\r\n    await fs.access(ruta, fs.constants.F_OK);\r\n    console.log(`El archivo ${ruta} existe`);\r\n\r\n    await fs.access(ruta, fs.constants.R_OK);\r\n    console.log(`El archivo ${ruta} puede ser le\xeddo`);\r\n\r\n    await fs.access(ruta, fs.constants.W_OK);\r\n    console.log(`El archivo ${ruta} puede ser escrito`);\r\n\r\n    // Para directorios, X_OK verifica que puede ser accedido (no ejecutado)\r\n    await fs.access(ruta, fs.constants.X_OK);\r\n    console.log(`El archivo ${ruta} puede ser ejecutado/accedido`);\r\n\r\n    return true;\r\n  } catch (error) {\r\n    console.log(`Error de acceso para ${ruta}: ${error.message}`);\r\n    return false;\r\n  }\r\n}\r\n\r\n// EJEMPLO 2: VERIFICACI\xd3N COMBINANDO M\xdaLTIPLES PERMISOS\r\nasync function verificarPermisosCombinados(ruta) {\r\n  try {\r\n    // Verificar m\xfaltiples permisos simult\xe1neamente usando OR bit a bit\r\n    // Esto verifica que el archivo existe Y puede ser le\xeddo Y escrito\r\n    await fs.access(\r\n      ruta,\r\n      fs.constants.F_OK | fs.constants.R_OK | fs.constants.W_OK\r\n    );\r\n    console.log(`El archivo ${ruta} existe, puede leerse y escribirse`);\r\n    return true;\r\n  } catch (error) {\r\n    console.log(\r\n      `El archivo ${ruta} no tiene los permisos requeridos: ${error.message}`\r\n    );\r\n    return false;\r\n  }\r\n}\r\n\r\n// EJEMPLO 3: VERIFICACI\xd3N CON MANEJO ESPEC\xcdFICO DE ERRORES\r\nasync function verificarConManejoErroresEspecifico(ruta) {\r\n  try {\r\n    await fs.access(ruta);\r\n    console.log(`El archivo ${ruta} es accesible`);\r\n    return true;\r\n  } catch (error) {\r\n    // Manejar diferentes tipos de errores espec\xedficamente\r\n    switch (error.code) {\r\n      case "ENOENT":\r\n        console.log(`El archivo ${ruta} no existe`);\r\n        break;\r\n      case "EACCES":\r\n        console.log(`Permiso denegado para acceder a ${ruta}`);\r\n        break;\r\n      case "EPERM":\r\n        console.log(`Operaci\xf3n no permitida en ${ruta}`);\r\n        break;\r\n      case "ENOTDIR":\r\n        console.log(`Un componente de la ruta no es un directorio`);\r\n        break;\r\n      case "ENAMETOOLONG":\r\n        console.log(`La ruta es demasiado larga`);\r\n        break;\r\n      default:\r\n        console.log(`Error desconocido al acceder a ${ruta}: ${error.message}`);\r\n    }\r\n    return false;\r\n  }\r\n}\r\n\r\n// EJEMPLO 4: VERIFICAR SI ES ARCHIVO O DIRECTORIO\r\nasync function verificarTipo(ruta) {\r\n  try {\r\n    // Usar fs.stat() para obtener informaci\xf3n detallada\r\n    const stats = await fs.stat(ruta);\r\n\r\n    if (stats.isFile()) {\r\n      console.log(`${ruta} es un archivo`);\r\n      console.log(`Tama\xf1o: ${stats.size} bytes`);\r\n      console.log(`Creado: ${stats.birthtime}`);\r\n      console.log(`Modificado: ${stats.mtime}`);\r\n    } else if (stats.isDirectory()) {\r\n      console.log(`${ruta} es un directorio`);\r\n    } else if (stats.isSymbolicLink()) {\r\n      console.log(`${ruta} es un enlace simb\xf3lico`);\r\n    }\r\n\r\n    return stats;\r\n  } catch (error) {\r\n    console.log(`No se pudo obtener informaci\xf3n de ${ruta}: ${error.message}`);\r\n    return null;\r\n  }\r\n}\r\n\r\n// EJEMPLO 5: FUNCI\xd3N REUTILIZABLE PARA VERIFICACI\xd3N DE ARCHIVOS\r\nclass VerificadorArchivos {\r\n  constructor() {\r\n    this.permisos = fs.constants;\r\n  }\r\n\r\n  async existe(ruta) {\r\n    try {\r\n      await fs.access(ruta, this.permisos.F_OK);\r\n      return true;\r\n    } catch {\r\n      return false;\r\n    }\r\n  }\r\n\r\n  async puedeLeer(ruta) {\r\n    try {\r\n      await fs.access(ruta, this.permisos.R_OK);\r\n      return true;\r\n    } catch {\r\n      return false;\r\n    }\r\n  }\r\n\r\n  async puedeEscribir(ruta) {\r\n    try {\r\n      await fs.access(ruta, this.permisos.W_OK);\r\n      return true;\r\n    } catch {\r\n      return false;\r\n    }\r\n  }\r\n\r\n  async puedeEjecutar(ruta) {\r\n    try {\r\n      await fs.access(ruta, this.permisos.X_OK);\r\n      return true;\r\n    } catch {\r\n      return false;\r\n    }\r\n  }\r\n\r\n  async obtenerInformacionCompleta(ruta) {\r\n    try {\r\n      const stats = await fs.stat(ruta);\r\n\r\n      return {\r\n        existe: true,\r\n        esArchivo: stats.isFile(),\r\n        esDirectorio: stats.isDirectory(),\r\n        esEnlaceSimbolico: stats.isSymbolicLink(),\r\n        tama\xf1o: stats.size,\r\n        creado: stats.birthtime,\r\n        modificado: stats.mtime,\r\n        puedeLeer: await this.puedeLeer(ruta),\r\n        puedeEscribir: await this.puedeEscribir(ruta),\r\n        puedeEjecutar: await this.puedeEjecutar(ruta),\r\n      };\r\n    } catch (error) {\r\n      return {\r\n        existe: false,\r\n        error: error.message,\r\n        codigoError: error.code,\r\n      };\r\n    }\r\n  }\r\n}\r\n\r\n// EJEMPLO 6: USO PR\xc1CTICO - VERIFICAR ANTES DE LEER\r\nasync function leerArchivoSeguro(ruta) {\r\n  // Verificar que el archivo existe y puede leerse antes de intentar leerlo\r\n  const verificador = new VerificadorArchivos();\r\n\r\n  if (!(await verificador.existe(ruta))) {\r\n    console.log(`No se puede leer ${ruta} porque no existe`);\r\n    return null;\r\n  }\r\n\r\n  if (!(await verificador.puedeLeer(ruta))) {\r\n    console.log(`No se puede leer ${ruta} por falta de permisos`);\r\n    return null;\r\n  }\r\n\r\n  try {\r\n    const contenido = await fs.readFile(ruta, "utf8");\r\n    console.log(`Archivo ${ruta} le\xeddo exitosamente`);\r\n    return contenido;\r\n  } catch (error) {\r\n    console.log(`Error inesperado al leer ${ruta}: ${error.message}`);\r\n    return null;\r\n  }\r\n}\r\n\r\n// EJEMPLO 7: VERIFICACI\xd3N DE M\xdaLTIPLES ARCHIVOS\r\nasync function verificarMultiplesArchivos(rutas) {\r\n  const resultados = {};\r\n\r\n  for (const ruta of rutas) {\r\n    try {\r\n      await fs.access(ruta);\r\n      resultados[ruta] = { existe: true, accesible: true };\r\n    } catch (error) {\r\n      resultados[ruta] = {\r\n        existe: false,\r\n        accesible: false,\r\n        error: error.message,\r\n        codigo: error.code,\r\n      };\r\n    }\r\n  }\r\n\r\n  return resultados;\r\n}\r\n\r\n// EJEMPLO 8: VERIFICACI\xd3N CON RECURSIVIDAD PARA DIRECTORIOS\r\nasync function verificarEstructuraDirectorio(directorio) {\r\n  try {\r\n    // Verificar que el directorio existe\r\n    await fs.access(directorio);\r\n\r\n    // Leer el contenido del directorio\r\n    const elementos = await fs.readdir(directorio);\r\n\r\n    const estructura = {\r\n      directorio: directorio,\r\n      existe: true,\r\n      elementos: [],\r\n    };\r\n\r\n    for (const elemento of elementos) {\r\n      const rutaCompleta = `${directorio}/${elemento}`;\r\n      const stats = await fs.stat(rutaCompleta);\r\n\r\n      estructura.elementos.push({\r\n        nombre: elemento,\r\n        esArchivo: stats.isFile(),\r\n        esDirectorio: stats.isDirectory(),\r\n        tama\xf1o: stats.size,\r\n        modificado: stats.mtime,\r\n      });\r\n    }\r\n\r\n    return estructura;\r\n  } catch (error) {\r\n    return {\r\n      directorio: directorio,\r\n      existe: false,\r\n      error: error.message,\r\n    };\r\n  }\r\n}\r\n\r\n// EJEMPLO 9: DIFERENCIA ENTRE fs.access() Y fs.stat()\r\nasync function compararAccessVsStat(ruta) {\r\n  console.log(`Comparando m\xe9todos para: ${ruta}`);\r\n\r\n  // fs.access() - Solo verifica permisos, m\xe1s r\xe1pido\r\n  try {\r\n    await fs.access(ruta);\r\n    console.log("fs.access(): El archivo es accesible");\r\n  } catch (error) {\r\n    console.log(`fs.access(): ${error.message}`);\r\n  }\r\n\r\n  // fs.stat() - Obtiene informaci\xf3n completa, m\xe1s lento pero m\xe1s detallado\r\n  try {\r\n    const stats = await fs.stat(ruta);\r\n    console.log(`fs.stat(): Existe, tama\xf1o: ${stats.size} bytes`);\r\n  } catch (error) {\r\n    console.log(`fs.stat(): ${error.message}`);\r\n  }\r\n}\r\n\r\n// EJEMPLO 10: USO EN CASO REAL - CONFIGURACI\xd3N DE APLICACI\xd3N\r\nasync function cargarConfiguracion(rutaConfig) {\r\n  const verificador = new VerificadorArchivos();\r\n\r\n  // Verificar si el archivo de configuraci\xf3n existe\r\n  if (!(await verificador.existe(rutaConfig))) {\r\n    console.log(\r\n      `Archivo de configuraci\xf3n ${rutaConfig} no encontrado, usando valores por defecto`\r\n    );\r\n    return { usarValoresPorDefecto: true };\r\n  }\r\n\r\n  // Verificar permisos de lectura\r\n  if (!(await verificador.puedeLeer(rutaConfig))) {\r\n    console.log(\r\n      `Sin permisos para leer ${rutaConfig}, usando valores por defecto`\r\n    );\r\n    return { usarValoresPorDefecto: true };\r\n  }\r\n\r\n  try {\r\n    // Cargar la configuraci\xf3n\r\n    const contenido = await fs.readFile(rutaConfig, "utf8");\r\n    const configuracion = JSON.parse(contenido);\r\n    console.log(`Configuraci\xf3n cargada desde ${rutaConfig}`);\r\n    return configuracion;\r\n  } catch (error) {\r\n    console.log(`Error al cargar configuraci\xf3n: ${error.message}`);\r\n    return { usarValoresPorDefecto: true, error: error.message };\r\n  }\r\n}\r\n\r\n// EJECUCI\xd3N DE EJEMPLOS\r\nasync function ejecutarEjemplos() {\r\n  console.log("=== EJEMPLOS DE VERIFICACI\xd3N DE ARCHIVOS ===");\r\n\r\n  // Ejemplo b\xe1sico\r\n  await verificarArchivo("./archivo-inexistente.txt");\r\n  await verificarArchivo("./package.json"); // Este deber\xeda existir\r\n\r\n  // Ejemplos avanzados\r\n  await verificarPermisosDetallados("./package.json");\r\n  await verificarConManejoErroresEspecifico("./archivo-inexistente.txt");\r\n  await verificarTipo("./");\r\n\r\n  // Usar la clase verificadora\r\n  const verificador = new VerificadorArchivos();\r\n  const info = await verificador.obtenerInformacionCompleta("./package.json");\r\n  console.log("Informaci\xf3n completa:", info);\r\n\r\n  // Comparar m\xe9todos\r\n  await compararAccessVsStat("./package.json");\r\n}\r\n\r\n// Descomentar para ejecutar\r\n// ejecutarEjemplos();\n'})}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"CARACTER\xcdSTICAS PRINCIPALES EXPLICADAS:"})}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:(0,a.jsx)(n.code,{children:"fs.access()"})}),": Verifica permisos de acceso a archivos/directorios"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Comportamiento"}),": Lanza error si no se puede acceder, no lanza error si es accesible"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Permisos disponibles"}),":","\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"fs.constants.F_OK"}),"\xa0- Verifica existencia"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"fs.constants.R_OK"}),"\xa0- Verifica permiso de lectura"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"fs.constants.W_OK"}),"\xa0- Verifica permiso de escritura"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"fs.constants.X_OK"}),"\xa0- Verifica permiso de ejecuci\xf3n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"DIFERENCIAS CLAVE:"})}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:(0,a.jsx)(n.code,{children:"fs.access()"})}),": Solo verifica permisos, m\xe1s r\xe1pido"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:(0,a.jsx)(n.code,{children:"fs.stat()"})}),": Obtiene informaci\xf3n completa (tama\xf1o, fechas, etc.), m\xe1s lento"]}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"USOS COMUNES:"})}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Validar existencia de archivos antes de operaciones"}),"\n",(0,a.jsx)(n.li,{children:"Verificar permisos antes de leer/escribir"}),"\n",(0,a.jsx)(n.li,{children:"Verificar requisitos de aplicaci\xf3n (archivos de configuraci\xf3n, etc.)"}),"\n",(0,a.jsx)(n.li,{children:"Manejo condicional basado en disponibilidad de archivos"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:"Este c\xf3digo proporciona una base s\xf3lida para verificar archivos de manera segura antes de realizar operaciones, previniendo errores y mejorando la robustez de las aplicaciones."}),"\n",(0,a.jsx)(n.h3,{id:"obtener-informaci\xf3n-detallada-de-archivos",children:"Obtener Informaci\xf3n Detallada de Archivos"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-jsx",children:'// Importar el m\xf3dulo de sistema de archivos con soporte para Promises\r\n// fs/promises proporciona m\xe9todos as\xedncronos basados en Promises\r\nimport fs from "fs/promises";\r\n\r\n// Funci\xf3n as\xedncrona para obtener informaci\xf3n detallada de un archivo o directorio\r\n// fs.stat() retorna un objeto Stats con informaci\xf3n completa sobre el sistema de archivos\r\nasync function obtenerInfoArchivo(ruta) {\r\n  try {\r\n    // Obtener estad\xedsticas del archivo\r\n    // fs.stat() retorna un objeto Stats con metadatos del archivo/directorio\r\n    const stats = await fs.stat(ruta);\r\n\r\n    // Mostrar informaci\xf3n detallada del archivo\r\n    console.log(`Informaci\xf3n del archivo: ${ruta}`);\r\n\r\n    // Verificar el tipo de elemento del sistema de archivos\r\n    console.log("Es archivo:", stats.isFile());\r\n    console.log("Es directorio:", stats.isDirectory());\r\n    console.log("Es enlace simb\xf3lico:", stats.isSymbolicLink());\r\n    console.log("Es bloque de dispositivo:", stats.isBlockDevice());\r\n    console.log("Es car\xe1cter de dispositivo:", stats.isCharacterDevice());\r\n    console.log("Es FIFO/pipe:", stats.isFIFO());\r\n    console.log("Es socket:", stats.isSocket());\r\n\r\n    // Informaci\xf3n de tama\xf1o\r\n    console.log("Tama\xf1o:", stats.size, "bytes");\r\n    console.log("Tama\xf1o en KB:", (stats.size / 1024).toFixed(2), "KB");\r\n    console.log("Tama\xf1o en MB:", (stats.size / (1024 * 1024)).toFixed(2), "MB");\r\n\r\n    // Informaci\xf3n de fechas y tiempos\r\n    console.log("Creado:", stats.birthtime.toLocaleString());\r\n    console.log("\xdaltima modificaci\xf3n:", stats.mtime.toLocaleString());\r\n    console.log("\xdaltimo acceso:", stats.atime.toLocaleString());\r\n    console.log("\xdaltimo cambio de metadatos:", stats.ctime.toLocaleString());\r\n\r\n    // Informaci\xf3n de permisos (en octal, formato est\xe1ndar Unix)\r\n    console.log("Permisos:", stats.mode.toString(8));\r\n\r\n    // Informaci\xf3n adicional disponible en el objeto Stats\r\n    console.log("UID del propietario:", stats.uid);\r\n    console.log("GID del grupo:", stats.gid);\r\n    console.log("N\xfamero de bloques asignados:", stats.blocks);\r\n    console.log("Tama\xf1o del bloque:", stats.blksize);\r\n\r\n    // Tambi\xe9n disponible: stats.dev, stats.ino, stats.nlink, stats.rdev\r\n\r\n    return stats;\r\n  } catch (error) {\r\n    console.error("Error al obtener informaci\xf3n:", error.message);\r\n    return null;\r\n  }\r\n}\r\n\r\n// Ejecutar la funci\xf3n\r\nobtenerInfoArchivo("./documento.txt");\r\n\r\n// EJEMPLOS ADICIONALES Y EXPLICACIONES DETALLADAS:\r\n\r\n// EJEMPLO 1: OBTENER INFORMACI\xd3N DE M\xdaLTIPLES ARCHIVOS\r\nasync function obtenerInfoMultiplesArchivos(rutas) {\r\n  const resultados = [];\r\n\r\n  for (const ruta of rutas) {\r\n    try {\r\n      const stats = await fs.stat(ruta);\r\n      resultados.push({\r\n        ruta: ruta,\r\n        existe: true,\r\n        esArchivo: stats.isFile(),\r\n        esDirectorio: stats.isDirectory(),\r\n        tama\xf1o: stats.size,\r\n        modificado: stats.mtime,\r\n      });\r\n    } catch (error) {\r\n      resultados.push({\r\n        ruta: ruta,\r\n        existe: false,\r\n        error: error.message,\r\n      });\r\n    }\r\n  }\r\n\r\n  return resultados;\r\n}\r\n\r\n// EJEMPLO 2: AN\xc1LISIS DETALLADO DE PERMISOS\r\nfunction analizarPermisos(stats) {\r\n  // Los permisos en Unix se representan como un n\xfamero octal\r\n  // Ejemplo: 0o100644 (archivo regular con permisos 644)\r\n  // Los \xfaltimos 3 d\xedgitos representan: propietario, grupo, otros\r\n\r\n  const modo = stats.mode;\r\n  const modoOctal = modo.toString(8);\r\n\r\n  console.log("An\xe1lisis detallado de permisos:");\r\n  console.log("Modo completo (octal):", modoOctal);\r\n  console.log("Permisos simplificados:", modoOctal.slice(-3));\r\n\r\n  // Extraer los \xfaltimos 3 d\xedgitos para permisos de usuario/grupo/otros\r\n  const permisos = modoOctal.slice(-3);\r\n  const [usuario, grupo, otros] = permisos.split("").map(Number);\r\n\r\n  console.log("Permisos del propietario:", usuario);\r\n  console.log("Permisos del grupo:", grupo);\r\n  console.log("Permisos para otros:", otros);\r\n\r\n  // Funci\xf3n para interpretar permisos num\xe9ricos\r\n  function interpretarPermisos(numero) {\r\n    const binario = numero.toString(2).padStart(3, "0");\r\n    return {\r\n      lectura: binario[0] === "1",\r\n      escritura: binario[1] === "1",\r\n      ejecucion: binario[2] === "1",\r\n    };\r\n  }\r\n\r\n  console.log("Propietario puede:", interpretarPermisos(usuario));\r\n  console.log("Grupo puede:", interpretarPermisos(grupo));\r\n  console.log("Otros pueden:", interpretarPermisos(otros));\r\n}\r\n\r\n// EJEMPLO 3: MONITOREO DE CAMBIOS EN ARCHIVOS\r\nasync function monitorearCambios(ruta, intervaloMs = 5000) {\r\n  let ultimoTama\xf1o = 0;\r\n  let ultimaModificacion = null;\r\n\r\n  const intervalo = setInterval(async () => {\r\n    try {\r\n      const stats = await fs.stat(ruta);\r\n\r\n      if (\r\n        stats.size !== ultimoTama\xf1o ||\r\n        ultimaModificacion === null ||\r\n        stats.mtime.getTime() !== ultimaModificacion.getTime()\r\n      ) {\r\n        console.log(`Cambio detectado en ${ruta}:`);\r\n        console.log(`  Tama\xf1o: ${ultimoTama\xf1o} -> ${stats.size} bytes`);\r\n        console.log(`  Modificado: ${stats.mtime.toLocaleString()}`);\r\n\r\n        ultimoTama\xf1o = stats.size;\r\n        ultimaModificacion = stats.mtime;\r\n      }\r\n    } catch (error) {\r\n      console.log(`Error monitoreando ${ruta}:`, error.message);\r\n      clearInterval(intervalo);\r\n    }\r\n  }, intervaloMs);\r\n\r\n  return intervalo;\r\n}\r\n\r\n// EJEMPLO 4: CLASE PARA GESTI\xd3N DE METADATOS DE ARCHIVOS\r\nclass GestorMetadatos {\r\n  constructor() {\r\n    this.cache = new Map();\r\n  }\r\n\r\n  async obtenerMetadatos(ruta) {\r\n    try {\r\n      const stats = await fs.stat(ruta);\r\n\r\n      const metadatos = {\r\n        ruta: ruta,\r\n        nombre: ruta.split("/").pop(),\r\n        tipo: this.obtenerTipo(stats),\r\n        tama\xf1o: stats.size,\r\n        tama\xf1oLegible: this.formatearTama\xf1o(stats.size),\r\n        creado: stats.birthtime,\r\n        modificado: stats.mtime,\r\n        accedido: stats.atime,\r\n        permisos: stats.mode.toString(8),\r\n        propietario: stats.uid,\r\n        grupo: stats.gid,\r\n        inodo: stats.ino,\r\n      };\r\n\r\n      // Guardar en cache\r\n      this.cache.set(ruta, metadatos);\r\n\r\n      return metadatos;\r\n    } catch (error) {\r\n      return {\r\n        ruta: ruta,\r\n        error: error.message,\r\n        codigoError: error.code,\r\n      };\r\n    }\r\n  }\r\n\r\n  obtenerTipo(stats) {\r\n    if (stats.isFile()) return "archivo";\r\n    if (stats.isDirectory()) return "directorio";\r\n    if (stats.isSymbolicLink()) return "enlace_simbolico";\r\n    if (stats.isBlockDevice()) return "dispositivo_bloque";\r\n    if (stats.isCharacterDevice()) return "dispositivo_caracter";\r\n    if (stats.isFIFO()) return "fifo";\r\n    if (stats.isSocket()) return "socket";\r\n    return "desconocido";\r\n  }\r\n\r\n  formatearTama\xf1o(bytes) {\r\n    const unidades = ["B", "KB", "MB", "GB", "TB"];\r\n    let tama\xf1o = bytes;\r\n    let unidadIndex = 0;\r\n\r\n    while (tama\xf1o >= 1024 && unidadIndex < unidades.length - 1) {\r\n      tama\xf1o /= 1024;\r\n      unidadIndex++;\r\n    }\r\n\r\n    return `${tama\xf1o.toFixed(2)} ${unidades[unidadIndex]}`;\r\n  }\r\n\r\n  async compararArchivos(ruta1, ruta2) {\r\n    const [meta1, meta2] = await Promise.all([\r\n      this.obtenerMetadatos(ruta1),\r\n      this.obtenerMetadatos(ruta2),\r\n    ]);\r\n\r\n    if (meta1.error || meta2.error) {\r\n      return { error: "No se pudieron obtener metadatos de ambos archivos" };\r\n    }\r\n\r\n    return {\r\n      mismoTama\xf1o: meta1.tama\xf1o === meta2.tama\xf1o,\r\n      mismaFechaModificacion:\r\n        meta1.modificado.getTime() === meta2.modificado.getTime(),\r\n      mismoTipo: meta1.tipo === meta2.tipo,\r\n      diferencias: {\r\n        tama\xf1o: Math.abs(meta1.tama\xf1o - meta2.tama\xf1o),\r\n        diasDesdeModificacion: Math.abs(\r\n          (meta1.modificado - meta2.modificado) / (1000 * 60 * 60 * 24)\r\n        ),\r\n      },\r\n    };\r\n  }\r\n}\r\n\r\n// EJEMPLO 5: USO DEL GESTOR DE METADATOS\r\nasync function usarGestorMetadatos() {\r\n  const gestor = new GestorMetadatos();\r\n\r\n  const archivos = [\r\n    "./documento.txt",\r\n    "./package.json",\r\n    "./src", // directorio\r\n  ];\r\n\r\n  for (const archivo of archivos) {\r\n    const metadatos = await gestor.obtenerMetadatos(archivo);\r\n\r\n    if (metadatos.error) {\r\n      console.log(`Error con ${archivo}:`, metadatos.error);\r\n    } else {\r\n      console.log(`\\nMetadatos de ${archivo}:`);\r\n      console.log(`  Tipo: ${metadatos.tipo}`);\r\n      console.log(`  Tama\xf1o: ${metadatos.tama\xf1oLegible}`);\r\n      console.log(`  Modificado: ${metadatos.modificado.toLocaleString()}`);\r\n      console.log(`  Permisos: ${metadatos.permisos}`);\r\n    }\r\n  }\r\n}\r\n\r\n// EJEMPLO 6: VERIFICACI\xd3N DE INTEGRIDAD DE ARCHIVOS\r\nasync function verificarIntegridad(ruta) {\r\n  try {\r\n    const stats = await fs.stat(ruta);\r\n\r\n    const verificaciones = {\r\n      existe: true,\r\n      esLegible: true, // Asumimos legible si podemos hacer stat\r\n      tama\xf1oValido: stats.size >= 0,\r\n      fechasConsistentes:\r\n        stats.birthtime <= stats.mtime && stats.mtime <= new Date(),\r\n      permisosValidos: (stats.mode & 0o777) <= 0o777,\r\n      inodoValido: stats.ino > 0,\r\n    };\r\n\r\n    const todasPasadas = Object.values(verificaciones).every((v) => v);\r\n\r\n    return {\r\n      integridad: todasPasadas ? "OK" : "PROBLEMA",\r\n      verificaciones: verificaciones,\r\n      detalles: stats,\r\n    };\r\n  } catch (error) {\r\n    return {\r\n      integridad: "ERROR",\r\n      error: error.message,\r\n    };\r\n  }\r\n}\r\n\r\n// EJEMPLO 7: ESTAD\xcdSTICAS DE USO DE ARCHIVOS\r\nasync function generarEstadisticas(directorio) {\r\n  try {\r\n    const elementos = await fs.readdir(directorio);\r\n    const estadisticas = {\r\n      totalArchivos: 0,\r\n      totalDirectorios: 0,\r\n      tama\xf1oTotal: 0,\r\n      archivosPorExtension: {},\r\n      archivosRecientes: [],\r\n      archivosGrandes: [],\r\n    };\r\n\r\n    for (const elemento of elementos) {\r\n      const rutaCompleta = `${directorio}/${elemento}`;\r\n\r\n      try {\r\n        const stats = await fs.stat(rutaCompleta);\r\n\r\n        if (stats.isFile()) {\r\n          estadisticas.totalArchivos++;\r\n          estadisticas.tama\xf1oTotal += stats.size;\r\n\r\n          // Agrupar por extensi\xf3n\r\n          const extension = elemento.split(".").pop() || "sin_extension";\r\n          estadisticas.archivosPorExtension[extension] =\r\n            (estadisticas.archivosPorExtension[extension] || 0) + 1;\r\n\r\n          // Archivos modificados en los \xfaltimos 7 d\xedas\r\n          const diasDesdeModificacion =\r\n            (new Date() - stats.mtime) / (1000 * 60 * 60 * 24);\r\n          if (diasDesdeModificacion <= 7) {\r\n            estadisticas.archivosRecientes.push({\r\n              nombre: elemento,\r\n              modificado: stats.mtime,\r\n              tama\xf1o: stats.size,\r\n            });\r\n          }\r\n\r\n          // Archivos mayores a 1MB\r\n          if (stats.size > 1024 * 1024) {\r\n            estadisticas.archivosGrandes.push({\r\n              nombre: elemento,\r\n              tama\xf1o: stats.size,\r\n              tama\xf1oLegible: (stats.size / (1024 * 1024)).toFixed(2) + " MB",\r\n            });\r\n          }\r\n        } else if (stats.isDirectory()) {\r\n          estadisticas.totalDirectorios++;\r\n        }\r\n      } catch (error) {\r\n        console.log(`Error procesando ${elemento}:`, error.message);\r\n      }\r\n    }\r\n\r\n    return estadisticas;\r\n  } catch (error) {\r\n    console.log(`Error accediendo al directorio ${directorio}:`, error.message);\r\n    return null;\r\n  }\r\n}\r\n\r\n// EJEMPLO 8: DIFERENCIA ENTRE FS.STAT() Y FS.LSTAT()\r\nasync function compararStatVsLstat(ruta) {\r\n  try {\r\n    // fs.stat() sigue enlaces simb\xf3licos y da info del archivo destino\r\n    const stats = await fs.stat(ruta);\r\n\r\n    // fs.lstat() da informaci\xf3n del enlace simb\xf3lico mismo\r\n    const lstats = await fs.lstat(ruta);\r\n\r\n    console.log("Comparaci\xf3n stat() vs lstat():");\r\n    console.log("stat() - Es enlace simb\xf3lico:", stats.isSymbolicLink());\r\n    console.log("lstat() - Es enlace simb\xf3lico:", lstats.isSymbolicLink());\r\n    console.log("stat() - Tama\xf1o:", stats.size);\r\n    console.log("lstat() - Tama\xf1o:", lstats.size);\r\n\r\n    // Si son diferentes, es un enlace simb\xf3lico\r\n    if (stats.ino !== lstats.ino) {\r\n      console.log("Este es un enlace simb\xf3lico que apunta a otro archivo");\r\n    }\r\n  } catch (error) {\r\n    console.log("Error en comparaci\xf3n:", error.message);\r\n  }\r\n}\r\n\r\n// EJECUCI\xd3N DE EJEMPLOS\r\nasync function ejecutarEjemplos() {\r\n  console.log("=== EJEMPLOS DE INFORMACI\xd3N DE ARCHIVOS ===");\r\n\r\n  // Ejemplo b\xe1sico\r\n  await obtenerInfoArchivo("./package.json");\r\n\r\n  // Ejemplos avanzados\r\n  const gestor = new GestorMetadatos();\r\n  const metadatos = await gestor.obtenerMetadatos("./package.json");\r\n  console.log("\\nMetadatos formateados:", metadatos);\r\n\r\n  const integridad = await verificarIntegridad("./package.json");\r\n  console.log("\\nVerificaci\xf3n de integridad:", integridad);\r\n\r\n  const estadisticas = await generarEstadisticas("./");\r\n  console.log("\\nEstad\xedsticas del directorio:", estadisticas);\r\n}\r\n\r\n// Descomentar para ejecutar\r\n// ejecutarEjemplos();\n'})}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"INFORMACI\xd3N PRINCIPAL DISPONIBLE EN EL OBJETO STATS:"})}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Tipo"}),":\xa0",(0,a.jsx)(n.code,{children:"isFile()"}),",\xa0",(0,a.jsx)(n.code,{children:"isDirectory()"}),",\xa0",(0,a.jsx)(n.code,{children:"isSymbolicLink()"})]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Tama\xf1o"}),":\xa0",(0,a.jsx)(n.code,{children:"size"}),"\xa0(en bytes)"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Fechas"}),":\xa0",(0,a.jsx)(n.code,{children:"birthtime"}),"\xa0(creaci\xf3n),\xa0",(0,a.jsx)(n.code,{children:"mtime"}),"\xa0(modificaci\xf3n),\xa0",(0,a.jsx)(n.code,{children:"atime"}),"\xa0(acceso),\xa0",(0,a.jsx)(n.code,{children:"ctime"}),"\xa0(cambio metadatos)"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Permisos"}),":\xa0",(0,a.jsx)(n.code,{children:"mode"}),"\xa0(permisos en formato octal)"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Propietario"}),":\xa0",(0,a.jsx)(n.code,{children:"uid"}),",\xa0",(0,a.jsx)(n.code,{children:"gid"}),"\xa0(usuario y grupo)"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Sistema de archivos"}),":\xa0",(0,a.jsx)(n.code,{children:"ino"}),"\xa0(inodo),\xa0",(0,a.jsx)(n.code,{children:"dev"}),"\xa0(dispositivo)"]}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"USOS COMUNES:"})}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Verificaci\xf3n de existencia y tipo de archivos"}),"\n",(0,a.jsx)(n.li,{children:"Monitoreo de cambios en archivos"}),"\n",(0,a.jsx)(n.li,{children:"Gesti\xf3n de permisos y seguridad"}),"\n",(0,a.jsx)(n.li,{children:"An\xe1lisis de uso de disco"}),"\n",(0,a.jsx)(n.li,{children:"Auditor\xeda de sistemas de archivos"}),"\n",(0,a.jsx)(n.li,{children:"Aplicaciones de backup y sincronizaci\xf3n"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:"Este c\xf3digo proporciona una base completa para trabajar con metadatos de archivos en Node.js, esencial para aplicaciones que necesitan informaci\xf3n detallada del sistema de archivos."}),"\n",(0,a.jsx)(n.h2,{id:"operaciones-con-directorios",children:"Operaciones con Directorios"}),"\n",(0,a.jsx)(n.h3,{id:"creaci\xf3n-de-directorios",children:"Creaci\xf3n de Directorios"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-jsx",children:'// Importar el m\xf3dulo de sistema de archivos con soporte para Promises\r\n// fs/promises proporciona m\xe9todos as\xedncronos basados en Promises\r\nimport fs from "fs/promises";\r\n\r\n// Funci\xf3n as\xedncrona para crear directorios\r\n// fs.mkdir() crea nuevos directorios en el sistema de archivos\r\nasync function crearDirectorios() {\r\n  try {\r\n    // Crear un directorio simple\r\n    // fs.mkdir() con un solo par\xe1metro crea un directorio en la ruta especificada\r\n    // Si el directorio ya existe, lanzar\xe1 un error\r\n    await fs.mkdir("./mi-directorio");\r\n    console.log("Directorio creado: ./mi-directorio");\r\n\r\n    // Crear directorios anidados (crea todos los directorios padres necesarios)\r\n    // Con la opci\xf3n recursive: true, fs.mkdir() crea toda la jerarqu\xeda de directorios\r\n    // Esto crea: ./carpeta-padre \u2192 ./carpeta-padre/carpeta-hija \u2192 ./carpeta-padre/carpeta-hija/subcarpeta\r\n    await fs.mkdir("./carpeta-padre/carpeta-hija/subcarpeta", {\r\n      recursive: true,\r\n    });\r\n    console.log("Directorios anidados creados exitosamente");\r\n  } catch (error) {\r\n    console.error("Error al crear directorios:", error.message);\r\n  }\r\n}\r\n\r\n// Ejecutar la funci\xf3n\r\ncrearDirectorios();\r\n\r\n// EJEMPLOS ADICIONALES Y EXPLICACIONES DETALLADAS:\r\n\r\n// EJEMPLO 1: CREAR DIRECTORIO CON PERMISOS ESPEC\xcdFICOS\r\nasync function crearDirectorioConPermisos() {\r\n  try {\r\n    // Crear directorio con permisos espec\xedficos usando mode\r\n    // 0o755 significa: propietario (lectura, escritura, ejecuci\xf3n), grupo y otros (lectura, ejecuci\xf3n)\r\n    // En formato string: rwxr-xr-x\r\n    await fs.mkdir("./directorio-con-permisos", {\r\n      mode: 0o755, // Permisos en formato octal\r\n    });\r\n    console.log("Directorio con permisos espec\xedficos creado");\r\n  } catch (error) {\r\n    console.error("Error al crear directorio con permisos:", error.message);\r\n  }\r\n}\r\n\r\n// EJEMPLO 2: VERIFICAR SI UN DIRECTORIO EXISTE ANTES DE CREARLO\r\nasync function crearDirectorioSiNoExiste(ruta) {\r\n  try {\r\n    // Primero verificar si el directorio ya existe\r\n    try {\r\n      await fs.access(ruta);\r\n      console.log(`El directorio ${ruta} ya existe`);\r\n      return false;\r\n    } catch (error) {\r\n      if (error.code === "ENOENT") {\r\n        // El directorio no existe, proceder a crearlo\r\n        await fs.mkdir(ruta, { recursive: true });\r\n        console.log(`Directorio ${ruta} creado exitosamente`);\r\n        return true;\r\n      } else {\r\n        // Otro tipo de error, relanzarlo\r\n        throw error;\r\n      }\r\n    }\r\n  } catch (error) {\r\n    console.error(\r\n      `Error al verificar/crear directorio ${ruta}:`,\r\n      error.message\r\n    );\r\n    return false;\r\n  }\r\n}\r\n\r\n// EJEMPLO 3: CREAR ESTRUCTURA COMPLEJA DE DIRECTORIOS\r\nasync function crearEstructuraCompleja() {\r\n  try {\r\n    const estructura = {\r\n      base: "./proyecto",\r\n      subdirectorios: [\r\n        "src/components",\r\n        "src/utils",\r\n        "public/images",\r\n        "public/css",\r\n        "public/js",\r\n        "docs/api",\r\n        "tests/unit",\r\n        "tests/integration",\r\n        "logs/application",\r\n        "logs/errors",\r\n        "temp/uploads",\r\n        "temp/cache",\r\n      ],\r\n    };\r\n\r\n    // Crear directorio base\r\n    await fs.mkdir(estructura.base, { recursive: true });\r\n    console.log(`Directorio base creado: ${estructura.base}`);\r\n\r\n    // Crear todos los subdirectorios\r\n    for (const subdir of estructura.subdirectorios) {\r\n      const rutaCompleta = `${estructura.base}/${subdir}`;\r\n      await fs.mkdir(rutaCompleta, { recursive: true });\r\n      console.log(`Subdirectorio creado: ${rutaCompleta}`);\r\n    }\r\n\r\n    console.log("Estructura de directorios completa creada");\r\n  } catch (error) {\r\n    console.error("Error creando estructura de directorios:", error.message);\r\n  }\r\n}\r\n\r\n// EJEMPLO 4: CREAR DIRECTORIOS TEMPORALES CON NOMBRES \xdaNICOS\r\nasync function crearDirectorioTemporal() {\r\n  try {\r\n    // Crear directorio temporal con timestamp para evitar colisiones\r\n    const timestamp = new Date().getTime();\r\n    const directorioTemporal = `./temp-${timestamp}`;\r\n\r\n    await fs.mkdir(directorioTemporal);\r\n    console.log(`Directorio temporal creado: ${directorioTemporal}`);\r\n\r\n    return directorioTemporal;\r\n  } catch (error) {\r\n    console.error("Error creando directorio temporal:", error.message);\r\n    return null;\r\n  }\r\n}\r\n\r\n// EJEMPLO 5: MANEJAR ERRORES ESPEC\xcdFICOS DE CREACI\xd3N DE DIRECTORIOS\r\nasync function crearDirectorioConManejoErrores(ruta) {\r\n  try {\r\n    await fs.mkdir(ruta, { recursive: true });\r\n    console.log(`Directorio ${ruta} creado exitosamente`);\r\n    return true;\r\n  } catch (error) {\r\n    // Manejar diferentes tipos de errores espec\xedficamente\r\n    switch (error.code) {\r\n      case "EEXIST":\r\n        console.log(`El directorio ${ruta} ya existe`);\r\n        break;\r\n      case "ENOENT":\r\n        console.log(\r\n          `Una parte de la ruta padre no existe (se necesita recursive: true)`\r\n        );\r\n        break;\r\n      case "EACCES":\r\n        console.log(`Permiso denegado para crear el directorio en ${ruta}`);\r\n        break;\r\n      case "ENOTDIR":\r\n        console.log(`Un componente de la ruta no es un directorio`);\r\n        break;\r\n      case "EROFS":\r\n        console.log(`El sistema de archivos es de solo lectura`);\r\n        break;\r\n      case "ENAMETOOLONG":\r\n        console.log(`El nombre del directorio es demasiado largo`);\r\n        break;\r\n      default:\r\n        console.log(`Error desconocido al crear directorio: ${error.message}`);\r\n    }\r\n    return false;\r\n  }\r\n}\r\n\r\n// EJEMPLO 6: CLASE PARA GESTI\xd3N DE DIRECTORIOS\r\nclass GestorDirectorios {\r\n  constructor(directorioBase = "./") {\r\n    this.directorioBase = directorioBase;\r\n  }\r\n\r\n  async crear(ruta, opciones = {}) {\r\n    try {\r\n      const rutaCompleta = `${this.directorioBase}/${ruta}`;\r\n      await fs.mkdir(rutaCompleta, {\r\n        recursive: true,\r\n        ...opciones,\r\n      });\r\n\r\n      return {\r\n        exito: true,\r\n        ruta: rutaCompleta,\r\n        mensaje: `Directorio ${rutaCompleta} creado exitosamente`,\r\n      };\r\n    } catch (error) {\r\n      return {\r\n        exito: false,\r\n        ruta: ruta,\r\n        error: error.message,\r\n        codigoError: error.code,\r\n      };\r\n    }\r\n  }\r\n\r\n  async crearEstructura(estructura) {\r\n    const resultados = [];\r\n\r\n    for (const ruta of estructura) {\r\n      const resultado = await this.crear(ruta);\r\n      resultados.push(resultado);\r\n    }\r\n\r\n    return resultados;\r\n  }\r\n\r\n  async crearDesdeConfiguracion(config) {\r\n    try {\r\n      // Configuraci\xf3n ejemplo:\r\n      // {\r\n      //   base: \'mi-proyecto\',\r\n      //   directorios: [\'src\', \'public\', \'tests\']\r\n      // }\r\n      const basePath = `${this.directorioBase}/${config.base}`;\r\n\r\n      // Crear directorio base\r\n      await fs.mkdir(basePath, { recursive: true });\r\n\r\n      // Crear subdirectorios\r\n      for (const subdir of config.directorios) {\r\n        const rutaCompleta = `${basePath}/${subdir}`;\r\n        await fs.mkdir(rutaCompleta, { recursive: true });\r\n      }\r\n\r\n      console.log(`Estructura creada en: ${basePath}`);\r\n      return true;\r\n    } catch (error) {\r\n      console.error("Error creando desde configuraci\xf3n:", error.message);\r\n      return false;\r\n    }\r\n  }\r\n}\r\n\r\n// EJEMPLO 7: USO DEL GESTOR DE DIRECTORIOS\r\nasync function usarGestorDirectorios() {\r\n  const gestor = new GestorDirectorios("./proyectos");\r\n\r\n  // Crear estructura de proyecto t\xedpica\r\n  const estructura = [\r\n    "mi-app/src/components",\r\n    "mi-app/src/utils",\r\n    "mi-app/public/images",\r\n    "mi-app/public/css",\r\n    "mi-app/public/js",\r\n    "mi-app/tests/unit",\r\n    "mi-app/tests/integration",\r\n    "mi-app/docs",\r\n  ];\r\n\r\n  const resultados = await gestor.crearEstructura(estructura);\r\n\r\n  for (const resultado of resultados) {\r\n    if (resultado.exito) {\r\n      console.log(`\u2705 ${resultado.mensaje}`);\r\n    } else {\r\n      console.log(`\u274c Error en ${resultado.ruta}: ${resultado.error}`);\r\n    }\r\n  }\r\n}\r\n\r\n// EJEMPLO 8: CREAR DIRECTORIO Y ARCHIVOS INICIALES\r\nasync function crearProyectoCompleto(nombreProyecto) {\r\n  try {\r\n    const estructura = {\r\n      base: nombreProyecto,\r\n      archivos: {\r\n        [`${nombreProyecto}/package.json`]: JSON.stringify(\r\n          {\r\n            name: nombreProyecto,\r\n            version: "1.0.0",\r\n            type: "module",\r\n          },\r\n          null,\r\n          2\r\n        ),\r\n        [`${nombreProyecto}/README.md`]: `# ${nombreProyecto}\\n\\nDescripci\xf3n del proyecto.`,\r\n        [`${nombreProyecto}/src/index.js`]: \'console.log("Hola Mundo");\',\r\n        [`${nombreProyecto}/.gitignore`]: "node_modules/\\n.env",\r\n      },\r\n    };\r\n\r\n    // Crear directorio base\r\n    await fs.mkdir(`${nombreProyecto}/src`, { recursive: true });\r\n    console.log(`Directorio base ${nombreProyecto} creado`);\r\n\r\n    // Crear archivos iniciales\r\n    for (const [rutaArchivo, contenido] of Object.entries(\r\n      estructura.archivos\r\n    )) {\r\n      await fs.writeFile(rutaArchivo, contenido);\r\n      console.log(`Archivo creado: ${rutaArchivo}`);\r\n    }\r\n\r\n    console.log(`Proyecto ${nombreProyecto} creado exitosamente`);\r\n  } catch (error) {\r\n    console.error("Error creando proyecto completo:", error.message);\r\n  }\r\n}\r\n\r\n// EJEMPLO 9: CREAR DIRECTORIOS CON VALIDACI\xd3N DE SEGURIDAD\r\nasync function crearDirectorioSeguro(ruta) {\r\n  try {\r\n    // Validar que la ruta no contenga patrones peligrosos\r\n    const patronesPeligrosos = ["../", "~/", "/etc/", "/bin/", "/usr/"];\r\n    const esSegura = !patronesPeligrosos.some((patron) =>\r\n      ruta.includes(patron)\r\n    );\r\n\r\n    if (!esSegura) {\r\n      throw new Error("Ruta no permitida por seguridad");\r\n    }\r\n\r\n    // Validar longitud m\xe1xima de ruta\r\n    if (ruta.length > 260) {\r\n      throw new Error("La ruta es demasiado larga");\r\n    }\r\n\r\n    // Validar caracteres no permitidos (depende del sistema operativo)\r\n    const caracteresNoPermitidos = ["<", ">", ":", \'"\', "|", "?", "*"];\r\n    const tieneCaracteresInvalidos = caracteresNoPermitidos.some((caracter) =>\r\n      ruta.includes(caracter)\r\n    );\r\n\r\n    if (tieneCaracteresInvalidos) {\r\n      throw new Error("La ruta contiene caracteres no permitidos");\r\n    }\r\n\r\n    await fs.mkdir(ruta, { recursive: true });\r\n    console.log(`Directorio seguro creado: ${ruta}`);\r\n  } catch (error) {\r\n    console.error("Error de seguridad:", error.message);\r\n  }\r\n}\r\n\r\n// EJEMPLO 10: CREAR DIRECTORIOS TEMPORALES PARA PROCESAMIENTO\r\nasync function crearEntornoTemporal() {\r\n  try {\r\n    const timestamp = new Date().getTime();\r\n    const directorioTemporal = `./procesamiento-${timestamp}`;\r\n\r\n    // Crear estructura temporal\r\n    await fs.mkdir(directorioTemporal, { recursive: true });\r\n    await fs.mkdir(`${directorioTemporal}/entrada`);\r\n    await fs.mkdir(`${directorioTemporal}/salida`);\r\n    await fs.mkdir(`${directorioTemporal}/temp`);\r\n\r\n    console.log(`Entorno temporal creado: ${directorioTemporal}`);\r\n\r\n    // Devolver informaci\xf3n del directorio temporal\r\n    return {\r\n      ruta: directorioTemporal,\r\n      entrada: `${directorioTemporal}/entrada`,\r\n      salida: `${directorioTemporal}/salida`,\r\n      temp: `${directorioTemporal}/temp`,\r\n    };\r\n  } catch (error) {\r\n    console.error("Error creando entorno temporal:", error.message);\r\n    return null;\r\n  }\r\n}\r\n\r\n// EJEMPLO 11: VERIFICAR Y CREAR DIRECTORIO CON ESTAD\xcdSTICAS\r\nasync function crearYVerificarDirectorio(ruta) {\r\n  try {\r\n    // Crear el directorio\r\n    await fs.mkdir(ruta, { recursive: true });\r\n\r\n    // Verificar que se cre\xf3 correctamente\r\n    const stats = await fs.stat(ruta);\r\n\r\n    if (stats.isDirectory()) {\r\n      console.log(`Directorio verificado: ${ruta}`);\r\n      console.log(`Creado: ${stats.birthtime.toLocaleString()}`);\r\n      console.log(`Permisos: ${stats.mode.toString(8)}`);\r\n      return true;\r\n    } else {\r\n      console.log(`Error: ${ruta} no es un directorio`);\r\n      return false;\r\n    }\r\n  } catch (error) {\r\n    console.error(`Error verificando directorio ${ruta}:`, error.message);\r\n    return false;\r\n  }\r\n}\r\n\r\n// EJECUCI\xd3N DE EJEMPLOS\r\nasync function ejecutarEjemplos() {\r\n  console.log("=== EJEMPLOS DE CREACI\xd3N DE DIRECTORIOS ===");\r\n\r\n  // Ejemplo b\xe1sico\r\n  await crearDirectorios();\r\n\r\n  // Ejemplos avanzados\r\n  await crearDirectorioConPermisos();\r\n  await crearDirectorioSiNoExiste("./directorio-verificado");\r\n  await crearEstructuraCompleja();\r\n\r\n  // Usar el gestor de directorios\r\n  await usarGestorDirectorios();\r\n\r\n  // Crear proyecto completo\r\n  await crearProyectoCompleto("mi-nuevo-proyecto");\r\n\r\n  // Crear directorio seguro\r\n  await crearDirectorioSeguro("./directorio-seguro");\r\n}\r\n\r\n// Descomentar para ejecutar\r\n// ejecutarEjemplos();\n'})}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"CARACTER\xcdSTICAS PRINCIPALES EXPLICADAS:"})}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:(0,a.jsx)(n.code,{children:"fs.mkdir(ruta)"})}),": Crea un directorio simple"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:(0,a.jsx)(n.code,{children:"fs.mkdir(ruta, { recursive: true })"})}),": Crea directorios anidados autom\xe1ticamente"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:(0,a.jsx)(n.code,{children:"fs.mkdir(ruta, { mode: permisos })"})}),": Crea directorio con permisos espec\xedficos"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Comportamiento"}),": Lanza error si el directorio ya existe (a menos que uses\xa0",(0,a.jsx)(n.code,{children:"recursive: true"}),"\xa0y no sea el directorio final)"]}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"PERMISOS COMUNES EN OCTAL:"})}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"0o755"}),"\xa0- Propietario: rwx, Grupo: r-x, Otros: r-x"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"0o777"}),"\xa0- Todos los permisos para todos"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"0o700"}),"\xa0- Solo propietario tiene permisos"]}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"USOS COMUNES:"})}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Inicializaci\xf3n de proyectos"}),"\n",(0,a.jsx)(n.li,{children:"Creaci\xf3n de estructuras de aplicaciones"}),"\n",(0,a.jsx)(n.li,{children:"Directorios temporales para procesamiento"}),"\n",(0,a.jsx)(n.li,{children:"Organizaci\xf3n de archivos por categor\xedas"}),"\n",(0,a.jsx)(n.li,{children:"Preparaci\xf3n de entornos de trabajo"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:"Este c\xf3digo proporciona una base completa para trabajar con directorios en Node.js, desde operaciones simples hasta gesti\xf3n avanzada de estructuras de directorios complejas."}),"\n",(0,a.jsx)(n.h3,{id:"listar-contenido-de-directorios",children:"Listar Contenido de Directorios"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-jsx",children:'// Importar el m\xf3dulo de sistema de archivos con soporte para Promises\r\n// fs/promises proporciona m\xe9todos as\xedncronos basados en Promises\r\nimport fs from "fs/promises";\r\n\r\n// Funci\xf3n as\xedncrona para listar el contenido de un directorio\r\n// fs.readdir() lee los nombres de los elementos en un directorio\r\nasync function listarDirectorio(ruta = "./") {\r\n  try {\r\n    // Leer todos los elementos del directorio\r\n    // fs.readdir() retorna un array con los nombres de los elementos del directorio\r\n    // Con la opci\xf3n withFileTypes: true, retorna objetos Dirent en lugar de strings\r\n    const elementos = await fs.readdir(ruta, {\r\n      withFileTypes: true, // Incluir informaci\xf3n del tipo de cada elemento\r\n    });\r\n\r\n    console.log(`Contenido de ${ruta}:`);\r\n\r\n    // Iterar sobre cada elemento del directorio\r\n    for (const elemento of elementos) {\r\n      // Determinar el tipo de elemento usando los m\xe9todos del objeto Dirent\r\n      // Dirent proporciona m\xe9todos para identificar el tipo de elemento del sistema de archivos\r\n      const tipo = elemento.isDirectory()\r\n        ? "[DIR]"\r\n        : elemento.isFile()\r\n        ? "[FILE]"\r\n        : elemento.isSymbolicLink()\r\n        ? "[LINK]"\r\n        : "[UNKNOWN]";\r\n\r\n      // Mostrar cada elemento con su tipo y nombre\r\n      console.log(`${tipo} ${elemento.name}`);\r\n    }\r\n\r\n    return elementos;\r\n  } catch (error) {\r\n    console.error("Error al listar directorio:", error.message);\r\n    return [];\r\n  }\r\n}\r\n\r\n// Ejecutar la funci\xf3n con el directorio actual\r\nlistarDirectorio("./");\r\n\r\n// EJEMPLOS ADICIONALES Y EXPLICACIONES DETALLADAS:\r\n\r\n// EJEMPLO 1: LISTAR DIRECTORIO SIN WITHFILETYPES\r\nasync function listarDirectorioSimple(ruta = "./") {\r\n  try {\r\n    // Sin withFileTypes: true, fs.readdir() retorna un array de strings\r\n    const nombres = await fs.readdir(ruta);\r\n\r\n    console.log(`Elementos en ${ruta}:`);\r\n    nombres.forEach((nombre) => {\r\n      console.log(` - ${nombre}`);\r\n    });\r\n\r\n    return nombres;\r\n  } catch (error) {\r\n    console.error("Error:", error.message);\r\n    return [];\r\n  }\r\n}\r\n\r\n// EJEMPLO 2: LISTAR CON INFORMACI\xd3N DETALLADA DE ARCHIVOS\r\nasync function listarConDetalles(ruta = "./") {\r\n  try {\r\n    const elementos = await fs.readdir(ruta, { withFileTypes: true });\r\n\r\n    console.log(`Contenido detallado de ${ruta}:`);\r\n    console.log("=".repeat(50));\r\n\r\n    for (const elemento of elementos) {\r\n      const rutaCompleta = `${ruta}/${elemento.name}`;\r\n\r\n      try {\r\n        const stats = await fs.stat(rutaCompleta);\r\n\r\n        console.log(\r\n          `${elemento.isDirectory() ? "[DIR]" : "[FILE]"} ${elemento.name}`\r\n        );\r\n        console.log(`  Tama\xf1o: ${stats.size} bytes`);\r\n        console.log(`  Modificado: ${stats.mtime.toLocaleString()}`);\r\n        console.log(`  Permisos: ${stats.mode.toString(8)}`);\r\n        console.log("---");\r\n      } catch (error) {\r\n        console.log(\r\n          `[ERROR] ${elemento.name} - No se pudo obtener informaci\xf3n`\r\n        );\r\n      }\r\n    }\r\n  } catch (error) {\r\n    console.error("Error al listar con detalles:", error.message);\r\n  }\r\n}\r\n\r\n// EJEMPLO 3: FILTRAR POR TIPO DE ELEMENTO\r\nasync function listarFiltrado(ruta = "./") {\r\n  try {\r\n    const elementos = await fs.readdir(ruta, { withFileTypes: true });\r\n\r\n    // Filtrar solo directorios\r\n    const directorios = elementos.filter((elemento) => elemento.isDirectory());\r\n    console.log("Directorios:");\r\n    directorios.forEach((dir) => console.log(` \ud83d\udcc1 ${dir.name}`));\r\n\r\n    // Filtrar solo archivos\r\n    const archivos = elementos.filter((elemento) => elemento.isFile());\r\n    console.log("\\nArchivos:");\r\n    archivos.forEach((archivo) => console.log(` \ud83d\udcc4 ${archivo.name}`));\r\n\r\n    // Filtrar enlaces simb\xf3licos\r\n    const enlaces = elementos.filter((elemento) => elemento.isSymbolicLink());\r\n    console.log("\\nEnlaces simb\xf3licos:");\r\n    enlaces.forEach((enlace) => console.log(` \ud83d\udd17 ${enlace.name}`));\r\n\r\n    return {\r\n      directorios: directorios,\r\n      archivos: archivos,\r\n      enlaces: enlaces,\r\n    };\r\n  } catch (error) {\r\n    console.error("Error al listar filtrado:", error.message);\r\n    return { directorios: [], archivos: [], enlaces: [] };\r\n  }\r\n}\r\n\r\n// EJEMPLO 4: LISTAR RECURSIVAMENTE (TODOS LOS SUBDIRECTORIOS)\r\nasync function listarRecursivo(ruta = "./", nivel = 0) {\r\n  try {\r\n    const elementos = await fs.readdir(ruta, { withFileTypes: true });\r\n\r\n    // Prefijo para indentaci\xf3n seg\xfan el nivel de profundidad\r\n    const indentacion = "  ".repeat(nivel);\r\n\r\n    for (const elemento of elementos) {\r\n      const rutaCompleta = `${ruta}/${elemento.name}`;\r\n\r\n      if (elemento.isDirectory()) {\r\n        console.log(`${indentacion}\ud83d\udcc1 ${elemento.name}/`);\r\n        // Llamada recursiva para listar el subdirectorio\r\n        await listarRecursivo(rutaCompleta, nivel + 1);\r\n      } else {\r\n        console.log(`${indentacion}\ud83d\udcc4 ${elemento.name}`);\r\n      }\r\n    }\r\n  } catch (error) {\r\n    console.error(`Error al listar ${ruta} recursivamente:`, error.message);\r\n  }\r\n}\r\n\r\n// EJEMPLO 5: LISTAR CON INFORMACI\xd3N DE TAMA\xd1O AGRUPADO\r\nasync function listarConEstadisticas(ruta = "./") {\r\n  try {\r\n    const elementos = await fs.readdir(ruta, { withFileTypes: true });\r\n\r\n    let totalArchivos = 0;\r\n    let totalDirectorios = 0;\r\n    let tama\xf1oTotal = 0;\r\n\r\n    console.log(`Estad\xedsticas de ${ruta}:`);\r\n    console.log("-".repeat(40));\r\n\r\n    for (const elemento of elementos) {\r\n      const rutaCompleta = `${ruta}/${elemento.name}`;\r\n\r\n      if (elemento.isDirectory()) {\r\n        totalDirectorios++;\r\n        console.log(`[DIR]  ${elemento.name}/`);\r\n      } else if (elemento.isFile()) {\r\n        totalArchivos++;\r\n        try {\r\n          const stats = await fs.stat(rutaCompleta);\r\n          tama\xf1oTotal += stats.size;\r\n          console.log(`[FILE] ${elemento.name} (${stats.size} bytes)`);\r\n        } catch (error) {\r\n          console.log(`[FILE] ${elemento.name} (error al obtener tama\xf1o)`);\r\n        }\r\n      }\r\n    }\r\n\r\n    console.log("-".repeat(40));\r\n    console.log(`Total directorios: ${totalDirectorios}`);\r\n    console.log(`Total archivos: ${totalArchivos}`);\r\n    console.log(`Tama\xf1o total: ${(tama\xf1oTotal / 1024).toFixed(2)} KB`);\r\n  } catch (error) {\r\n    console.error("Error al listar con estad\xedsticas:", error.message);\r\n  }\r\n}\r\n\r\n// EJEMPLO 6: CLASE PARA GESTI\xd3N DE LISTADO DE DIRECTORIOS\r\nclass GestorListado {\r\n  constructor(directorioBase = "./") {\r\n    this.directorioBase = directorioBase;\r\n  }\r\n\r\n  async listar(ruta = "", opciones = {}) {\r\n    try {\r\n      const rutaCompleta = `${this.directorioBase}/${ruta}`.replace(\r\n        /\\/\\//g,\r\n        "/"\r\n      );\r\n      const elementos = await fs.readdir(rutaCompleta, {\r\n        withFileTypes: true,\r\n        ...opciones,\r\n      });\r\n\r\n      return elementos.map((elemento) => ({\r\n        nombre: elemento.name,\r\n        ruta: `${rutaCompleta}/${elemento.name}`,\r\n        esDirectorio: elemento.isDirectory(),\r\n        esArchivo: elemento.isFile(),\r\n        esEnlace: elemento.isSymbolicLink(),\r\n        tipo: this.obtenerTipo(elemento),\r\n      }));\r\n    } catch (error) {\r\n      console.error(`Error listando ${ruta}:`, error.message);\r\n      return [];\r\n    }\r\n  }\r\n\r\n  obtenerTipo(elemento) {\r\n    if (elemento.isDirectory()) return "directorio";\r\n    if (elemento.isFile()) return "archivo";\r\n    if (elemento.isSymbolicLink()) return "enlace";\r\n    if (elemento.isBlockDevice()) return "dispositivo_bloque";\r\n    if (elemento.isCharacterDevice()) return "dispositivo_caracter";\r\n    if (elemento.isFIFO()) return "fifo";\r\n    if (elemento.isSocket()) return "socket";\r\n    return "desconocido";\r\n  }\r\n\r\n  async listarPorTipo(ruta = "") {\r\n    const elementos = await this.listar(ruta);\r\n\r\n    return {\r\n      directorios: elementos.filter((e) => e.esDirectorio),\r\n      archivos: elementos.filter((e) => e.esArchivo),\r\n      enlaces: elementos.filter((e) => e.esEnlace),\r\n    };\r\n  }\r\n\r\n  async buscarPorPatron(ruta = "", patron) {\r\n    const elementos = await this.listar(ruta);\r\n    const regex = new RegExp(patron, "i"); // B\xfasqueda case insensitive\r\n\r\n    return elementos.filter((elemento) => regex.test(elemento.nombre));\r\n  }\r\n}\r\n\r\n// EJEMPLO 7: USO DEL GESTOR DE LISTADO\r\nasync function usarGestorListado() {\r\n  const gestor = new GestorListado("./");\r\n\r\n  console.log("=== LISTADO COMPLETO ===");\r\n  const elementos = await gestor.listar();\r\n  elementos.forEach((elemento) => {\r\n    console.log(`${elemento.tipo.toUpperCase().padEnd(12)} ${elemento.nombre}`);\r\n  });\r\n\r\n  console.log("\\n=== LISTADO POR TIPO ===");\r\n  const porTipo = await gestor.listarPorTipo();\r\n\r\n  console.log("Directorios:");\r\n  porTipo.directorios.forEach((dir) => console.log(`  ${dir.nombre}`));\r\n\r\n  console.log("\\nArchivos:");\r\n  porTipo.archivos.forEach((archivo) => console.log(`  ${archivo.nombre}`));\r\n\r\n  console.log("\\n=== B\xdaSQUEDA POR PATR\xd3N ===");\r\n  const jsFiles = await gestor.buscarPorPatron("", "\\\\.js$");\r\n  console.log("Archivos JavaScript:");\r\n  jsFiles.forEach((archivo) => console.log(`  ${archivo.nombre}`));\r\n}\r\n\r\n// EJEMPLO 8: LISTAR CON ORDENAMIENTO\r\nasync function listarOrdenado(ruta = "./") {\r\n  try {\r\n    const elementos = await fs.readdir(ruta, { withFileTypes: true });\r\n\r\n    // Ordenar: directorios primero, luego archivos, alfab\xe9ticamente\r\n    elementos.sort((a, b) => {\r\n      // Directorios primero\r\n      if (a.isDirectory() && !b.isDirectory()) return -1;\r\n      if (!a.isDirectory() && b.isDirectory()) return 1;\r\n\r\n      // Luego orden alfab\xe9tico\r\n      return a.name.localeCompare(b.name);\r\n    });\r\n\r\n    console.log(`Contenido ordenado de ${ruta}:`);\r\n    elementos.forEach((elemento) => {\r\n      const tipo = elemento.isDirectory() ? "[DIR] " : "[FILE]";\r\n      console.log(`${tipo} ${elemento.name}`);\r\n    });\r\n\r\n    return elementos;\r\n  } catch (error) {\r\n    console.error("Error al listar ordenado:", error.message);\r\n    return [];\r\n  }\r\n}\r\n\r\n// EJEMPLO 9: LISTAR CON INFORMACI\xd3N DE EXTENSIONES\r\nasync function listarConExtensiones(ruta = "./") {\r\n  try {\r\n    const elementos = await fs.readdir(ruta, { withFileTypes: true });\r\n    const archivos = elementos.filter((elemento) => elemento.isFile());\r\n\r\n    // Agrupar por extensi\xf3n\r\n    const porExtension = {};\r\n\r\n    archivos.forEach((archivo) => {\r\n      const extension = archivo.name.split(".").pop() || "sin-extension";\r\n      if (!porExtension[extension]) {\r\n        porExtension[extension] = [];\r\n      }\r\n      porExtension[extension].push(archivo.name);\r\n    });\r\n\r\n    console.log("Archivos agrupados por extensi\xf3n:");\r\n    Object.keys(porExtension)\r\n      .sort()\r\n      .forEach((extension) => {\r\n        console.log(`\\n.${extension}:`);\r\n        porExtension[extension].forEach((archivo) => {\r\n          console.log(`  ${archivo}`);\r\n        });\r\n      });\r\n\r\n    return porExtension;\r\n  } catch (error) {\r\n    console.error("Error al listar por extensiones:", error.message);\r\n    return {};\r\n  }\r\n}\r\n\r\n// EJEMPLO 10: LISTAR CON L\xcdMITE Y PAGINACI\xd3N\r\nasync function listarPaginado(\r\n  ruta = "./",\r\n  pagina = 1,\r\n  elementosPorPagina = 10\r\n) {\r\n  try {\r\n    const todosElementos = await fs.readdir(ruta, { withFileTypes: true });\r\n\r\n    // Calcular \xedndices para la paginaci\xf3n\r\n    const inicio = (pagina - 1) * elementosPorPagina;\r\n    const fin = inicio + elementosPorPagina;\r\n    const elementosPagina = todosElementos.slice(inicio, fin);\r\n\r\n    console.log(\r\n      `P\xe1gina ${pagina} de ${Math.ceil(\r\n        todosElementos.length / elementosPorPagina\r\n      )}`\r\n    );\r\n    console.log(\r\n      `Elementos ${inicio + 1}-${Math.min(fin, todosElementos.length)} de ${\r\n        todosElementos.length\r\n      }`\r\n    );\r\n    console.log("-".repeat(40));\r\n\r\n    elementosPagina.forEach((elemento, index) => {\r\n      const numero = inicio + index + 1;\r\n      const tipo = elemento.isDirectory() ? "[DIR]" : "[FILE]";\r\n      console.log(`${numero.toString().padStart(3)}. ${tipo} ${elemento.name}`);\r\n    });\r\n\r\n    return {\r\n      elementos: elementosPagina,\r\n      paginaActual: pagina,\r\n      totalPaginas: Math.ceil(todosElementos.length / elementosPorPagina),\r\n      totalElementos: todosElementos.length,\r\n    };\r\n  } catch (error) {\r\n    console.error("Error en listado paginado:", error.message);\r\n    return {\r\n      elementos: [],\r\n      paginaActual: 1,\r\n      totalPaginas: 0,\r\n      totalElementos: 0,\r\n    };\r\n  }\r\n}\r\n\r\n// EJEMPLO 11: LISTAR OCULTOS Y MOSTRAR TODOS LOS DETALLES\r\nasync function listarCompleto(ruta = "./") {\r\n  try {\r\n    // En algunos sistemas, readdir no muestra archivos ocultos por defecto\r\n    const elementos = await fs.readdir(ruta, {\r\n      withFileTypes: true,\r\n    });\r\n\r\n    console.log(`Listado completo de ${ruta}:`);\r\n    console.log("=".repeat(60));\r\n\r\n    for (const elemento of elementos) {\r\n      const rutaCompleta = `${ruta}/${elemento.name}`;\r\n\r\n      try {\r\n        const stats = await fs.stat(rutaCompleta);\r\n\r\n        console.log(\r\n          `${elemento.isDirectory() ? "D" : "F"} ${elemento.name.padEnd(30)}`\r\n        );\r\n        console.log(`     Tama\xf1o: ${stats.size.toString().padStart(10)} bytes`);\r\n        console.log(`     Modificado: ${stats.mtime.toLocaleDateString()}`);\r\n        console.log(`     Permisos: ${stats.mode.toString(8)}`);\r\n        console.log("");\r\n      } catch (error) {\r\n        console.log(`? ${elemento.name} - Error al obtener detalles`);\r\n      }\r\n    }\r\n  } catch (error) {\r\n    console.error("Error en listado completo:", error.message);\r\n  }\r\n}\r\n\r\n// EJECUCI\xd3N DE EJEMPLOS\r\nasync function ejecutarEjemplos() {\r\n  console.log("=== EJEMPLOS DE LISTADO DE DIRECTORIOS ===");\r\n\r\n  // Ejemplo b\xe1sico\r\n  await listarDirectorio("./");\r\n\r\n  // Ejemplos avanzados\r\n  console.log("\\n--- Listado con detalles ---");\r\n  await listarConDetalles("./");\r\n\r\n  console.log("\\n--- Listado filtrado ---");\r\n  await listarFiltrado("./");\r\n\r\n  console.log("\\n--- Listado ordenado ---");\r\n  await listarOrdenado("./");\r\n\r\n  console.log("\\n--- Listado con extensiones ---");\r\n  await listarConExtensiones("./");\r\n\r\n  console.log("\\n--- Usando gestor de listado ---");\r\n  await usarGestorListado();\r\n\r\n  console.log("\\n--- Listado paginado ---");\r\n  await listarPaginado("./", 1, 5);\r\n}\r\n\r\n// Descomentar para ejecutar\r\n// ejecutarEjemplos();\n'})}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"CARACTER\xcdSTICAS PRINCIPALES EXPLICADAS:"})}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:(0,a.jsx)(n.code,{children:"fs.readdir(ruta)"})}),": Lista nombres de elementos como strings"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:(0,a.jsx)(n.code,{children:"fs.readdir(ruta, { withFileTypes: true })"})}),": Lista objetos Dirent con informaci\xf3n de tipo"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Objeto Dirent"}),": Proporciona m\xe9todos como\xa0",(0,a.jsx)(n.code,{children:"isDirectory()"}),",\xa0",(0,a.jsx)(n.code,{children:"isFile()"}),",\xa0",(0,a.jsx)(n.code,{children:"isSymbolicLink()"})]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Manejo de errores"}),": Captura errores de permisos, directorio no existente, etc."]}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"M\xc9TODOS DISPONIBLES EN DIRENT:"})}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"isDirectory()"}),"\xa0- Verifica si es directorio"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"isFile()"}),"\xa0- Verifica si es archivo regular"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"isSymbolicLink()"}),"\xa0- Verifica si es enlace simb\xf3lico"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"isBlockDevice()"}),"\xa0- Verifica si es dispositivo de bloque"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"isCharacterDevice()"}),"\xa0- Verifica si es dispositivo de car\xe1cter"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"isFIFO()"}),"\xa0- Verifica si es FIFO/pipe"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"isSocket()"}),"\xa0- Verifica si es socket"]}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"USOS COMUNES:"})}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Exploradores de archivos"}),"\n",(0,a.jsx)(n.li,{children:"Herramientas de administraci\xf3n de sistemas"}),"\n",(0,a.jsx)(n.li,{children:"Aplicaciones de backup y sincronizaci\xf3n"}),"\n",(0,a.jsx)(n.li,{children:"Utilidades de limpieza y organizaci\xf3n"}),"\n",(0,a.jsx)(n.li,{children:"Herramientas de desarrollo y build"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:"Este c\xf3digo proporciona una base completa para trabajar con listados de directorios en Node.js, desde operaciones simples hasta funcionalidades avanzadas como filtrado, ordenamiento y paginaci\xf3n."}),"\n",(0,a.jsx)(n.h3,{id:"eliminaci\xf3n-de-archivos-y-directorios",children:"Eliminaci\xf3n de Archivos y Directorios"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-jsx",children:'// Importar el m\xf3dulo de sistema de archivos con soporte para Promises\r\n// fs/promises proporciona m\xe9todos as\xedncronos basados en Promises\r\nimport fs from "fs/promises";\r\n\r\n// Funci\xf3n as\xedncrona para realizar operaciones de limpieza de archivos y directorios\r\n// ADVERTENCIA: Estas operaciones son destructivas y no se pueden deshacer\r\nasync function limpiarArchivos() {\r\n  try {\r\n    // Eliminar un archivo espec\xedfico\r\n    // fs.unlink() elimina archivos o enlaces simb\xf3licos\r\n    // No funciona con directorios - para directorios usar fs.rmdir() o fs.rm()\r\n    await fs.unlink("./archivo-temporal.txt");\r\n    console.log("Archivo eliminado: ./archivo-temporal.txt");\r\n\r\n    // Eliminar directorio vac\xedo\r\n    // fs.rmdir() solo funciona con directorios que est\xe1n vac\xedos\r\n    // Si el directorio contiene archivos u otros directorios, lanzar\xe1 un error\r\n    await fs.rmdir("./directorio-vacio");\r\n    console.log("Directorio vac\xedo eliminado: ./directorio-vacio");\r\n\r\n    // Eliminar directorio y todo su contenido de forma recursiva\r\n    // fs.rm() es la funci\xf3n m\xe1s moderna y vers\xe1til para eliminaci\xf3n\r\n    // Con recursive: true, elimina todo el contenido del directorio recursivamente\r\n    // Con force: true, no lanza error si el directorio no existe\r\n    await fs.rm("./directorio-con-contenido", {\r\n      recursive: true, // Eliminar recursivamente todo el contenido\r\n      force: true, // No lanzar error si el path no existe\r\n    });\r\n    console.log(\r\n      "Directorio y contenido eliminados: ./directorio-con-contenido"\r\n    );\r\n  } catch (error) {\r\n    console.error("Error en operaciones de limpieza:", error.message);\r\n  }\r\n}\r\n\r\n// Ejecutar la funci\xf3n (comentado por seguridad)\r\n// limpiarArchivos(); // Usar con precauci\xf3n - operaciones destructivas\r\n\r\n// EJEMPLOS ADICIONALES Y EXPLICACIONES DETALLADAS:\r\n\r\n// EJEMPLO 1: VERIFICAR ANTES DE ELIMINAR\r\nasync function eliminarConVerificacion(ruta) {\r\n  try {\r\n    // Verificar que el archivo/directorio existe antes de intentar eliminarlo\r\n    await fs.access(ruta);\r\n\r\n    // Obtener informaci\xf3n para determinar el tipo\r\n    const stats = await fs.stat(ruta);\r\n\r\n    if (stats.isFile()) {\r\n      await fs.unlink(ruta);\r\n      console.log(`Archivo eliminado: ${ruta}`);\r\n    } else if (stats.isDirectory()) {\r\n      // Para directorios, verificar si est\xe1 vac\xedo\r\n      const contenido = await fs.readdir(ruta);\r\n      if (contenido.length === 0) {\r\n        await fs.rmdir(ruta);\r\n        console.log(`Directorio vac\xedo eliminado: ${ruta}`);\r\n      } else {\r\n        console.log(\r\n          `Directorio no vac\xedo: ${ruta} (contiene ${contenido.length} elementos)`\r\n        );\r\n        // Podr\xeda usar fs.rm() con recursive: true aqu\xed\r\n      }\r\n    }\r\n  } catch (error) {\r\n    if (error.code === "ENOENT") {\r\n      console.log(`El elemento ${ruta} no existe`);\r\n    } else {\r\n      console.error(`Error al eliminar ${ruta}:`, error.message);\r\n    }\r\n  }\r\n}\r\n\r\n// EJEMPLO 2: ELIMINACI\xd3N SEGURA CON M\xdaLTIPLES OPCIONES\r\nasync function eliminarSeguro(ruta, opciones = {}) {\r\n  const config = {\r\n    verificarExistencia: true,\r\n    forzarEliminacion: false,\r\n    maxIntentos: 3,\r\n    ...opciones,\r\n  };\r\n\r\n  let intentos = 0;\r\n\r\n  while (intentos < config.maxIntentos) {\r\n    try {\r\n      if (config.verificarExistencia) {\r\n        try {\r\n          await fs.access(ruta);\r\n        } catch (error) {\r\n          if (error.code === "ENOENT") {\r\n            console.log(`El elemento ${ruta} no existe`);\r\n            return true; // Considerado \xe9xito - ya no existe\r\n          }\r\n          throw error;\r\n        }\r\n      }\r\n\r\n      // Intentar eliminar con fs.rm() (m\xe1s moderno y vers\xe1til)\r\n      await fs.rm(ruta, {\r\n        recursive: true,\r\n        force: config.forzarEliminacion,\r\n      });\r\n\r\n      console.log(`Eliminado exitosamente: ${ruta}`);\r\n      return true;\r\n    } catch (error) {\r\n      intentos++;\r\n      console.log(`Intento ${intentos} fallado para ${ruta}: ${error.message}`);\r\n\r\n      if (intentos >= config.maxIntentos) {\r\n        console.error(\r\n          `No se pudo eliminar ${ruta} despu\xe9s de ${config.maxIntentos} intentos`\r\n        );\r\n        return false;\r\n      }\r\n\r\n      // Esperar antes de reintentar (backoff exponencial)\r\n      await new Promise((resolve) => setTimeout(resolve, 1000 * intentos));\r\n    }\r\n  }\r\n}\r\n\r\n// EJEMPLO 3: ELIMINAR M\xdaLTIPLES ARCHIVOS POR PATR\xd3N\r\nasync function eliminarPorPatron(directorio, patron) {\r\n  try {\r\n    const elementos = await fs.readdir(directorio, { withFileTypes: true });\r\n    const regex = new RegExp(patron);\r\n\r\n    const eliminaciones = [];\r\n\r\n    for (const elemento of elementos) {\r\n      if (elemento.isFile() && regex.test(elemento.name)) {\r\n        const rutaCompleta = `${directorio}/${elemento.name}`;\r\n        eliminaciones.push(\r\n          fs\r\n            .unlink(rutaCompleta)\r\n            .then(() => {\r\n              console.log(`Eliminado: ${elemento.name}`);\r\n              return { exito: true, archivo: elemento.name };\r\n            })\r\n            .catch((error) => {\r\n              console.error(\r\n                `Error eliminando ${elemento.name}:`,\r\n                error.message\r\n              );\r\n              return {\r\n                exito: false,\r\n                archivo: elemento.name,\r\n                error: error.message,\r\n              };\r\n            })\r\n        );\r\n      }\r\n    }\r\n\r\n    const resultados = await Promise.all(eliminaciones);\r\n    const exitosos = resultados.filter((r) => r.exito).length;\r\n\r\n    console.log(\r\n      `Eliminaci\xf3n completada: ${exitosos}/${resultados.length} archivos eliminados`\r\n    );\r\n    return resultados;\r\n  } catch (error) {\r\n    console.error("Error en eliminaci\xf3n por patr\xf3n:", error.message);\r\n    return [];\r\n  }\r\n}\r\n\r\n// EJEMPLO 4: LIMPIAR DIRECTORIO TEMPORAL\r\nasync function limpiarDirectorioTemporal(directorio) {\r\n  try {\r\n    // Verificar que el directorio existe\r\n    await fs.access(directorio);\r\n\r\n    // Leer todo el contenido\r\n    const elementos = await fs.readdir(directorio, { withFileTypes: true });\r\n\r\n    console.log(`Limpiando directorio temporal: ${directorio}`);\r\n    console.log(`Encontrados ${elementos.length} elementos`);\r\n\r\n    for (const elemento of elementos) {\r\n      const rutaCompleta = `${directorio}/${elemento.name}`;\r\n\r\n      try {\r\n        if (elemento.isFile()) {\r\n          await fs.unlink(rutaCompleta);\r\n          console.log(`  Archivo eliminado: ${elemento.name}`);\r\n        } else if (elemento.isDirectory()) {\r\n          await fs.rm(rutaCompleta, { recursive: true, force: true });\r\n          console.log(`  Directorio eliminado: ${elemento.name}/`);\r\n        }\r\n      } catch (error) {\r\n        console.error(`  Error eliminando ${elemento.name}:`, error.message);\r\n      }\r\n    }\r\n\r\n    console.log("Limpieza de directorio temporal completada");\r\n  } catch (error) {\r\n    if (error.code === "ENOENT") {\r\n      console.log(`El directorio temporal ${directorio} no existe`);\r\n    } else {\r\n      console.error("Error limpiando directorio temporal:", error.message);\r\n    }\r\n  }\r\n}\r\n\r\n// EJEMPLO 5: CLASE PARA GESTI\xd3N SEGURA DE ELIMINACIONES\r\nclass GestorEliminacion {\r\n  constructor() {\r\n    this.registroEliminados = [];\r\n  }\r\n\r\n  async eliminar(ruta, opciones = {}) {\r\n    const config = {\r\n      recursive: true,\r\n      force: false,\r\n      registrar: true,\r\n      ...opciones,\r\n    };\r\n\r\n    try {\r\n      // Obtener informaci\xf3n antes de eliminar (para registro)\r\n      let infoPrevia = null;\r\n      if (config.registrar) {\r\n        try {\r\n          const stats = await fs.stat(ruta);\r\n          infoPrevia = {\r\n            ruta: ruta,\r\n            esDirectorio: stats.isDirectory(),\r\n            esArchivo: stats.isFile(),\r\n            tama\xf1o: stats.size,\r\n            modificado: stats.mtime,\r\n          };\r\n        } catch (error) {\r\n          // Si no podemos obtener stats, continuar igual\r\n        }\r\n      }\r\n\r\n      // Realizar la eliminaci\xf3n\r\n      await fs.rm(ruta, {\r\n        recursive: config.recursive,\r\n        force: config.force,\r\n      });\r\n\r\n      // Registrar la eliminaci\xf3n exitosa\r\n      if (config.registrar && infoPrevia) {\r\n        this.registroEliminados.push({\r\n          ...infoPrevia,\r\n          fechaEliminacion: new Date(),\r\n          exito: true,\r\n        });\r\n      }\r\n\r\n      console.log(`\u2705 Eliminado: ${ruta}`);\r\n      return { exito: true, ruta: ruta };\r\n    } catch (error) {\r\n      console.error(`\u274c Error eliminando ${ruta}:`, error.message);\r\n\r\n      if (config.registrar) {\r\n        this.registroEliminados.push({\r\n          ruta: ruta,\r\n          fechaIntento: new Date(),\r\n          exito: false,\r\n          error: error.message,\r\n        });\r\n      }\r\n\r\n      return {\r\n        exito: false,\r\n        ruta: ruta,\r\n        error: error.message,\r\n        codigoError: error.code,\r\n      };\r\n    }\r\n  }\r\n\r\n  async eliminarMultiples(rutas, opciones = {}) {\r\n    const resultados = [];\r\n\r\n    for (const ruta of rutas) {\r\n      const resultado = await this.eliminar(ruta, opciones);\r\n      resultados.push(resultado);\r\n    }\r\n\r\n    return resultados;\r\n  }\r\n\r\n  obtenerRegistro() {\r\n    return this.registroEliminados;\r\n  }\r\n\r\n  limpiarRegistro() {\r\n    const count = this.registroEliminados.length;\r\n    this.registroEliminados = [];\r\n    return count;\r\n  }\r\n}\r\n\r\n// EJEMPLO 6: USO DEL GESTOR DE ELIMINACI\xd3N\r\nasync function usarGestorEliminacion() {\r\n  const gestor = new GestorEliminacion();\r\n\r\n  const elementosAEliminar = [\r\n    "./archivo-temp-1.txt",\r\n    "./archivo-temp-2.txt",\r\n    "./directorio-temp",\r\n  ];\r\n\r\n  console.log("Iniciando eliminaci\xf3n de elementos...");\r\n  const resultados = await gestor.eliminarMultiples(elementosAEliminar, {\r\n    force: true,\r\n    registrar: true,\r\n  });\r\n\r\n  const exitosos = resultados.filter((r) => r.exito).length;\r\n  console.log(\r\n    `Proceso completado: ${exitosos}/${resultados.length} eliminaciones exitosas`\r\n  );\r\n\r\n  // Mostrar registro\r\n  const registro = gestor.obtenerRegistro();\r\n  console.log("\\nRegistro de eliminaciones:");\r\n  registro.forEach((item, index) => {\r\n    console.log(\r\n      `${index + 1}. ${item.ruta} - ${item.exito ? "\xc9XITO" : "FALLIDO"}`\r\n    );\r\n  });\r\n}\r\n\r\n// EJEMPLO 7: ELIMINAR ARCHIVOS ANTIGUOS\r\nasync function eliminarArchivosAntiguos(directorio, diasLimite = 30) {\r\n  try {\r\n    const elementos = await fs.readdir(directorio, { withFileTypes: true });\r\n    const fechaLimite = new Date();\r\n    fechaLimite.setDate(fechaLimite.getDate() - diasLimite);\r\n\r\n    console.log(\r\n      `Eliminando archivos m\xe1s antiguos que: ${fechaLimite.toLocaleDateString()}`\r\n    );\r\n\r\n    for (const elemento of elementos) {\r\n      if (elemento.isFile()) {\r\n        const rutaCompleta = `${directorio}/${elemento.name}`;\r\n        const stats = await fs.stat(rutaCompleta);\r\n\r\n        if (stats.mtime < fechaLimite) {\r\n          await fs.unlink(rutaCompleta);\r\n          console.log(\r\n            `Eliminado archivo antiguo: ${\r\n              elemento.name\r\n            } (${stats.mtime.toLocaleDateString()})`\r\n          );\r\n        }\r\n      }\r\n    }\r\n  } catch (error) {\r\n    console.error("Error eliminando archivos antiguos:", error.message);\r\n  }\r\n}\r\n\r\n// EJEMPLO 8: ELIMINACI\xd3N CON VALIDACI\xd3N DE SEGURIDAD\r\nasync function eliminarConValidacionSegura(ruta, exclusiones = []) {\r\n  // Lista de rutas cr\xedticas que NUNCA deber\xedan eliminarse\r\n  const rutasProtegidas = [\r\n    "/",\r\n    "/etc",\r\n    "/bin",\r\n    "/usr",\r\n    "/var",\r\n    "/home",\r\n    "/System",\r\n    "/Windows",\r\n    "C:\\\\",\r\n    "C:/Windows",\r\n  ];\r\n\r\n  // Convertir ruta a absoluta para comparaci\xf3n\r\n  const rutaAbsoluta = await fs.realpath(ruta);\r\n\r\n  // Verificar que no sea una ruta protegida\r\n  const esRutaProtegida = rutasProtegidas.some((protegida) =>\r\n    rutaAbsoluta.startsWith(protegida)\r\n  );\r\n\r\n  if (esRutaProtegida) {\r\n    throw new Error(\r\n      `OPERACI\xd3N BLOQUEADA: La ruta ${rutaAbsoluta} est\xe1 protegida`\r\n    );\r\n  }\r\n\r\n  // Verificar exclusiones personalizadas\r\n  const estaExcluida = exclusiones.some((exclusion) =>\r\n    rutaAbsoluta.includes(exclusion)\r\n  );\r\n\r\n  if (estaExcluida) {\r\n    throw new Error(\r\n      `OPERACI\xd3N BLOQUEADA: La ruta ${ruta} est\xe1 en la lista de exclusiones`\r\n    );\r\n  }\r\n\r\n  // Si pasa todas las validaciones, proceder con eliminaci\xf3n\r\n  await fs.rm(ruta, { recursive: true, force: true });\r\n  console.log(`Eliminaci\xf3n segura completada: ${ruta}`);\r\n}\r\n\r\n// EJEMPLO 9: LIMPIAR CACHE DE APLICACI\xd3N\r\nasync function limpiarCacheAplicacion() {\r\n  const carpetasCache = [\r\n    "./node_modules/.cache",\r\n    "./.cache",\r\n    "./temp",\r\n    "./dist", // Directorio de build\r\n    "./coverage", // Directorio de reports de tests\r\n  ];\r\n\r\n  console.log("Iniciando limpieza de cache de aplicaci\xf3n...");\r\n\r\n  for (const carpeta of carpetasCache) {\r\n    try {\r\n      await fs.access(carpeta);\r\n      await fs.rm(carpeta, { recursive: true, force: true });\r\n      console.log(`\u2705 Cache limpiada: ${carpeta}`);\r\n    } catch (error) {\r\n      if (error.code === "ENOENT") {\r\n        console.log(`\u26a0\ufe0f  Cache no encontrada: ${carpeta}`);\r\n      } else {\r\n        console.error(`\u274c Error limpiando ${carpeta}:`, error.message);\r\n      }\r\n    }\r\n  }\r\n\r\n  console.log("Limpieza de cache completada");\r\n}\r\n\r\n// EJEMPLO 10: ELIMINAR CON CONFIRMACI\xd3N INTERACTIVA (SIMULADA)\r\nasync function eliminarConConfirmacion(ruta) {\r\n  // En una aplicaci\xf3n real, esto interactuar\xeda con la consola\r\n  // Para este ejemplo, simulamos la confirmaci\xf3n\r\n\r\n  const confirmacionSimulada = true; // En realidad esto vendr\xeda de input del usuario\r\n\r\n  if (!confirmacionSimulada) {\r\n    console.log("Eliminaci\xf3n cancelada por el usuario");\r\n    return false;\r\n  }\r\n\r\n  try {\r\n    // Mostrar informaci\xf3n de lo que se va a eliminar\r\n    const stats = await fs.stat(ruta);\r\n    const tipo = stats.isDirectory() ? "directorio" : "archivo";\r\n    const tama\xf1o = stats.isFile() ? ` (${stats.size} bytes)` : "";\r\n\r\n    console.log(`Confirmando eliminaci\xf3n de ${tipo}: ${ruta}${tama\xf1o}`);\r\n\r\n    // Aqu\xed ir\xeda la confirmaci\xf3n real del usuario\r\n    // const confirmacion = await preguntaUsuario(\'\xbfContinuar? (s/n): \');\r\n\r\n    // Simulamos que el usuario confirma\r\n    await fs.rm(ruta, { recursive: true, force: true });\r\n    console.log("\u2705 Eliminaci\xf3n confirmada y ejecutada");\r\n    return true;\r\n  } catch (error) {\r\n    console.error("Error en eliminaci\xf3n con confirmaci\xf3n:", error.message);\r\n    return false;\r\n  }\r\n}\r\n\r\n// EJECUCI\xd3N DE EJEMPLOS (COMENTADO POR SEGURIDAD)\r\nasync function ejecutarEjemplos() {\r\n  console.log("=== EJEMPLOS DE ELIMINACI\xd3N DE ARCHIVOS ===");\r\n\r\n  // NOTA: Estos ejemplos est\xe1n comentados porque son operaciones destructivas\r\n  // Descomentar solo para pruebas en entornos controlados\r\n\r\n  /*\r\n    // Ejemplo b\xe1sico (crear archivos temporales primero para prueba)\r\n    await fs.writeFile(\'./archivo-temporal.txt\', \'contenido temporal\');\r\n    await fs.mkdir(\'./directorio-vacio\', { recursive: true });\r\n    await fs.mkdir(\'./directorio-con-contenido/subdir\', { recursive: true });\r\n    await fs.writeFile(\'./directorio-con-contenido/archivo.txt\', \'contenido\');\r\n    \r\n    await limpiarArchivos();\r\n    \r\n    // Ejemplos avanzados\r\n    await eliminarConVerificacion(\'./archivo-prueba.txt\');\r\n    await eliminarPorPatron(\'./\', \'^temp-\');\r\n    await usarGestorEliminacion();\r\n    */\r\n\r\n  console.log("Ejemplos de eliminaci\xf3n (comentados por seguridad)");\r\n}\r\n\r\n// Descomentar para ejecutar (SOLO EN ENTORNOS DE PRUEBA)\r\n// ejecutarEjemplos();\n'})}),"\n",(0,a.jsx)(n.h2,{id:"operaciones-de-copia-y-movimiento",children:"Operaciones de Copia y Movimiento"}),"\n",(0,a.jsx)(n.h3,{id:"copiar-archivos",children:"Copiar Archivos"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-jsx",children:'// Importar el m\xf3dulo de sistema de archivos con soporte para Promises\r\n// fs/promises proporciona m\xe9todos as\xedncronos basados en Promises\r\nimport fs from "fs/promises";\r\n\r\n// Funci\xf3n as\xedncrona para copiar un archivo de una ubicaci\xf3n a otra\r\n// fs.copyFile() copia el contenido de un archivo a otro archivo\r\nasync function copiarArchivo(origen, destino) {\r\n  try {\r\n    // Copiar archivo de origen a destino\r\n    // fs.copyFile() copia todo el contenido del archivo origen al archivo destino\r\n    // Si el archivo destino ya existe, ser\xe1 sobrescrito completamente\r\n    await fs.copyFile(origen, destino);\r\n    console.log(`Archivo copiado de ${origen} a ${destino}`);\r\n  } catch (error) {\r\n    console.error("Error al copiar archivo:", error.message);\r\n  }\r\n}\r\n\r\n// Ejecutar la funci\xf3n con archivos de ejemplo\r\ncopiarArchivo("./original.txt", "./copia.txt");\r\n\r\n// EJEMPLOS ADICIONALES Y EXPLICACIONES DETALLADAS:\r\n\r\n// EJEMPLO 1: COPIAR CON MODOS DE COPIADO ESPEC\xcdFICOS\r\nasync function copiarArchivoConModo(origen, destino, modo) {\r\n  try {\r\n    // fs.copyFile() acepta un tercer par\xe1metro opcional que especifica el modo de copiado\r\n    // Los modos disponibles son constantes del m\xf3dulo fs:\r\n    // - fs.constants.COPYFILE_EXCL: La operaci\xf3n falla si el archivo destino ya existe\r\n    // - fs.constants.COPYFILE_FICLONE: El archivo se copia usando copy-on-write (si la plataforma lo soporta)\r\n    // - fs.constants.COPYFILE_FICLONE_FORCE: El archivo se copia usando copy-on-write y falla si no est\xe1 soportado\r\n\r\n    await fs.copyFile(origen, destino, modo);\r\n    console.log(`Archivo copiado con modo espec\xedfico: ${origen} -> ${destino}`);\r\n  } catch (error) {\r\n    console.error("Error al copiar con modo:", error.message);\r\n  }\r\n}\r\n\r\n// EJEMPLO 2: COPIAR CON VERIFICACI\xd3N DE EXISTENCIA\r\nasync function copiarConVerificacion(origen, destino) {\r\n  try {\r\n    // Verificar que el archivo origen existe\r\n    await fs.access(origen);\r\n    console.log(`Archivo origen verificado: ${origen}`);\r\n\r\n    // Verificar si el archivo destino ya existe\r\n    try {\r\n      await fs.access(destino);\r\n      console.log(\r\n        `Advertencia: El archivo destino ${destino} ya existe y ser\xe1 sobrescrito`\r\n      );\r\n    } catch (error) {\r\n      if (error.code === "ENOENT") {\r\n        console.log(`Archivo destino no existe, se crear\xe1: ${destino}`);\r\n      } else {\r\n        throw error; // Relanzar otros errores\r\n      }\r\n    }\r\n\r\n    // Realizar la copia\r\n    await fs.copyFile(origen, destino);\r\n    console.log(`Copia completada: ${origen} -> ${destino}`);\r\n\r\n    // Verificar que la copia fue exitosa\r\n    const statsOrigen = await fs.stat(origen);\r\n    const statsDestino = await fs.stat(destino);\r\n\r\n    if (statsOrigen.size === statsDestino.size) {\r\n      console.log("\u2705 Verificaci\xf3n: Archivos tienen el mismo tama\xf1o");\r\n    } else {\r\n      console.log("\u26a0\ufe0f  Advertencia: Los archivos tienen tama\xf1os diferentes");\r\n    }\r\n  } catch (error) {\r\n    console.error("Error en copia con verificaci\xf3n:", error.message);\r\n  }\r\n}\r\n\r\n// EJEMPLO 3: COPIAR M\xdaLTIPLES ARCHIVOS\r\nasync function copiarMultiplesArchivos(archivos) {\r\n  try {\r\n    // archivos es un array de objetos { origen, destino }\r\n    const resultados = [];\r\n\r\n    for (const archivo of archivos) {\r\n      try {\r\n        await fs.copyFile(archivo.origen, archivo.destino);\r\n        console.log(`\u2705 Copiado: ${archivo.origen} -> ${archivo.destino}`);\r\n        resultados.push({\r\n          exito: true,\r\n          origen: archivo.origen,\r\n          destino: archivo.destino,\r\n        });\r\n      } catch (error) {\r\n        console.error(`\u274c Error copiando ${archivo.origen}:`, error.message);\r\n        resultados.push({\r\n          exito: false,\r\n          origen: archivo.origen,\r\n          destino: archivo.destino,\r\n          error: error.message,\r\n        });\r\n      }\r\n    }\r\n\r\n    const exitosos = resultados.filter((r) => r.exito).length;\r\n    console.log(`Resumen: ${exitosos}/${resultados.length} copias exitosas`);\r\n\r\n    return resultados;\r\n  } catch (error) {\r\n    console.error("Error en copia m\xfaltiple:", error.message);\r\n    return [];\r\n  }\r\n}\r\n\r\n// EJEMPLO 4: COPIAR CON CREACI\xd3N DE DIRECTORIOS DESTINO\r\nasync function copiarConDirectorios(origen, destino) {\r\n  try {\r\n    // Extraer el directorio destino del path completo\r\n    const path = await import("path");\r\n    const directorioDestino = path.dirname(destino);\r\n\r\n    // Verificar/Crear el directorio destino\r\n    try {\r\n      await fs.access(directorioDestino);\r\n    } catch (error) {\r\n      if (error.code === "ENOENT") {\r\n        console.log(`Creando directorio destino: ${directorioDestino}`);\r\n        await fs.mkdir(directorioDestino, { recursive: true });\r\n      } else {\r\n        throw error;\r\n      }\r\n    }\r\n\r\n    // Realizar la copia\r\n    await fs.copyFile(origen, destino);\r\n    console.log(`Archivo copiado con directorios: ${origen} -> ${destino}`);\r\n  } catch (error) {\r\n    console.error("Error copiando con directorios:", error.message);\r\n  }\r\n}\r\n\r\n// EJEMPLO 5: COPIAR CON MODO EXCLUSIVO (NO SOBRESCRIBIR)\r\nasync function copiarSinSobrescribir(origen, destino) {\r\n  try {\r\n    // COPYFILE_EXCL hace que la operaci\xf3n falle si el archivo destino ya existe\r\n    await fs.copyFile(origen, destino, fs.constants.COPYFILE_EXCL);\r\n    console.log(\r\n      `\u2705 Archivo copiado (sin sobrescribir): ${origen} -> ${destino}`\r\n    );\r\n  } catch (error) {\r\n    if (error.code === "EEXIST") {\r\n      console.log(\r\n        `\u26a0\ufe0f  El archivo destino ${destino} ya existe. No se sobrescribi\xf3.`\r\n      );\r\n    } else {\r\n      console.error("Error en copia exclusiva:", error.message);\r\n    }\r\n  }\r\n}\r\n\r\n// EJEMPLO 6: CLASE PARA GESTI\xd3N DE COPIAS\r\nclass GestorCopias {\r\n  constructor() {\r\n    this.registroCopias = [];\r\n  }\r\n\r\n  async copiar(origen, destino, opciones = {}) {\r\n    const config = {\r\n      sobrescribir: true,\r\n      crearDirectorios: true,\r\n      verificarIntegridad: false,\r\n      ...opciones,\r\n    };\r\n\r\n    try {\r\n      // Verificar archivo origen\r\n      const statsOrigen = await fs.stat(origen);\r\n      if (!statsOrigen.isFile()) {\r\n        throw new Error("El origen no es un archivo regular");\r\n      }\r\n\r\n      // Manejar directorios destino\r\n      if (config.crearDirectorios) {\r\n        const path = await import("path");\r\n        const directorioDestino = path.dirname(destino);\r\n        try {\r\n          await fs.access(directorioDestino);\r\n        } catch (error) {\r\n          if (error.code === "ENOENT") {\r\n            await fs.mkdir(directorioDestino, { recursive: true });\r\n          } else {\r\n            throw error;\r\n          }\r\n        }\r\n      }\r\n\r\n      // Configurar modo de copia\r\n      let modo = 0;\r\n      if (!config.sobrescribir) {\r\n        modo = fs.constants.COPYFILE_EXCL;\r\n      }\r\n\r\n      // Realizar la copia\r\n      await fs.copyFile(origen, destino, modo);\r\n\r\n      // Verificar integridad si se solicita\r\n      if (config.verificarIntegridad) {\r\n        const statsDestino = await fs.stat(destino);\r\n        if (statsOrigen.size !== statsDestino.size) {\r\n          throw new Error(\r\n            "La verificaci\xf3n de integridad fall\xf3: tama\xf1os diferentes"\r\n          );\r\n        }\r\n      }\r\n\r\n      // Registrar la copia exitosa\r\n      const registro = {\r\n        origen: origen,\r\n        destino: destino,\r\n        fecha: new Date(),\r\n        tama\xf1o: statsOrigen.size,\r\n        exito: true,\r\n      };\r\n\r\n      this.registroCopias.push(registro);\r\n      console.log(`\u2705 Copia exitosa: ${origen} -> ${destino}`);\r\n\r\n      return registro;\r\n    } catch (error) {\r\n      const registroError = {\r\n        origen: origen,\r\n        destino: destino,\r\n        fecha: new Date(),\r\n        exito: false,\r\n        error: error.message,\r\n      };\r\n\r\n      this.registroCopias.push(registroError);\r\n      console.error(`\u274c Error copiando ${origen}:`, error.message);\r\n\r\n      return registroError;\r\n    }\r\n  }\r\n\r\n  async copiarLote(archivos, opciones = {}) {\r\n    const resultados = [];\r\n\r\n    for (const archivo of archivos) {\r\n      const resultado = await this.copiar(\r\n        archivo.origen,\r\n        archivo.destino,\r\n        opciones\r\n      );\r\n      resultados.push(resultado);\r\n    }\r\n\r\n    return resultados;\r\n  }\r\n\r\n  obtenerEstadisticas() {\r\n    const total = this.registroCopias.length;\r\n    const exitosas = this.registroCopias.filter((c) => c.exito).length;\r\n    const fallidas = total - exitosas;\r\n    const tama\xf1oTotal = this.registroCopias\r\n      .filter((c) => c.exito && c.tama\xf1o)\r\n      .reduce((sum, c) => sum + c.tama\xf1o, 0);\r\n\r\n    return {\r\n      totalCopias: total,\r\n      exitosas: exitosas,\r\n      fallidas: fallidas,\r\n      tama\xf1oTotal: tama\xf1oTotal,\r\n      tasaExito: total > 0 ? ((exitosas / total) * 100).toFixed(2) + "%" : "0%",\r\n    };\r\n  }\r\n\r\n  limpiarRegistro() {\r\n    const count = this.registroCopias.length;\r\n    this.registroCopias = [];\r\n    return count;\r\n  }\r\n}\r\n\r\n// EJEMPLO 7: USO DEL GESTOR DE COPIAS\r\nasync function usarGestorCopias() {\r\n  const gestor = new GestorCopias();\r\n\r\n  const archivosACopiar = [\r\n    { origen: "./archivo1.txt", destino: "./backups/archivo1-backup.txt" },\r\n    { origen: "./archivo2.txt", destino: "./backups/archivo2-backup.txt" },\r\n    { origen: "./archivo3.txt", destino: "./backups/archivo3-backup.txt" },\r\n  ];\r\n\r\n  console.log("Iniciando copia de lote de archivos...");\r\n  const resultados = await gestor.copiarLote(archivosACopiar, {\r\n    crearDirectorios: true,\r\n    verificarIntegridad: true,\r\n    sobrescribir: false,\r\n  });\r\n\r\n  const estadisticas = gestor.obtenerEstadisticas();\r\n  console.log("\\nEstad\xedsticas de copia:");\r\n  console.log(`- Total: ${estadisticas.totalCopias}`);\r\n  console.log(`- Exitosas: ${estadisticas.exitosas}`);\r\n  console.log(`- Fallidas: ${estadisticas.fallidas}`);\r\n  console.log(`- Tasa de \xe9xito: ${estadisticas.tasaExito}`);\r\n  console.log(`- Tama\xf1o total copiado: ${estadisticas.tama\xf1oTotal} bytes`);\r\n}\r\n\r\n// EJEMPLO 8: COPIAR CON TRANSFORMACI\xd3N DE CONTENIDO\r\nasync function copiarConTransformacion(origen, destino, transformacion) {\r\n  try {\r\n    // Leer el archivo origen\r\n    const contenido = await fs.readFile(origen, "utf8");\r\n\r\n    // Aplicar transformaci\xf3n\r\n    let contenidoTransformado;\r\n    if (typeof transformacion === "function") {\r\n      contenidoTransformado = transformacion(contenido);\r\n    } else {\r\n      contenidoTransformado = contenido;\r\n    }\r\n\r\n    // Escribir el archivo destino\r\n    await fs.writeFile(destino, contenidoTransformado);\r\n    console.log(`Archivo copiado y transformado: ${origen} -> ${destino}`);\r\n  } catch (error) {\r\n    console.error("Error en copia con transformaci\xf3n:", error.message);\r\n  }\r\n}\r\n\r\n// EJEMPLO 9: COPIAR ARCHIVOS BINARIOS\r\nasync function copiarArchivoBinario(origen, destino) {\r\n  try {\r\n    // Para archivos binarios, no especificar codificaci\xf3n\r\n    // copyFile funciona igual para archivos de texto y binarios\r\n\r\n    // Verificar que es un archivo binario (opcional)\r\n    const stats = await fs.stat(origen);\r\n    console.log(`Copiando archivo binario (${stats.size} bytes): ${origen}`);\r\n\r\n    // Realizar la copia\r\n    await fs.copyFile(origen, destino);\r\n\r\n    // Verificar la copia\r\n    const statsDestino = await fs.stat(destino);\r\n    if (stats.size === statsDestino.size) {\r\n      console.log(`\u2705 Copia binaria verificada: ${origen} -> ${destino}`);\r\n    } else {\r\n      console.log("\u26a0\ufe0f  Advertencia: Tama\xf1os diferentes en copia binaria");\r\n    }\r\n  } catch (error) {\r\n    console.error("Error copiando archivo binario:", error.message);\r\n  }\r\n}\r\n\r\n// EJEMPLO 10: COPIAR CON BACKUP AUTOM\xc1TICO\r\nasync function copiarConBackup(origen, destino) {\r\n  try {\r\n    const path = await import("path");\r\n\r\n    // Si el archivo destino ya existe, crear un backup\r\n    try {\r\n      await fs.access(destino);\r\n\r\n      // El archivo destino existe, crear backup\r\n      const extension = path.extname(destino);\r\n      const nombreBase = path.basename(destino, extension);\r\n      const timestamp = new Date().getTime();\r\n      const backupPath = `${path.dirname(\r\n        destino\r\n      )}/${nombreBase}_backup_${timestamp}${extension}`;\r\n\r\n      await fs.copyFile(destino, backupPath);\r\n      console.log(`\u2705 Backup creado: ${backupPath}`);\r\n    } catch (error) {\r\n      // El archivo destino no existe, no se necesita backup\r\n      if (error.code !== "ENOENT") {\r\n        throw error;\r\n      }\r\n    }\r\n\r\n    // Realizar la copia principal\r\n    await fs.copyFile(origen, destino);\r\n    console.log(`\u2705 Archivo copiado: ${origen} -> ${destino}`);\r\n  } catch (error) {\r\n    console.error("Error en copia con backup:", error.message);\r\n  }\r\n}\r\n\r\n// EJEMPLO 11: COPIAR CON LIMITE DE TAMA\xd1O\r\nasync function copiarConLimiteTama\xf1o(\r\n  origen,\r\n  destino,\r\n  tama\xf1oMaximo = 10 * 1024 * 1024\r\n) {\r\n  // 10MB por defecto\r\n  try {\r\n    // Verificar tama\xf1o del archivo origen\r\n    const stats = await fs.stat(origen);\r\n\r\n    if (stats.size > tama\xf1oMaximo) {\r\n      throw new Error(\r\n        `El archivo es demasiado grande (${stats.size} bytes). L\xedmite: ${tama\xf1oMaximo} bytes`\r\n      );\r\n    }\r\n\r\n    // Realizar la copia si pasa la verificaci\xf3n de tama\xf1o\r\n    await fs.copyFile(origen, destino);\r\n    console.log(\r\n      `\u2705 Archivo copiado (${stats.size} bytes): ${origen} -> ${destino}`\r\n    );\r\n  } catch (error) {\r\n    console.error("Error en copia con l\xedmite de tama\xf1o:", error.message);\r\n  }\r\n}\r\n\r\n// EJECUCI\xd3N DE EJEMPLOS\r\nasync function ejecutarEjemplos() {\r\n  console.log("=== EJEMPLOS DE COPIA DE ARCHIVOS ===");\r\n\r\n  // Crear archivos de prueba primero\r\n  try {\r\n    await fs.writeFile(\r\n      "./original.txt",\r\n      "Este es el contenido del archivo original"\r\n    );\r\n    await fs.writeFile("./archivo1.txt", "Contenido archivo 1");\r\n    await fs.writeFile("./archivo2.txt", "Contenido archivo 2");\r\n\r\n    // Ejemplo b\xe1sico\r\n    await copiarArchivo("./original.txt", "./copia-basica.txt");\r\n\r\n    // Ejemplos avanzados\r\n    await copiarConVerificacion("./original.txt", "./copia-verificada.txt");\r\n    await copiarSinSobrescribir("./original.txt", "./copia-exclusiva.txt");\r\n    await usarGestorCopias();\r\n\r\n    // Limpiar archivos de prueba\r\n    await fs.unlink("./original.txt");\r\n    await fs.unlink("./copia-basica.txt");\r\n    await fs.unlink("./copia-verificada.txt");\r\n    await fs.rm("./backups", { recursive: true, force: true });\r\n  } catch (error) {\r\n    console.error("Error en ejemplos:", error.message);\r\n  }\r\n}\r\n\r\n// Descomentar para ejecutar\r\n// ejecutarEjemplos();\n'})}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"CARACTER\xcdSTICAS PRINCIPALES EXPLICADAS:"})}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:(0,a.jsx)(n.code,{children:"fs.copyFile(origen, destino)"})}),": Copia el contenido de un archivo a otro"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:(0,a.jsx)(n.code,{children:"fs.copyFile(origen, destino, modo)"})}),": Copia con modos espec\xedficos"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Modos disponibles"}),":","\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"COPYFILE_EXCL"}),": Falla si el destino existe"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"COPYFILE_FICLONE"}),": Usa copy-on-write si est\xe1 disponible"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"COPYFILE_FICLONE_FORCE"}),": Fuerza copy-on-write o falla"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"COMPORTAMIENTO POR DEFECTO:"})}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Sobrescribe el archivo destino si existe"}),"\n",(0,a.jsx)(n.li,{children:"Copia tanto archivos de texto como binarios"}),"\n",(0,a.jsx)(n.li,{children:"Mantiene los mismos permisos (en la mayor\xeda de sistemas)"}),"\n",(0,a.jsx)(n.li,{children:"No copia metadatos como fechas de creaci\xf3n"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsxs)(n.strong,{children:["VENTAJAS DE\xa0",(0,a.jsx)(n.code,{children:"copyFile"}),":"]})}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"M\xe1s eficiente que leer y escribir manualmente"}),"\n",(0,a.jsx)(n.li,{children:"Maneja autom\xe1ticamente archivos grandes"}),"\n",(0,a.jsx)(n.li,{children:"Optimizado para el sistema operativo"}),"\n",(0,a.jsx)(n.li,{children:"Soporte para operaciones at\xf3micas en algunos casos"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"USOS COMUNES:"})}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Creaci\xf3n de backups"}),"\n",(0,a.jsx)(n.li,{children:"Duplicaci\xf3n de archivos de configuraci\xf3n"}),"\n",(0,a.jsx)(n.li,{children:"Procesamiento de uploads de archivos"}),"\n",(0,a.jsx)(n.li,{children:"Sincronizaci\xf3n de datos"}),"\n",(0,a.jsx)(n.li,{children:"Operaciones de deployment"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:"Este c\xf3digo proporciona una base completa para trabajar con operaciones de copia de archivos en Node.js, desde funciones b\xe1sicas hasta gesti\xf3n avanzada con verificaci\xf3n de integridad y manejo de errores."}),"\n",(0,a.jsx)(n.h3,{id:"renombrar-y-mover-archivos",children:"Renombrar y Mover Archivos"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-jsx",children:'// Importar el m\xf3dulo de sistema de archivos con soporte para Promises\r\n// fs/promises proporciona m\xe9todos as\xedncronos basados en Promises\r\nimport fs from "fs/promises";\r\n\r\n// Funci\xf3n as\xedncrona para renombrar y mover archivos\r\n// fs.rename() puede tanto renombrar archivos como moverlos entre directorios\r\nasync function renombrarArchivo() {\r\n  try {\r\n    // Renombrar un archivo (tambi\xe9n puede moverlo entre directorios)\r\n    // fs.rename() cambia el nombre de un archivo o lo mueve a una nueva ubicaci\xf3n\r\n    // Si la ruta destino es diferente, el archivo se mueve a esa ubicaci\xf3n\r\n    await fs.rename("./viejo-nombre.txt", "./nuevo-nombre.txt");\r\n    console.log(\r\n      "Archivo renombrado exitosamente: ./viejo-nombre.txt -> ./nuevo-nombre.txt"\r\n    );\r\n\r\n    // Mover archivo a otro directorio\r\n    // Cuando el directorio destino es diferente, fs.rename() mueve el archivo\r\n    // El directorio destino debe existir, de lo contrario lanzar\xe1 un error\r\n    await fs.rename("./archivo.txt", "./backups/archivo.txt");\r\n    console.log(\r\n      "Archivo movido a directorio backups: ./archivo.txt -> ./backups/archivo.txt"\r\n    );\r\n  } catch (error) {\r\n    console.error("Error al renombrar/mover archivo:", error.message);\r\n  }\r\n}\r\n\r\n// Ejecutar la funci\xf3n\r\nrenombrarArchivo();\r\n\r\n// EJEMPLOS ADICIONALES Y EXPLICACIONES DETALLADAS:\r\n\r\n// EJEMPLO 1: VERIFICAR ANTES DE RENOMBRAR\r\nasync function renombrarConVerificacion(viejaRuta, nuevaRuta) {\r\n  try {\r\n    // Verificar que el archivo origen existe\r\n    await fs.access(viejaRuta);\r\n    console.log(`Archivo origen verificado: ${viejaRuta}`);\r\n\r\n    // Verificar si el archivo destino ya existe\r\n    try {\r\n      await fs.access(nuevaRuta);\r\n      console.log(\r\n        `Advertencia: El archivo destino ${nuevaRuta} ya existe y ser\xe1 sobrescrito`\r\n      );\r\n    } catch (error) {\r\n      if (error.code === "ENOENT") {\r\n        console.log(`Archivo destino no existe, se crear\xe1: ${nuevaRuta}`);\r\n      } else {\r\n        throw error; // Relanzar otros errores\r\n      }\r\n    }\r\n\r\n    // Realizar el renombrado\r\n    await fs.rename(viejaRuta, nuevaRuta);\r\n    console.log(`\u2705 Renombrado exitoso: ${viejaRuta} -> ${nuevaRuta}`);\r\n  } catch (error) {\r\n    console.error("Error en renombrado con verificaci\xf3n:", error.message);\r\n  }\r\n}\r\n\r\n// EJEMPLO 2: MOVER ARCHIVO CON CREACI\xd3N DE DIRECTORIO DESTINO\r\nasync function moverConDirectorio(origen, destino) {\r\n  try {\r\n    // Importar path para manipulaci\xf3n de rutas\r\n    const path = await import("path");\r\n\r\n    // Extraer el directorio destino del path completo\r\n    const directorioDestino = path.dirname(destino);\r\n\r\n    // Verificar si el directorio destino existe, si no, crearlo\r\n    try {\r\n      await fs.access(directorioDestino);\r\n    } catch (error) {\r\n      if (error.code === "ENOENT") {\r\n        console.log(`Creando directorio destino: ${directorioDestino}`);\r\n        await fs.mkdir(directorioDestino, { recursive: true });\r\n      } else {\r\n        throw error;\r\n      }\r\n    }\r\n\r\n    // Realizar el movimiento\r\n    await fs.rename(origen, destino);\r\n    console.log(`\u2705 Archivo movido: ${origen} -> ${destino}`);\r\n  } catch (error) {\r\n    console.error("Error moviendo archivo con directorio:", error.message);\r\n  }\r\n}\r\n\r\n// EJEMPLO 3: RENOMBRAR M\xdaLTIPLES ARCHIVOS\r\nasync function renombrarMultiplesArchivos(renombres) {\r\n  try {\r\n    // renombres es un array de objetos { origen, destino }\r\n    const resultados = [];\r\n\r\n    for (const renombre of renombres) {\r\n      try {\r\n        await fs.rename(renombre.origen, renombre.destino);\r\n        console.log(`\u2705 Renombrado: ${renombre.origen} -> ${renombre.destino}`);\r\n        resultados.push({\r\n          exito: true,\r\n          origen: renombre.origen,\r\n          destino: renombre.destino,\r\n        });\r\n      } catch (error) {\r\n        console.error(\r\n          `\u274c Error renombrando ${renombre.origen}:`,\r\n          error.message\r\n        );\r\n        resultados.push({\r\n          exito: false,\r\n          origen: renombre.origen,\r\n          destino: renombre.destino,\r\n          error: error.message,\r\n        });\r\n      }\r\n    }\r\n\r\n    const exitosos = resultados.filter((r) => r.exito).length;\r\n    console.log(\r\n      `Resumen: ${exitosos}/${resultados.length} renombrados exitosos`\r\n    );\r\n\r\n    return resultados;\r\n  } catch (error) {\r\n    console.error("Error en renombrado m\xfaltiple:", error.message);\r\n    return [];\r\n  }\r\n}\r\n\r\n// EJEMPLO 4: RENOMBRAR CON PATR\xd3N (B\xdaSQUEDA Y REEMPLAZO)\r\nasync function renombrarPorPatron(directorio, patronBusqueda, patronReemplazo) {\r\n  try {\r\n    const elementos = await fs.readdir(directorio, { withFileTypes: true });\r\n    const archivos = elementos.filter((elemento) => elemento.isFile());\r\n\r\n    const resultados = [];\r\n\r\n    for (const archivo of archivos) {\r\n      if (archivo.name.includes(patronBusqueda)) {\r\n        const nuevoNombre = archivo.name.replace(\r\n          patronBusqueda,\r\n          patronReemplazo\r\n        );\r\n        const origen = `${directorio}/${archivo.name}`;\r\n        const destino = `${directorio}/${nuevoNombre}`;\r\n\r\n        try {\r\n          await fs.rename(origen, destino);\r\n          console.log(`\u2705 Renombrado: ${archivo.name} -> ${nuevoNombre}`);\r\n          resultados.push({\r\n            exito: true,\r\n            origen: archivo.name,\r\n            destino: nuevoNombre,\r\n          });\r\n        } catch (error) {\r\n          console.error(`\u274c Error renombrando ${archivo.name}:`, error.message);\r\n          resultados.push({\r\n            exito: false,\r\n            origen: archivo.name,\r\n            error: error.message,\r\n          });\r\n        }\r\n      }\r\n    }\r\n\r\n    return resultados;\r\n  } catch (error) {\r\n    console.error("Error en renombrado por patr\xf3n:", error.message);\r\n    return [];\r\n  }\r\n}\r\n\r\n// EJEMPLO 5: CLASE PARA GESTI\xd3N DE RENOMBRADO\r\nclass GestorRenombrado {\r\n  constructor() {\r\n    this.registroRenombres = [];\r\n  }\r\n\r\n  async renombrar(origen, destino, opciones = {}) {\r\n    const config = {\r\n      crearDirectorios: true,\r\n      sobrescribir: false,\r\n      ...opciones,\r\n    };\r\n\r\n    try {\r\n      // Verificar archivo origen\r\n      const statsOrigen = await fs.stat(origen);\r\n      if (!statsOrigen.isFile()) {\r\n        throw new Error("El origen no es un archivo regular");\r\n      }\r\n\r\n      // Manejar directorios destino\r\n      if (config.crearDirectorios) {\r\n        const path = await import("path");\r\n        const directorioDestino = path.dirname(destino);\r\n        try {\r\n          await fs.access(directorioDestino);\r\n        } catch (error) {\r\n          if (error.code === "ENOENT") {\r\n            await fs.mkdir(directorioDestino, { recursive: true });\r\n          } else {\r\n            throw error;\r\n          }\r\n        }\r\n      }\r\n\r\n      // Verificar si el destino existe (si no se permite sobrescribir)\r\n      if (!config.sobrescribir) {\r\n        try {\r\n          await fs.access(destino);\r\n          throw new Error("El archivo destino ya existe");\r\n        } catch (error) {\r\n          if (error.code !== "ENOENT") {\r\n            throw error;\r\n          }\r\n        }\r\n      }\r\n\r\n      // Realizar el renombrado\r\n      await fs.rename(origen, destino);\r\n\r\n      // Registrar el renombrado exitoso\r\n      const registro = {\r\n        origen: origen,\r\n        destino: destino,\r\n        fecha: new Date(),\r\n        tama\xf1o: statsOrigen.size,\r\n        exito: true,\r\n      };\r\n\r\n      this.registroRenombres.push(registro);\r\n      console.log(`\u2705 Renombrado exitoso: ${origen} -> ${destino}`);\r\n\r\n      return registro;\r\n    } catch (error) {\r\n      const registroError = {\r\n        origen: origen,\r\n        destino: destino,\r\n        fecha: new Date(),\r\n        exito: false,\r\n        error: error.message,\r\n      };\r\n\r\n      this.registroRenombres.push(registroError);\r\n      console.error(`\u274c Error renombrando ${origen}:`, error.message);\r\n\r\n      return registroError;\r\n    }\r\n  }\r\n\r\n  async renombrarLote(renombres, opciones = {}) {\r\n    const resultados = [];\r\n\r\n    for (const renombre of renombres) {\r\n      const resultado = await this.renombrar(\r\n        renombre.origen,\r\n        renombre.destino,\r\n        opciones\r\n      );\r\n      resultados.push(resultado);\r\n    }\r\n\r\n    return resultados;\r\n  }\r\n\r\n  async renombrarConTimestamp(origen, prefijo = "backup_") {\r\n    try {\r\n      const path = await import("path");\r\n      const timestamp = new Date().getTime();\r\n      const extension = path.extname(origen);\r\n      const nombreBase = path.basename(origen, extension);\r\n      const directorio = path.dirname(origen);\r\n\r\n      const destino = `${directorio}/${prefijo}${nombreBase}_${timestamp}${extension}`;\r\n\r\n      return await this.renombrar(origen, destino);\r\n    } catch (error) {\r\n      console.error("Error en renombrado con timestamp:", error.message);\r\n      return { exito: false, error: error.message };\r\n    }\r\n  }\r\n\r\n  obtenerEstadisticas() {\r\n    const total = this.registroRenombres.length;\r\n    const exitosos = this.registroRenombres.filter((r) => r.exito).length;\r\n    const fallidos = total - exitosos;\r\n\r\n    return {\r\n      totalRenombres: total,\r\n      exitosos: exitosos,\r\n      fallidos: fallidos,\r\n      tasaExito: total > 0 ? ((exitosos / total) * 100).toFixed(2) + "%" : "0%",\r\n    };\r\n  }\r\n\r\n  limpiarRegistro() {\r\n    const count = this.registroRenombres.length;\r\n    this.registroRenombres = [];\r\n    return count;\r\n  }\r\n}\r\n\r\n// EJEMPLO 6: USO DEL GESTOR DE RENOMBRADO\r\nasync function usarGestorRenombrado() {\r\n  const gestor = new GestorRenombrado();\r\n\r\n  const archivosARenombrar = [\r\n    { origen: "./documento-viejo.txt", destino: "./documento-nuevo.txt" },\r\n    { origen: "./imagen.jpg", destino: "./fotos/imagen-actualizada.jpg" },\r\n    { origen: "./log.txt", destino: "./archivos/log-diario.txt" },\r\n  ];\r\n\r\n  console.log("Iniciando renombrado de lote de archivos...");\r\n  const resultados = await gestor.renombrarLote(archivosARenombrar, {\r\n    crearDirectorios: true,\r\n    sobrescribir: false,\r\n  });\r\n\r\n  const estadisticas = gestor.obtenerEstadisticas();\r\n  console.log("\\nEstad\xedsticas de renombrado:");\r\n  console.log(`- Total: ${estadisticas.totalRenombres}`);\r\n  console.log(`- Exitosos: ${estadisticas.exitosos}`);\r\n  console.log(`- Fallidos: ${estadisticas.fallidos}`);\r\n  console.log(`- Tasa de \xe9xito: ${estadisticas.tasaExito}`);\r\n}\r\n\r\n// EJEMPLO 7: ORGANIZAR ARCHIVOS POR EXTENSI\xd3N\r\nasync function organizarPorExtension(directorio) {\r\n  try {\r\n    const elementos = await fs.readdir(directorio, { withFileTypes: true });\r\n    const archivos = elementos.filter((elemento) => elemento.isFile());\r\n\r\n    const resultados = [];\r\n\r\n    for (const archivo of archivos) {\r\n      const path = await import("path");\r\n      const extension =\r\n        path.extname(archivo.name).toLowerCase() || "sin-extension";\r\n      const directorioDestino = `${directorio}/${extension.replace(".", "")}`;\r\n      const destino = `${directorioDestino}/${archivo.name}`;\r\n\r\n      // Crear directorio para la extensi\xf3n si no existe\r\n      try {\r\n        await fs.access(directorioDestino);\r\n      } catch (error) {\r\n        if (error.code === "ENOENT") {\r\n          await fs.mkdir(directorioDestino, { recursive: true });\r\n        } else {\r\n          throw error;\r\n        }\r\n      }\r\n\r\n      // Mover el archivo\r\n      try {\r\n        await fs.rename(`${directorio}/${archivo.name}`, destino);\r\n        console.log(`\u2705 Organizado: ${archivo.name} -> ${directorioDestino}/`);\r\n        resultados.push({\r\n          exito: true,\r\n          archivo: archivo.name,\r\n          destino: directorioDestino,\r\n        });\r\n      } catch (error) {\r\n        console.error(`\u274c Error organizando ${archivo.name}:`, error.message);\r\n        resultados.push({\r\n          exito: false,\r\n          archivo: archivo.name,\r\n          error: error.message,\r\n        });\r\n      }\r\n    }\r\n\r\n    return resultados;\r\n  } catch (error) {\r\n    console.error("Error organizando por extensi\xf3n:", error.message);\r\n    return [];\r\n  }\r\n}\r\n\r\n// EJEMPLO 8: RENOMBRAR CON NUMERACI\xd3N SECUENCIAL\r\nasync function renombrarSecuencial(directorio, prefijo = "archivo_") {\r\n  try {\r\n    const elementos = await fs.readdir(directorio, { withFileTypes: true });\r\n    const archivos = elementos.filter((elemento) => elemento.isFile());\r\n\r\n    // Ordenar archivos alfab\xe9ticamente\r\n    archivos.sort((a, b) => a.name.localeCompare(b.name));\r\n\r\n    const resultados = [];\r\n\r\n    for (let i = 0; i < archivos.length; i++) {\r\n      const archivo = archivos[i];\r\n      const numero = (i + 1).toString().padStart(3, "0"); // 001, 002, etc.\r\n      const extension = archivo.name.split(".").pop();\r\n      const nuevoNombre = `${prefijo}${numero}.${extension}`;\r\n      const origen = `${directorio}/${archivo.name}`;\r\n      const destino = `${directorio}/${nuevoNombre}`;\r\n\r\n      try {\r\n        await fs.rename(origen, destino);\r\n        console.log(\r\n          `\u2705 Renombrado secuencial: ${archivo.name} -> ${nuevoNombre}`\r\n        );\r\n        resultados.push({\r\n          exito: true,\r\n          original: archivo.name,\r\n          nuevo: nuevoNombre,\r\n        });\r\n      } catch (error) {\r\n        console.error(`\u274c Error renombrando ${archivo.name}:`, error.message);\r\n        resultados.push({\r\n          exito: false,\r\n          archivo: archivo.name,\r\n          error: error.message,\r\n        });\r\n      }\r\n    }\r\n\r\n    return resultados;\r\n  } catch (error) {\r\n    console.error("Error en renombrado secuencial:", error.message);\r\n    return [];\r\n  }\r\n}\r\n\r\n// EJEMPLO 9: MOVER ARCHIVOS POR FECHA\r\nasync function moverPorFecha(directorio, diasLimite = 30) {\r\n  try {\r\n    const elementos = await fs.readdir(directorio, { withFileTypes: true });\r\n    const archivos = elementos.filter((elemento) => elemento.isFile());\r\n\r\n    const fechaLimite = new Date();\r\n    fechaLimite.setDate(fechaLimite.getDate() - diasLimite);\r\n\r\n    const resultados = [];\r\n\r\n    for (const archivo of archivos) {\r\n      const rutaCompleta = `${directorio}/${archivo.name}`;\r\n      const stats = await fs.stat(rutaCompleta);\r\n\r\n      if (stats.mtime < fechaLimite) {\r\n        const path = await import("path");\r\n        const fechaCarpeta = stats.mtime.toISOString().split("T")[0]; // YYYY-MM-DD\r\n        const directorioDestino = `${directorio}/antiguos/${fechaCarpeta}`;\r\n        const destino = `${directorioDestino}/${archivo.name}`;\r\n\r\n        // Crear directorio de fecha si no existe\r\n        try {\r\n          await fs.access(directorioDestino);\r\n        } catch (error) {\r\n          if (error.code === "ENOENT") {\r\n            await fs.mkdir(directorioDestino, { recursive: true });\r\n          } else {\r\n            throw error;\r\n          }\r\n        }\r\n\r\n        // Mover el archivo\r\n        try {\r\n          await fs.rename(rutaCompleta, destino);\r\n          console.log(\r\n            `\u2705 Movido por fecha: ${archivo.name} -> ${directorioDestino}/`\r\n          );\r\n          resultados.push({\r\n            exito: true,\r\n            archivo: archivo.name,\r\n            destino: directorioDestino,\r\n            fecha: stats.mtime,\r\n          });\r\n        } catch (error) {\r\n          console.error(`\u274c Error moviendo ${archivo.name}:`, error.message);\r\n          resultados.push({\r\n            exito: false,\r\n            archivo: archivo.name,\r\n            error: error.message,\r\n          });\r\n        }\r\n      }\r\n    }\r\n\r\n    return resultados;\r\n  } catch (error) {\r\n    console.error("Error moviendo por fecha:", error.message);\r\n    return [];\r\n  }\r\n}\r\n\r\n// EJEMPLO 10: RENOMBRAR CON VALIDACI\xd3N DE SEGURIDAD\r\nasync function renombrarSeguro(origen, destino, exclusiones = []) {\r\n  // Lista de rutas cr\xedticas que NUNCA deber\xedan renombrarse\r\n  const rutasProtegidas = [\r\n    "/",\r\n    "/etc",\r\n    "/bin",\r\n    "/usr",\r\n    "/var",\r\n    "/home",\r\n    "/System",\r\n    "/Windows",\r\n    "C:\\\\",\r\n    "C:/Windows",\r\n  ];\r\n\r\n  // Convertir rutas a absolutas para comparaci\xf3n\r\n  const path = await import("path");\r\n  const origenAbsoluto = await fs.realpath(origen);\r\n  const destinoAbsoluto = path.resolve(destino);\r\n\r\n  // Verificar que no sean rutas protegidas\r\n  const esRutaProtegida = rutasProtegidas.some(\r\n    (protegida) =>\r\n      origenAbsoluto.startsWith(protegida) ||\r\n      destinoAbsoluto.startsWith(protegida)\r\n  );\r\n\r\n  if (esRutaProtegida) {\r\n    throw new Error(`OPERACI\xd3N BLOQUEADA: Ruta protegida detectada`);\r\n  }\r\n\r\n  // Verificar exclusiones personalizadas\r\n  const estaExcluida = exclusiones.some(\r\n    (exclusion) =>\r\n      origenAbsoluto.includes(exclusion) || destinoAbsoluto.includes(exclusion)\r\n  );\r\n\r\n  if (estaExcluida) {\r\n    throw new Error(`OPERACI\xd3N BLOQUEADA: Ruta en lista de exclusiones`);\r\n  }\r\n\r\n  // Si pasa todas las validaciones, proceder con renombrado\r\n  await fs.rename(origen, destino);\r\n  console.log(`\u2705 Renombrado seguro completado: ${origen} -> ${destino}`);\r\n}\r\n\r\n// EJECUCI\xd3N DE EJEMPLOS\r\nasync function ejecutarEjemplos() {\r\n  console.log("=== EJEMPLOS DE RENOMBRADO Y MOVIMIENTO DE ARCHIVOS ===");\r\n\r\n  // Crear archivos y directorios de prueba primero\r\n  try {\r\n    await fs.writeFile("./viejo-nombre.txt", "Contenido archivo viejo");\r\n    await fs.writeFile("./archivo.txt", "Contenido archivo normal");\r\n    await fs.mkdir("./backups", { recursive: true });\r\n\r\n    // Ejemplo b\xe1sico\r\n    await renombrarArchivo();\r\n\r\n    // Crear m\xe1s archivos para ejemplos avanzados\r\n    await fs.writeFile("./documento-viejo.txt", "Contenido documento");\r\n    await fs.writeFile("./imagen.jpg", "contenido imagen simulado");\r\n    await fs.writeFile("./log.txt", "contenido log");\r\n\r\n    // Ejemplos avanzados\r\n    await renombrarConVerificacion(\r\n      "./documento-viejo.txt",\r\n      "./documento-nuevo.txt"\r\n    );\r\n    await usarGestorRenombrado();\r\n    await renombrarPorPatron("./", "viejo", "nuevo");\r\n\r\n    // Limpiar archivos de prueba\r\n    await fs.unlink("./nuevo-nombre.txt").catch(() => {});\r\n    await fs.unlink("./documento-nuevo.txt").catch(() => {});\r\n    await fs.rm("./backups", { recursive: true, force: true }).catch(() => {});\r\n    await fs.rm("./fotos", { recursive: true, force: true }).catch(() => {});\r\n    await fs.rm("./archivos", { recursive: true, force: true }).catch(() => {});\r\n  } catch (error) {\r\n    console.error("Error en ejemplos:", error.message);\r\n  }\r\n}\r\n\r\n// Descomentar para ejecutar\r\n// ejecutarEjemplos();\n'})}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"FUNCIONES PRINCIPALES EXPLICADAS:"})}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:(0,a.jsx)(n.code,{children:"fs.unlink(ruta)"})}),": Elimina archivos o enlaces simb\xf3licos"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:(0,a.jsx)(n.code,{children:"fs.rmdir(ruta)"})}),": Elimina directorios vac\xedos"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:(0,a.jsx)(n.code,{children:"fs.rm(ruta, opciones)"})}),": Funci\xf3n moderna que unifica la eliminaci\xf3n","\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"recursive: true"}),"\xa0- Elimina directorios con contenido"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"force: true"}),"\xa0- No lanza error si el elemento no existe"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"DIFERENCIAS CLAVE:"})}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:(0,a.jsx)(n.code,{children:"unlink()"})}),": Solo para archivos y enlaces simb\xf3licos"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:(0,a.jsx)(n.code,{children:"rmdir()"})}),": Solo para directorios vac\xedos"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:(0,a.jsx)(n.code,{children:"rm()"})}),": Para cualquier tipo, con opciones para recursividad y fuerza"]}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"PRECAUCIONES CR\xcdTICAS:"})}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Las eliminaciones son permanentes e irreversibles"}),"\n",(0,a.jsx)(n.li,{children:"Verificar siempre la ruta antes de eliminar"}),"\n",(0,a.jsx)(n.li,{children:"Usar validaciones de seguridad para rutas cr\xedticas"}),"\n",(0,a.jsx)(n.li,{children:"Considerar implementar confirmaciones interactivas"}),"\n",(0,a.jsx)(n.li,{children:"Mantener registros de operaciones de eliminaci\xf3n"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"USOS COMUNES:"})}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Limpieza de archivos temporales"}),"\n",(0,a.jsx)(n.li,{children:"Gesti\xf3n de espacio en disco"}),"\n",(0,a.jsx)(n.li,{children:"Rotaci\xf3n de logs"}),"\n",(0,a.jsx)(n.li,{children:"Limpieza de cach\xe9 de aplicaciones"}),"\n",(0,a.jsx)(n.li,{children:"Operaciones de mantenimiento del sistema"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:"Este c\xf3digo proporciona una base completa para trabajar con operaciones de eliminaci\xf3n de forma segura y controlada en Node.js."}),"\n",(0,a.jsx)(n.h2,{id:"manejo-de-archivos-grandes-con-streams",children:"Manejo de Archivos Grandes con Streams"}),"\n",(0,a.jsx)(n.p,{children:"Para archivos de gran tama\xf1o, es m\xe1s eficiente usar streams en lugar de leer todo el contenido en memoria."}),"\n",(0,a.jsx)(n.h3,{id:"lectura-con-streams",children:"Lectura con Streams"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-jsx",children:'// Importar el m\xf3dulo de sistema de archivos (versi\xf3n con callbacks)\r\n// y la funci\xf3n once para manejar eventos una sola vez\r\nimport fs from "fs";\r\nimport { once } from "events";\r\n\r\n// Funci\xf3n as\xedncrona para leer archivos grandes usando streams\r\n// Los streams son esenciales para archivos que no caben en memoria\r\nasync function leerArchivoGrande(rutaArchivo) {\r\n  // Crear stream de lectura\r\n  // fs.createReadStream() crea un stream legible que lee el archivo en chunks\r\n  const streamLectura = fs.createReadStream(rutaArchivo, {\r\n    encoding: "utf8", // Codificaci\xf3n del archivo\r\n    highWaterMark: 64 * 1024, // Tama\xf1o de cada chunk: 64KB\r\n    // highWaterMark controla el tama\xf1o m\xe1ximo de cada fragmento de datos\r\n  });\r\n\r\n  try {\r\n    // Variables para trackear el progreso\r\n    let totalBytes = 0;\r\n    let numeroChunks = 0;\r\n\r\n    // Manejar eventos del stream - \'data\' se dispara cuando hay datos disponibles\r\n    streamLectura.on("data", (chunk) => {\r\n      numeroChunks++;\r\n      totalBytes += chunk.length;\r\n      console.log(`Procesando chunk ${numeroChunks}: ${chunk.length} bytes`);\r\n\r\n      // Aqu\xed puedes procesar cada chunk seg\xfan tus necesidades\r\n      // Ejemplo: buscar texto, transformar datos, analizar contenido, etc.\r\n      // El chunk es una porci\xf3n del archivo, no el archivo completo\r\n\r\n      // EJEMPLO: Contar l\xedneas en el chunk actual\r\n      const lineasEnChunk = chunk.split("\\n").length - 1;\r\n      console.log(`  L\xedneas en chunk: ${lineasEnChunk}`);\r\n\r\n      // EJEMPLO: Buscar una palabra espec\xedfica\r\n      if (chunk.includes("error")) {\r\n        console.log(\'  \u26a0\ufe0f  Se encontr\xf3 la palabra "error" en este chunk\');\r\n      }\r\n    });\r\n\r\n    // Evento \'end\' - se dispara cuando todo el archivo ha sido le\xeddo\r\n    streamLectura.on("end", () => {\r\n      console.log(\r\n        `Lectura completada: ${numeroChunks} chunks, ${totalBytes} bytes total`\r\n      );\r\n      console.log(\r\n        `Tama\xf1o promedio por chunk: ${(totalBytes / numeroChunks).toFixed(\r\n          2\r\n        )} bytes`\r\n      );\r\n    });\r\n\r\n    // Evento \'error\' - se dispara cuando ocurre un error en la lectura\r\n    streamLectura.on("error", (error) => {\r\n      console.error("Error en la lectura:", error.message);\r\n    });\r\n\r\n    // Evento \'open\' - se dispara cuando el archivo se abre exitosamente\r\n    streamLectura.on("open", () => {\r\n      console.log(`Archivo abierto: ${rutaArchivo}`);\r\n    });\r\n\r\n    // Evento \'close\' - se dispara cuando el stream se cierra\r\n    streamLectura.on("close", () => {\r\n      console.log("Stream cerrado");\r\n    });\r\n\r\n    // Esperar a que el stream termine usando once()\r\n    // once() retorna una promise que se resuelve cuando el evento \'end\' ocurre\r\n    await once(streamLectura, "end");\r\n  } catch (error) {\r\n    console.error("Error en lectura por stream:", error.message);\r\n  }\r\n}\r\n\r\n// Ejecutar la funci\xf3n\r\n// leerArchivoGrande(\'./archivo-grande.log\');\r\n\r\n// EJEMPLOS ADICIONALES Y EXPLICACIONES DETALLADAS:\r\n\r\n// EJEMPLO 1: STREAM CON PAUSA Y REANUDACI\xd3N\r\nasync function leerConPausa(rutaArchivo) {\r\n  const stream = fs.createReadStream(rutaArchivo, {\r\n    encoding: "utf8",\r\n    highWaterMark: 32 * 1024, // 32KB chunks\r\n  });\r\n\r\n  let chunkCount = 0;\r\n\r\n  stream.on("data", (chunk) => {\r\n    chunkCount++;\r\n    console.log(`Chunk ${chunkCount}: ${chunk.length} bytes`);\r\n\r\n    // Pausar despu\xe9s de 5 chunks para simular procesamiento lento\r\n    if (chunkCount === 5) {\r\n      console.log("Pausando stream por 2 segundos...");\r\n      stream.pause();\r\n\r\n      setTimeout(() => {\r\n        console.log("Reanudando stream...");\r\n        stream.resume();\r\n      }, 2000);\r\n    }\r\n  });\r\n\r\n  stream.on("end", () => {\r\n    console.log(`Lectura completada con pausas: ${chunkCount} chunks`);\r\n  });\r\n\r\n  await once(stream, "end");\r\n}\r\n\r\n// EJEMPLO 2: PROCESAR STREAM CON PIPELINE PARA TRANSFORMACI\xd3N\r\nimport { pipeline } from "stream/promises";\r\nimport { Transform } from "stream";\r\n\r\nasync function procesarConTransformacion(rutaArchivo) {\r\n  // Crear un stream de transformaci\xf3n personalizado\r\n  const transformador = new Transform({\r\n    transform(chunk, encoding, callback) {\r\n      // Convertir a may\xfasculas como ejemplo de transformaci\xf3n\r\n      const resultado = chunk.toString().toUpperCase();\r\n      this.push(resultado);\r\n      callback();\r\n    },\r\n  });\r\n\r\n  const streamLectura = fs.createReadStream(rutaArchivo, {\r\n    encoding: "utf8",\r\n    highWaterMark: 16 * 1024,\r\n  });\r\n\r\n  try {\r\n    // Usar pipeline para conectar streams autom\xe1ticamente\r\n    await pipeline(streamLectura, transformador, async function* (source) {\r\n      // Procesar los datos transformados\r\n      let lineCount = 0;\r\n      for await (const chunk of source) {\r\n        lineCount += chunk.toString().split("\\n").length - 1;\r\n        console.log(`Chunk transformado: ${chunk.length} bytes`);\r\n      }\r\n      console.log(`Total l\xedneas procesadas: ${lineCount}`);\r\n    });\r\n  } catch (error) {\r\n    console.error("Error en pipeline:", error.message);\r\n  }\r\n}\r\n\r\n// EJEMPLO 3: LECTURA CON L\xcdMITE DE VELOCIDAD (THROTTLING)\r\nasync function leerConThrottling(rutaArchivo, bytesPorSegundo = 10240) {\r\n  // 10KB/s\r\n  const stream = fs.createReadStream(rutaArchivo, {\r\n    encoding: "utf8",\r\n    highWaterMark: 1024, // 1KB chunks peque\xf1os para mejor control\r\n  });\r\n\r\n  let totalBytes = 0;\r\n  let startTime = Date.now();\r\n\r\n  stream.on("data", (chunk) => {\r\n    totalBytes += chunk.length;\r\n    const elapsedTime = Date.now() - startTime;\r\n    const expectedTime = (totalBytes / bytesPorSegundo) * 1000;\r\n\r\n    // Si vamos muy r\xe1pido, hacer una pausa\r\n    if (elapsedTime < expectedTime) {\r\n      const delay = expectedTime - elapsedTime;\r\n      stream.pause();\r\n      setTimeout(() => stream.resume(), delay);\r\n    }\r\n\r\n    console.log(`Procesados ${totalBytes} bytes, velocidad controlada`);\r\n  });\r\n\r\n  await once(stream, "end");\r\n}\r\n\r\n// EJEMPLO 4: BUSCAR PATRONES EN ARCHIVO GRANDE\r\nasync function buscarPatron(rutaArchivo, patron) {\r\n  const stream = fs.createReadStream(rutaArchivo, {\r\n    encoding: "utf8",\r\n    highWaterMark: 64 * 1024,\r\n  });\r\n\r\n  const regex = new RegExp(patron, "gi");\r\n  let coincidencias = [];\r\n  let numeroLinea = 1;\r\n  let buffer = "";\r\n\r\n  stream.on("data", (chunk) => {\r\n    // Manejar chunks que pueden cortar l\xedneas a la mitad\r\n    buffer += chunk;\r\n    const lineas = buffer.split("\\n");\r\n\r\n    // La \xfaltima l\xednea podr\xeda estar incompleta\r\n    buffer = lineas.pop() || "";\r\n\r\n    for (const linea of lineas) {\r\n      const encontrados = linea.match(regex);\r\n      if (encontrados) {\r\n        coincidencias.push({\r\n          linea: numeroLinea,\r\n          contenido: linea.trim(),\r\n          coincidencias: encontrados,\r\n        });\r\n      }\r\n      numeroLinea++;\r\n    }\r\n  });\r\n\r\n  stream.on("end", () => {\r\n    // Procesar la \xfaltima l\xednea si queda algo en el buffer\r\n    if (buffer.trim()) {\r\n      const encontrados = buffer.match(regex);\r\n      if (encontrados) {\r\n        coincidencias.push({\r\n          linea: numeroLinea,\r\n          contenido: buffer.trim(),\r\n          coincidencias: encontrados,\r\n        });\r\n      }\r\n    }\r\n\r\n    console.log(\r\n      `Encontradas ${coincidencias.length} coincidencias del patr\xf3n "${patron}"`\r\n    );\r\n    coincidencias.forEach((coincidencia, index) => {\r\n      console.log(\r\n        `${index + 1}. L\xednea ${coincidencia.linea}: ${coincidencia.contenido}`\r\n      );\r\n    });\r\n  });\r\n\r\n  await once(stream, "end");\r\n  return coincidencias;\r\n}\r\n\r\n// EJEMPLO 5: CONTADOR DE PALABRAS EN ARCHIVO GRANDE\r\nasync function contarPalabras(rutaArchivo) {\r\n  const stream = fs.createReadStream(rutaArchivo, {\r\n    encoding: "utf8",\r\n    highWaterMark: 128 * 1024,\r\n  });\r\n\r\n  let totalPalabras = 0;\r\n  let totalLineas = 0;\r\n  let buffer = "";\r\n\r\n  stream.on("data", (chunk) => {\r\n    buffer += chunk;\r\n    const lineas = buffer.split("\\n");\r\n    buffer = lineas.pop() || "";\r\n\r\n    totalLineas += lineas.length;\r\n\r\n    for (const linea of lineas) {\r\n      // Contar palabras (secuencias de caracteres no-espacio)\r\n      const palabras = linea\r\n        .trim()\r\n        .split(/\\s+/)\r\n        .filter((p) => p.length > 0);\r\n      totalPalabras += palabras.length;\r\n    }\r\n  });\r\n\r\n  stream.on("end", () => {\r\n    // Procesar \xfaltima l\xednea\r\n    if (buffer.trim()) {\r\n      totalLineas++;\r\n      const palabras = buffer\r\n        .trim()\r\n        .split(/\\s+/)\r\n        .filter((p) => p.length > 0);\r\n      totalPalabras += palabras.length;\r\n    }\r\n\r\n    console.log(`Estad\xedsticas del archivo:`);\r\n    console.log(`- Total l\xedneas: ${totalLineas}`);\r\n    console.log(`- Total palabras: ${totalPalabras}`);\r\n    console.log(\r\n      `- Promedio palabras por l\xednea: ${(totalPalabras / totalLineas).toFixed(\r\n        2\r\n      )}`\r\n    );\r\n  });\r\n\r\n  await once(stream, "end");\r\n  return { lineas: totalLineas, palabras: totalPalabras };\r\n}\r\n\r\n// EJEMPLO 6: STREAM CON MANEJO DE ERRORES ROBUSTO\r\nasync function leerConManejoErrores(rutaArchivo) {\r\n  const stream = fs.createReadStream(rutaArchivo, {\r\n    encoding: "utf8",\r\n    highWaterMark: 64 * 1024,\r\n  });\r\n\r\n  let chunksProcesados = 0;\r\n  let errores = [];\r\n\r\n  // Manejador de datos\r\n  stream.on("data", (chunk) => {\r\n    try {\r\n      chunksProcesados++;\r\n      // Simular un error ocasional\r\n      if (chunksProcesados === 3) {\r\n        throw new Error("Error simulado en chunk 3");\r\n      }\r\n      console.log(`Chunk ${chunksProcesados} procesado: ${chunk.length} bytes`);\r\n    } catch (error) {\r\n      errores.push({\r\n        chunk: chunksProcesados,\r\n        error: error.message,\r\n      });\r\n      console.error(`Error en chunk ${chunksProcesados}:`, error.message);\r\n    }\r\n  });\r\n\r\n  // Manejador de errores del stream\r\n  stream.on("error", (error) => {\r\n    console.error("Error del stream:", error.message);\r\n    errores.push({ tipo: "stream", error: error.message });\r\n  });\r\n\r\n  stream.on("end", () => {\r\n    console.log(`Procesamiento completado con ${errores.length} errores`);\r\n    if (errores.length > 0) {\r\n      console.log("Errores encontrados:", errores);\r\n    }\r\n  });\r\n\r\n  await once(stream, "end");\r\n  return { chunksProcesados, errores };\r\n}\r\n\r\n// EJEMPLO 7: LECTURA CON PROGRESO EN TIEMPO REAL\r\nasync function leerConProgreso(rutaArchivo) {\r\n  // Primero obtener el tama\xf1o total del archivo\r\n  const stats = await fs.promises.stat(rutaArchivo);\r\n  const tama\xf1oTotal = stats.size;\r\n\r\n  const stream = fs.createReadStream(rutaArchivo, {\r\n    encoding: "utf8",\r\n    highWaterMark: 64 * 1024,\r\n  });\r\n\r\n  let bytesLeidos = 0;\r\n\r\n  stream.on("data", (chunk) => {\r\n    bytesLeidos += chunk.length;\r\n    const porcentaje = ((bytesLeidos / tama\xf1oTotal) * 100).toFixed(1);\r\n    console.log(\r\n      `Progreso: ${porcentaje}% (${bytesLeidos}/${tama\xf1oTotal} bytes)`\r\n    );\r\n  });\r\n\r\n  stream.on("end", () => {\r\n    console.log("\u2705 Lectura completada al 100%");\r\n  });\r\n\r\n  await once(stream, "end");\r\n}\r\n\r\n// EJEMPLO 8: CLASE PARA GESTI\xd3N DE STREAMS\r\nclass GestorStreams {\r\n  constructor() {\r\n    this.streamsActivos = new Map();\r\n  }\r\n\r\n  async leerArchivo(rutaArchivo, opciones = {}) {\r\n    const config = {\r\n      highWaterMark: 64 * 1024,\r\n      encoding: "utf8",\r\n      onData: null,\r\n      onEnd: null,\r\n      onError: null,\r\n      ...opciones,\r\n    };\r\n\r\n    const stream = fs.createReadStream(rutaArchivo, {\r\n      encoding: config.encoding,\r\n      highWaterMark: config.highWaterMark,\r\n    });\r\n\r\n    const streamId = `${rutaArchivo}-${Date.now()}`;\r\n    this.streamsActivos.set(streamId, stream);\r\n\r\n    return new Promise((resolve, reject) => {\r\n      let datosAcumulados = "";\r\n      let chunks = 0;\r\n\r\n      stream.on("data", (chunk) => {\r\n        chunks++;\r\n        datosAcumulados += chunk;\r\n\r\n        if (config.onData) {\r\n          config.onData(chunk, chunks);\r\n        }\r\n      });\r\n\r\n      stream.on("end", () => {\r\n        this.streamsActivos.delete(streamId);\r\n\r\n        if (config.onEnd) {\r\n          config.onEnd(datosAcumulados, chunks);\r\n        }\r\n\r\n        resolve({\r\n          contenido: datosAcumulados,\r\n          totalChunks: chunks,\r\n          tama\xf1o: datosAcumulados.length,\r\n        });\r\n      });\r\n\r\n      stream.on("error", (error) => {\r\n        this.streamsActivos.delete(streamId);\r\n\r\n        if (config.onError) {\r\n          config.onError(error);\r\n        }\r\n\r\n        reject(error);\r\n      });\r\n    });\r\n  }\r\n\r\n  cancelarLectura(rutaArchivo) {\r\n    for (const [id, stream] of this.streamsActivos) {\r\n      if (id.startsWith(rutaArchivo)) {\r\n        stream.destroy();\r\n        this.streamsActivos.delete(id);\r\n        console.log(`Lectura cancelada: ${rutaArchivo}`);\r\n        return true;\r\n      }\r\n    }\r\n    return false;\r\n  }\r\n\r\n  obtenerStreamsActivos() {\r\n    return Array.from(this.streamsActivos.keys());\r\n  }\r\n}\r\n\r\n// EJEMPLO 9: USO DEL GESTOR DE STREAMS\r\nasync function usarGestorStreams() {\r\n  const gestor = new GestorStreams();\r\n\r\n  try {\r\n    const resultado = await gestor.leerArchivo("./archivo-grande.log", {\r\n      highWaterMark: 32 * 1024,\r\n      onData: (chunk, chunkNumber) => {\r\n        console.log(`Procesando chunk ${chunkNumber}: ${chunk.length} bytes`);\r\n      },\r\n      onEnd: (contenido, totalChunks) => {\r\n        console.log(\r\n          `Lectura completada: ${totalChunks} chunks, ${contenido.length} caracteres`\r\n        );\r\n      },\r\n    });\r\n\r\n    console.log("Resultado final:", resultado);\r\n  } catch (error) {\r\n    console.error("Error en gestor de streams:", error.message);\r\n  }\r\n}\r\n\r\n// EJEMPLO 10: COMPARACI\xd3N STREAM vs READFILE\r\nasync function compararMetodos(rutaArchivo) {\r\n  console.log("=== COMPARACI\xd3N: STREAM vs READFILE ===");\r\n\r\n  // M\xe9todo 1: Usando stream (eficiente en memoria)\r\n  console.log("\\n1. Usando Stream:");\r\n  const inicioStream = Date.now();\r\n  const stream = fs.createReadStream(rutaArchivo, { encoding: "utf8" });\r\n\r\n  let chunksStream = 0;\r\n  stream.on("data", () => chunksStream++);\r\n\r\n  await once(stream, "end");\r\n  const tiempoStream = Date.now() - inicioStream;\r\n  console.log(`   Tiempo: ${tiempoStream}ms, Chunks: ${chunksStream}`);\r\n\r\n  // M\xe9todo 2: Usando readFile (carga todo en memoria)\r\n  console.log("\\n2. Usando readFile:");\r\n  const inicioReadFile = Date.now();\r\n\r\n  try {\r\n    const datos = await fs.promises.readFile(rutaArchivo, "utf8");\r\n    const tiempoReadFile = Date.now() - inicioReadFile;\r\n    console.log(\r\n      `   Tiempo: ${tiempoReadFile}ms, Tama\xf1o: ${datos.length} caracteres`\r\n    );\r\n\r\n    console.log("\\nComparaci\xf3n:");\r\n    console.log(\r\n      `   Stream fue ${(tiempoReadFile / tiempoStream).toFixed(2)}x m\xe1s r\xe1pido`\r\n    );\r\n    console.log(\r\n      `   readFile us\xf3 ${(datos.length / 1024 / 1024).toFixed(2)}MB de memoria`\r\n    );\r\n  } catch (error) {\r\n    console.error("Error con readFile:", error.message);\r\n  }\r\n}\r\n\r\n// EJECUCI\xd3N DE EJEMPLOS\r\nasync function ejecutarEjemplos() {\r\n  console.log("=== EJEMPLOS DE STREAMS PARA ARCHIVOS GRANDES ===");\r\n\r\n  // Nota: Necesitar\xedas archivos reales para probar estos ejemplos\r\n  console.log("Estos ejemplos requieren archivos reales para funcionar");\r\n  console.log(\r\n    "Puedes crear archivos de prueba con: echo \'contenido\' > archivo-prueba.log"\r\n  );\r\n\r\n  /*\r\n    // Ejemplos (descomentar cuando tengas archivos de prueba)\r\n    await leerArchivoGrande(\'./archivo-grande.log\');\r\n    await leerConPausa(\'./archivo-grande.log\');\r\n    await buscarPatron(\'./archivo-grande.log\', \'error\');\r\n    await contarPalabras(\'./archivo-grande.log\');\r\n    await leerConProgreso(\'./archivo-grande.log\');\r\n    await usarGestorStreams();\r\n    await compararMetodos(\'./archivo-grande.log\');\r\n    */\r\n}\r\n\r\n// Descomentar para ejecutar\r\n// ejecutarEjemplos();\n'})}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"CARACTER\xcdSTICAS PRINCIPALES EXPLICADAS:"})}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:(0,a.jsx)(n.code,{children:"fs.createReadStream()"})}),": Crea un stream legible para archivos grandes"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:(0,a.jsx)(n.code,{children:"highWaterMark"})}),": Controla el tama\xf1o de cada chunk (64KB en el ejemplo)"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Eventos del stream"}),":\xa0",(0,a.jsx)(n.code,{children:"data"}),",\xa0",(0,a.jsx)(n.code,{children:"end"}),",\xa0",(0,a.jsx)(n.code,{children:"error"}),",\xa0",(0,a.jsx)(n.code,{children:"open"}),",\xa0",(0,a.jsx)(n.code,{children:"close"})]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:(0,a.jsx)(n.code,{children:"once()"})}),": Utilidad para esperar un evento una sola vez"]}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"VENTAJAS DE LOS STREAMS:"})}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Eficiencia en memoria"}),": No carga el archivo completo en RAM"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Procesamiento en tiempo real"}),": Puedes procesar datos mientras se leen"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Control granular"}),": Pausar, reanudar, cancelar la lectura"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Escalabilidad"}),": Maneja archivos de cualquier tama\xf1o"]}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"EVENTOS PRINCIPALES:"})}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:(0,a.jsx)(n.code,{children:"data"})}),": Se dispara cuando hay datos disponibles para procesar"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:(0,a.jsx)(n.code,{children:"end"})}),": Se dispara cuando la lectura se completa"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:(0,a.jsx)(n.code,{children:"error"})}),": Se dispara cuando ocurre un error"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:(0,a.jsx)(n.code,{children:"open"})}),": Se dispara cuando el archivo se abre"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:(0,a.jsx)(n.code,{children:"close"})}),": Se dispara cuando el stream se cierra"]}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"USOS COMUNES:"})}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Procesamiento de logs grandes"}),"\n",(0,a.jsx)(n.li,{children:"An\xe1lisis de datasets extensos"}),"\n",(0,a.jsx)(n.li,{children:"Procesamiento de archivos de video/audio"}),"\n",(0,a.jsx)(n.li,{children:"Streaming de datos en tiempo real"}),"\n",(0,a.jsx)(n.li,{children:"Aplicaciones que necesitan procesamiento incremental"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:"Este c\xf3digo proporciona una base completa para trabajar con streams en Node.js, esencial para aplicaciones que necesitan manejar archivos grandes de manera eficiente."}),"\n",(0,a.jsx)(n.h3,{id:"escritura-con-streams",children:"Escritura con Streams"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-jsx",children:"// Importar el m\xf3dulo de sistema de archivos (versi\xf3n con callbacks)\r\nimport fs from 'fs';\r\n\r\n// Funci\xf3n as\xedncrona para escribir archivos grandes usando streams\r\n// Los streams de escritura son esenciales para generar archivos grandes eficientemente\r\nasync function escribirArchivoGrande(rutaDestino, lineas) {\r\n    return new Promise((resolve, reject) => {\r\n        // Crear stream de escritura\r\n        // fs.createWriteStream() crea un stream escribible que escribe al archivo en chunks\r\n        const streamEscritura = fs.createWriteStream(rutaDestino, {\r\n            encoding: 'utf8'  // Codificaci\xf3n del archivo de salida\r\n            // highWaterMark por defecto es 16KB para streams de escritura\r\n        });\r\n\r\n        // Evento 'finish' - se dispara cuando todos los datos han sido escritos\r\n        // y el stream ha sido cerrado con .end()\r\n        streamEscritura.on('finish', () => {\r\n            console.log('Escritura completada exitosamente');\r\n            resolve();\r\n        });\r\n\r\n        // Evento 'error' - se dispara cuando ocurre un error en la escritura\r\n        streamEscritura.on('error', (error) => {\r\n            console.error('Error en la escritura:', error.message);\r\n            reject(error);\r\n        });\r\n\r\n        // Evento 'open' - se dispara cuando el archivo se abre para escritura\r\n        streamEscritura.on('open', () => {\r\n            console.log(`Archivo abierto para escritura: ${rutaDestino}`);\r\n        });\r\n\r\n        // Evento 'close' - se dispara cuando el stream se cierra\r\n        streamEscritura.on('close', () => {\r\n            console.log('Stream de escritura cerrado');\r\n        });\r\n\r\n        // Escribir datos l\xednea por l\xednea\r\n        let lineasEscritas = 0;\r\n        let drenajesNecesarios = 0;\r\n\r\n        for (const linea of lineas) {\r\n            // streamEscritura.write() retorna false si el buffer interno est\xe1 lleno\r\n            // Esto se conoce como \"backpressure\" - el stream indica que no puede aceptar m\xe1s datos temporalmente\r\n            const puedeContinuar = streamEscritura.write(linea + '\\n');\r\n            lineasEscritas++;\r\n\r\n            // Controlar backpressure - pausar si el buffer est\xe1 lleno\r\n            if (!puedeContinuar) {\r\n                drenajesNecesarios++;\r\n                console.log(`Backpressure detectado en l\xednea ${lineasEscritas}. Esperando drenaje...`);\r\n\r\n                // Esperar a que el buffer se vac\xede (evento 'drain')\r\n                // El evento 'drain' se emite cuando el buffer interno se ha vaciado\r\n                // y el stream puede aceptar m\xe1s datos\r\n                streamEscritura.once('drain', () => {\r\n                    console.log(`Drenaje completado (${drenajesNecesarios}). Continuando escritura...`);\r\n                });\r\n            }\r\n        }\r\n\r\n        // Indicar que no hay m\xe1s datos por escribir\r\n        // Esto es esencial - sin .end() el stream nunca emitir\xe1 'finish'\r\n        streamEscritura.end();\r\n\r\n        console.log(`Total l\xedneas enviadas: ${lineasEscritas}`);\r\n        console.log(`Drenajes necesarios: ${drenajesNecesarios}`);\r\n\r\n    });\r\n}\r\n\r\n// Ejemplo de uso\r\nconst lineas = Array.from({ length: 10000 }, (_, i) => `L\xednea ${i + 1}`);\r\nescribirArchivoGrande('./archivo-grande-salida.txt', lineas);\r\n\r\n// EJEMPLOS ADICIONALES Y EXPLICACIONES DETALLADAS:\r\n\r\n// EJEMPLO 1: ESCRITURA CON HIGHWATERMARK PERSONALIZADO\r\nasync function escribirConHighWaterMark(rutaDestino, datos) {\r\n    return new Promise((resolve, reject) => {\r\n        const streamEscritura = fs.createWriteStream(rutaDestino, {\r\n            encoding: 'utf8',\r\n            highWaterMark: 8 * 1024 // 8KB - buffer m\xe1s peque\xf1o para backpressure m\xe1s frecuente\r\n        });\r\n\r\n        let bytesEscritos = 0;\r\n        let drenajes = 0;\r\n\r\n        streamEscritura.on('finish', () => {\r\n            console.log(`Escritura completada: ${bytesEscritos} bytes, ${drenajes} drenajes`);\r\n            resolve();\r\n        });\r\n\r\n        streamEscritura.on('error', reject);\r\n\r\n        for (const dato of datos) {\r\n            const datoConSalto = dato + '\\n';\r\n            bytesEscritos += Buffer.byteLength(datoConSalto, 'utf8');\r\n\r\n            const puedeContinuar = streamEscritura.write(datoConSalto);\r\n\r\n            if (!puedeContinuar) {\r\n                drenajes++;\r\n                streamEscritura.once('drain', () => {\r\n                    console.log(`Drenaje ${drenajes} completado`);\r\n                });\r\n            }\r\n        }\r\n\r\n        streamEscritura.end();\r\n    });\r\n}\r\n\r\n// EJEMPLO 2: ESCRITURA CON GENERADOR DE DATOS AS\xcdNCRONO\r\nasync function escribirDesdeGenerador(rutaDestino, generadorDatos) {\r\n    return new Promise((resolve, reject) => {\r\n        const streamEscritura = fs.createWriteStream(rutaDestino, {\r\n            encoding: 'utf8'\r\n        });\r\n\r\n        let escriturasPendientes = 0;\r\n        let completado = false;\r\n\r\n        async function escribirSiguiente() {\r\n            const { value: dato, done } = await generadorDatos.next();\r\n\r\n            if (done) {\r\n                completado = true;\r\n                // Esperar a que todas las escrituras pendientes terminen\r\n                if (escriturasPendientes === 0) {\r\n                    streamEscritura.end();\r\n                }\r\n                return;\r\n            }\r\n\r\n            escriturasPendientes++;\r\n            const puedeContinuar = streamEscritura.write(dato + '\\n');\r\n\r\n            if (!puedeContinuar) {\r\n                await new Promise(resolve => {\r\n                    streamEscritura.once('drain', () => {\r\n                        escriturasPendientes--;\r\n                        resolve();\r\n                    });\r\n                });\r\n            } else {\r\n                escriturasPendientes--;\r\n            }\r\n\r\n            // Escribir siguiente dato\r\n            escribirSiguiente();\r\n        }\r\n\r\n        streamEscritura.on('finish', resolve);\r\n        streamEscritura.on('error', reject);\r\n\r\n        // Iniciar el proceso de escritura\r\n        escribirSiguiente();\r\n    });\r\n}\r\n\r\n// EJEMPLO 3: ESCRITURA CON TRANSFORMACI\xd3N DE DATOS\r\nimport { Transform } from 'stream';\r\n\r\nasync function escribirConTransformacion(rutaDestino, datos) {\r\n    return new Promise((resolve, reject) => {\r\n        // Crear un stream de transformaci\xf3n personalizado\r\n        const transformador = new Transform({\r\n            transform(chunk, encoding, callback) {\r\n                // Transformar datos - en este caso, convertir a JSON\r\n                try {\r\n                    const datoTransformado = JSON.stringify({\r\n                        timestamp: new Date().toISOString(),\r\n                        data: chunk.toString().trim(),\r\n                        length: chunk.length\r\n                    }) + '\\n';\r\n                    this.push(datoTransformado);\r\n                    callback();\r\n                } catch (error) {\r\n                    callback(error);\r\n                }\r\n            }\r\n        });\r\n\r\n        const streamEscritura = fs.createWriteStream(rutaDestino, {\r\n            encoding: 'utf8'\r\n        });\r\n\r\n        // Conectar los streams\r\n        transformador.pipe(streamEscritura);\r\n\r\n        streamEscritura.on('finish', () => {\r\n            console.log('Escritura con transformaci\xf3n completada');\r\n            resolve();\r\n        });\r\n\r\n        streamEscritura.on('error', reject);\r\n        transformador.on('error', reject);\r\n\r\n        // Escribir datos a trav\xe9s del transformador\r\n        for (const dato of datos) {\r\n            transformador.write(dato);\r\n        }\r\n\r\n        transformador.end();\r\n    });\r\n}\r\n\r\n// EJEMPLO 4: ESCRITURA CON COMPRESI\xd3N\r\nimport zlib from 'zlib';\r\n\r\nasync function escribirComprimido(rutaDestino, datos) {\r\n    return new Promise((resolve, reject) => {\r\n        const streamEscritura = fs.createWriteStream(rutaDestino);\r\n        const compresor = zlib.createGzip(); // Compresor GZIP\r\n\r\n        let datosOriginales = 0;\r\n        let datosComprimidos = 0;\r\n\r\n        compresor.on('data', (chunk) => {\r\n            datosComprimidos += chunk.length;\r\n        });\r\n\r\n        // Pipe: compresor -> escritura\r\n        compresor.pipe(streamEscritura);\r\n\r\n        streamEscritura.on('finish', () => {\r\n            const ratio = ((1 - datosComprimidos / datosOriginales) * 100).toFixed(1);\r\n            console.log(`Compresi\xf3n completada: ${datosOriginales} -> ${datosComprimidos} bytes (${ratio}% reducci\xf3n)`);\r\n            resolve();\r\n        });\r\n\r\n        streamEscritura.on('error', reject);\r\n        compresor.on('error', reject);\r\n\r\n        // Escribir datos al compresor\r\n        for (const dato of datos) {\r\n            const buffer = Buffer.from(dato + '\\n', 'utf8');\r\n            datosOriginales += buffer.length;\r\n            compresor.write(buffer);\r\n        }\r\n\r\n        compresor.end();\r\n    });\r\n}\r\n\r\n// EJEMPLO 5: ESCRITURA CON VALIDACI\xd3N Y REINTENTOS\r\nasync function escribirConReintentos(rutaDestino, datos, maxReintentos = 3) {\r\n    let reintentos = 0;\r\n\r\n    while (reintentos <= maxReintentos) {\r\n        try {\r\n            await escribirConValidacion(rutaDestino, datos);\r\n            console.log('Escritura exitosa');\r\n            return;\r\n        } catch (error) {\r\n            reintentos++;\r\n            console.error(`Intento ${reintentos} fallado:`, error.message);\r\n\r\n            if (reintentos > maxReintentos) {\r\n                throw new Error(`Fallo despu\xe9s de ${maxReintentos} reintentos: ${error.message}`);\r\n            }\r\n\r\n            // Esperar antes de reintentar (backoff exponencial)\r\n            await new Promise(resolve => setTimeout(resolve, 1000 * reintentos));\r\n            console.log(`Reintentando escritura (intento ${reintentos + 1})...`);\r\n        }\r\n    }\r\n}\r\n\r\nasync function escribirConValidacion(rutaDestino, datos) {\r\n    return new Promise((resolve, reject) => {\r\n        const streamEscritura = fs.createWriteStream(rutaDestino, {\r\n            encoding: 'utf8'\r\n        });\r\n\r\n        let bytesPrometidos = 0;\r\n        let errores = [];\r\n\r\n        streamEscritura.on('finish', async () => {\r\n            // Validar que el archivo se escribi\xf3 correctamente\r\n            try {\r\n                const stats = await fs.promises.stat(rutaDestino);\r\n                if (stats.size === 0) {\r\n                    throw new Error('Archivo creado pero vac\xedo');\r\n                }\r\n                console.log(`Validaci\xf3n exitosa: ${stats.size} bytes escritos`);\r\n                resolve();\r\n            } catch (error) {\r\n                reject(new Error(`Validaci\xf3n fallida: ${error.message}`));\r\n            }\r\n        });\r\n\r\n        streamEscritura.on('error', reject);\r\n\r\n        for (const dato of datos) {\r\n            try {\r\n                // Validar dato antes de escribir\r\n                if (typeof dato !== 'string') {\r\n                    throw new Error(`Dato inv\xe1lido: ${typeof dato}`);\r\n                }\r\n\r\n                const datoParaEscribir = dato + '\\n';\r\n                bytesPrometidos += Buffer.byteLength(datoParaEscribir, 'utf8');\r\n\r\n                const puedeContinuar = streamEscritura.write(datoParaEscribir);\r\n\r\n                if (!puedeContinuar) {\r\n                    await new Promise(resolve => {\r\n                        streamEscritura.once('drain', resolve);\r\n                    });\r\n                }\r\n            } catch (error) {\r\n                errores.push(error.message);\r\n                console.error('Error validando dato:', error.message);\r\n            }\r\n        }\r\n\r\n        if (errores.length > 0) {\r\n            console.warn(`${errores.length} errores de validaci\xf3n durante la escritura`);\r\n        }\r\n\r\n        streamEscritura.end();\r\n    });\r\n}\r\n\r\n// EJEMPLO 6: CLASE PARA GESTI\xd3N DE ESCRITURA DE STREAMS\r\nclass GestorEscrituraStreams {\r\n    constructor() {\r\n        this.streamsActivos = new Map();\r\n        this.estadisticas = new Map();\r\n    }\r\n\r\n    async escribirArchivo(rutaDestino, datos, opciones = {}) {\r\n        const config = {\r\n            highWaterMark: 16 * 1024,\r\n            encoding: 'utf8',\r\n            comprimir: false,\r\n            transformar: null,\r\n            ...opciones\r\n        };\r\n\r\n        return new Promise((resolve, reject) => {\r\n            const streamEscritura = fs.createWriteStream(rutaDestino, {\r\n                encoding: config.encoding,\r\n                highWaterMark: config.highWaterMark\r\n            });\r\n\r\n            const streamId = `${rutaDestino}-${Date.now()}`;\r\n            this.streamsActivos.set(streamId, streamEscritura);\r\n\r\n            const estadisticas = {\r\n                inicio: new Date(),\r\n                datosEscritos: 0,\r\n                drenajes: 0,\r\n                lineasEscritas: 0\r\n            };\r\n            this.estadisticas.set(streamId, estadisticas);\r\n\r\n            streamEscritura.on('finish', () => {\r\n                estadisticas.fin = new Date();\r\n                estadisticas.duracion = estadisticas.fin - estadisticas.inicio;\r\n                this.streamsActivos.delete(streamId);\r\n\r\n                console.log(`Escritura completada: ${estadisticas.lineasEscritas} l\xedneas, ${estadisticas.drenajes} drenajes`);\r\n                resolve(estadisticas);\r\n            });\r\n\r\n            streamEscritura.on('error', (error) => {\r\n                this.streamsActivos.delete(streamId);\r\n                this.estadisticas.delete(streamId);\r\n                reject(error);\r\n            });\r\n\r\n            // Escribir datos\r\n            for (const dato of datos) {\r\n                let datoParaEscribir = dato;\r\n\r\n                // Aplicar transformaci\xf3n si se especifica\r\n                if (config.transformar && typeof config.transformar === 'function') {\r\n                    datoParaEscribir = config.transformar(dato);\r\n                }\r\n\r\n                const lineaCompleta = datoParaEscribir + '\\n';\r\n                estadisticas.datosEscritos += Buffer.byteLength(lineaCompleta, 'utf8');\r\n                estadisticas.lineasEscritas++;\r\n\r\n                const puedeContinuar = streamEscritura.write(lineaCompleta);\r\n\r\n                if (!puedeContinuar) {\r\n                    estadisticas.drenajes++;\r\n                    streamEscritura.once('drain', () => {\r\n                        console.log(`Drenaje ${estadisticas.drenajes} completado para ${streamId}`);\r\n                    });\r\n                }\r\n            }\r\n\r\n            streamEscritura.end();\r\n        });\r\n    }\r\n\r\n    cancelarEscritura(rutaDestino) {\r\n        for (const [id, stream] of this.streamsActivos) {\r\n            if (id.startsWith(rutaDestino)) {\r\n                stream.destroy();\r\n                this.streamsActivos.delete(id);\r\n                const stats = this.estadisticas.get(id);\r\n                this.estadisticas.delete(id);\r\n                console.log(`Escritura cancelada: ${rutaDestino} (${stats?.lineasEscritas} l\xedneas escritas)`);\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    obtenerEstadisticas() {\r\n        return Array.from(this.estadisticas.entries()).map(([id, stats]) => ({\r\n            id,\r\n            ...stats\r\n        }));\r\n    }\r\n}\r\n\r\n// EJEMPLO 7: ESCRITURA CON PROGRESO EN TIEMPO REAL\r\nasync function escribirConProgreso(rutaDestino, datos) {\r\n    return new Promise((resolve, reject) => {\r\n        const streamEscritura = fs.createWriteStream(rutaDestino, {\r\n            encoding: 'utf8'\r\n        });\r\n\r\n        const totalDatos = datos.length;\r\n        let datosEscritos = 0;\r\n        let ultimoProgreso = 0;\r\n\r\n        function actualizarProgreso() {\r\n            datosEscritos++;\r\n            const progreso = Math.floor((datosEscritos / totalDatos) * 100);\r\n\r\n            // Solo mostrar cuando el progreso cambia significativamente\r\n            if (progreso !== ultimoProgreso && progreso % 10 === 0) {\r\n                console.log(`Progreso: ${progreso}% (${datosEscritos}/${totalDatos})`);\r\n                ultimoProgreso = progreso;\r\n            }\r\n        }\r\n\r\n        streamEscritura.on('finish', () => {\r\n            console.log('\u2705 Escritura completada al 100%');\r\n            resolve();\r\n        });\r\n\r\n        streamEscritura.on('error', reject);\r\n\r\n        for (const dato of datos) {\r\n            const puedeContinuar = streamEscritura.write(dato + '\\n');\r\n            actualizarProgreso();\r\n\r\n            if (!puedeContinuar) {\r\n                streamEscritura.once('drain', () => {\r\n                    console.log('Buffer drenado, continuando...');\r\n                });\r\n            }\r\n        }\r\n\r\n        streamEscritura.end();\r\n    });\r\n}\r\n\r\n// EJEMPLO 8: ESCRITURA CONCATENANDO M\xdaLTIPLES FUENTES\r\nasync function escribirDesdeMultiplesFuentes(rutaDestino, fuentesDeDatos) {\r\n    return new Promise((resolve, reject) => {\r\n        const streamEscritura = fs.createWriteStream(rutaDestino, {\r\n            encoding: 'utf8'\r\n        });\r\n\r\n        let fuentesCompletadas = 0;\r\n        let lineasTotales = 0;\r\n\r\n        streamEscritura.on('finish', () => {\r\n            console.log(`Escritura completada: ${fuentesCompletadas} fuentes, ${lineasTotales} l\xedneas`);\r\n            resolve();\r\n        });\r\n\r\n        streamEscritura.on('error', reject);\r\n\r\n        async function escribirFuente(fuente) {\r\n            for await (const dato of fuente) {\r\n                const puedeContinuar = streamEscritura.write(dato + '\\n');\r\n                lineasTotales++;\r\n\r\n                if (!puedeContinuar) {\r\n                    await new Promise(resolve => {\r\n                        streamEscritura.once('drain', resolve);\r\n                    });\r\n                }\r\n            }\r\n            fuentesCompletadas++;\r\n        }\r\n\r\n        // Escribir todas las fuentes en paralelo\r\n        Promise.all(fuentesDeDatos.map(escribirFuente))\r\n            .then(() => streamEscritura.end())\r\n            .catch(reject);\r\n    });\r\n}\r\n\r\n// EJEMPLO 9: ESCRITURA CON L\xcdMITE DE VELOCIDAD\r\nasync function escribirConThrottling(rutaDestino, datos, bytesPorSegundo = 10240) { // 10KB/s\r\n    return new Promise((resolve, reject) => {\r\n        const streamEscritura = fs.createWriteStream(rutaDestino, {\r\n            encoding: 'utf8'\r\n        });\r\n\r\n        let bytesEscritos = 0;\r\n        let inicio = Date.now();\r\n        let indice = 0;\r\n\r\n        function escribirSiguiente() {\r\n            if (indice >= datos.length) {\r\n                streamEscritura.end();\r\n                return;\r\n            }\r\n\r\n            const dato = datos[indice];\r\n            const datoConSalto = dato + '\\n';\r\n            const bytesDato = Buffer.byteLength(datoConSalto, 'utf8');\r\n\r\n            // Calcular si necesitamos esperar para mantener el l\xedmite de velocidad\r\n            const tiempoTranscurrido = Date.now() - inicio;\r\n            const tiempoEsperado = (bytesEscritos / bytesPorSegundo) * 1000;\r\n\r\n            if (tiempoTranscurrido < tiempoEsperado) {\r\n                const espera = tiempoEsperado - tiempoTranscurrido;\r\n                setTimeout(escribirSiguiente, espera);\r\n                return;\r\n            }\r\n\r\n            const puedeContinuar = streamEscritura.write(datoConSalto);\r\n            bytesEscritos += bytesDato;\r\n            indice++;\r\n\r\n            if (!puedeContinuar) {\r\n                streamEscritura.once('drain', escribirSiguiente);\r\n            } else {\r\n                setImmediate(escribirSiguiente);\r\n            }\r\n        }\r\n\r\n        streamEscritura.on('finish', () => {\r\n            const duracion = (Date.now() - inicio) / 1000;\r\n            const velocidad = (bytesEscritos / duracion / 1024).toFixed(2);\r\n            console.log(`Escritura throttled completada: ${velocidad} KB/s`);\r\n            resolve();\r\n        });\r\n\r\n        streamEscritura.on('error', reject);\r\n\r\n        // Iniciar el proceso\r\n        escribirSiguiente();\r\n    });\r\n}\r\n\r\n// EJEMPLO 10: COMPARACI\xd3N STREAM vs WRITEFILE\r\nasync function compararMetodosEscritura(rutaDestino, datos) {\r\n    console.log('=== COMPARACI\xd3N: STREAM vs WRITEFILE ===');\r\n\r\n    // M\xe9todo 1: Usando stream (eficiente en memoria)\r\n    console.log('\\n1. Usando Stream:');\r\n    const inicioStream = Date.now();\r\n\r\n    await new Promise((resolve, reject) => {\r\n        const stream = fs.createWriteStream(rutaDestino + '.stream', { encoding: 'utf8' });\r\n\r\n        for (const dato of datos) {\r\n            stream.write(dato + '\\n');\r\n        }\r\n\r\n        stream.end();\r\n        stream.on('finish', resolve);\r\n        stream.on('error', reject);\r\n    });\r\n\r\n    const tiempoStream = Date.now() - inicioStream;\r\n    console.log(`   Tiempo: ${tiempoStream}ms`);\r\n\r\n    // M\xe9todo 2: Usando writeFile (concatena todo en memoria primero)\r\n    console.log('\\n2. Usando writeFile:');\r\n    const inicioWriteFile = Date.now();\r\n\r\n    try {\r\n        const contenido = datos.map(dato => dato + '\\n').join('');\r\n        await fs.promises.writeFile(rutaDestino + '.writefile', contenido, 'utf8');\r\n        const tiempoWriteFile = Date.now() - inicioWriteFile;\r\n\r\n        console.log(`   Tiempo: ${tiempoWriteFile}ms`);\r\n        console.log(`   Memoria usada: ${(Buffer.byteLength(contenido, 'utf8') / 1024 / 1024).toFixed(2)}MB`);\r\n\r\n        console.log('\\nComparaci\xf3n:');\r\n        const ratio = tiempoWriteFile / tiempoStream;\r\n        console.log(`   Stream fue ${ratio.toFixed(2)}x ${ratio > 1 ? 'm\xe1s r\xe1pido' : 'm\xe1s lento'}`);\r\n\r\n    } catch (error) {\r\n        console.error('Error con writeFile:', error.message);\r\n    }\r\n}\r\n\r\n// EJECUCI\xd3N DE EJEMPLOS\r\nasync function ejecutarEjemplos() {\r\n    console.log(\"=== EJEMPLOS DE ESCRITURA CON STREAMS ===\");\r\n\r\n    const datosPrueba = Array.from({ length: 1000 }, (_, i) => `Dato de prueba ${i + 1}`);\r\n\r\n    // Ejemplo b\xe1sico\r\n    await escribirArchivoGrande('./ejemplo-stream.txt', datosPrueba.slice(0, 100));\r\n\r\n    // Ejemplos avanzados\r\n    await escribirConHighWaterMark('./ejemplo-highwatermark.txt', datosPrueba.slice(0, 50));\r\n    await escribirConProgreso('./ejemplo-progreso.txt', datosPrueba);\r\n\r\n    // Usar gestor de streams\r\n    const gestor = new GestorEscrituraStreams();\r\n    await gestor.escribirArchivo('./ejemplo-gestor.txt', datosPrueba, {\r\n        transformar: (dato) => `TRANSFORMADO: ${dato.toUpperCase()}`\r\n    });\r\n\r\n    console.log('Estad\xedsticas del gestor:', gestor.obtenerEstadisticas());\r\n\r\n    // Comparaci\xf3n de m\xe9todos\r\n    await compararMetodosEscritura('./comparacion', datosPrueba);\r\n\r\n    // Limpiar archivos de ejemplo\r\n    try {\r\n        await fs.promises.unlink('./ejemplo-stream.txt');\r\n        await fs.promises.unlink('./ejemplo-highwatermark.txt');\r\n        await fs.promises.unlink('./ejemplo-progreso.txt');\r\n        await fs.promises.unlink('./ejemplo-gestor.txt');\r\n        await fs.promises.unlink('./comparacion.stream');\r\n        await fs.promises.unlink('./comparacion.writefile');\r\n    } catch (error) {\r\n        // Ignorar errores de limpieza\r\n    }\r\n}\r\n\r\n// Descomentar para ejecutar\r\n// ejecutarEjemplos();\n"})}),"\n",(0,a.jsx)(n.h2,{id:"conclusi\xf3n",children:"Conclusi\xf3n"}),"\n",(0,a.jsxs)(n.p,{children:["El m\xf3dulo de sistema de archivos de Node.js con ES Modules proporciona una API poderosa y moderna para trabajar con archivos y directorios. Las operaciones basadas en promesas permiten un c\xf3digo m\xe1s limpio y legible usando ",(0,a.jsx)(n.code,{children:"async/await"}),"."]}),"\n",(0,a.jsx)(n.p,{children:"Los conceptos clave cubiertos incluyen:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Lectura y escritura de archivos de texto y binarios"}),"\n",(0,a.jsx)(n.li,{children:"Operaciones con directorios (creaci\xf3n, listado, eliminaci\xf3n)"}),"\n",(0,a.jsxs)(n.li,{children:["Uso del m\xf3dulo ",(0,a.jsx)(n.code,{children:"path"})," para manejo seguro de rutas"]}),"\n",(0,a.jsx)(n.li,{children:"Trabajo eficiente con archivos grandes mediante streams"}),"\n",(0,a.jsx)(n.li,{children:"Operaciones avanzadas como copia, movimiento y cambio de permisos"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:"Este conocimiento forma la base para construir aplicaciones que necesitan interactuar con el sistema de archivos, como herramientas de l\xednea de comandos, procesadores de datos, servidores de archivos y sistemas de backup."})]})}function u(r={}){const{wrapper:n}={...(0,s.R)(),...r.components};return n?(0,a.jsx)(n,{...r,children:(0,a.jsx)(d,{...r})}):d(r)}},8453:(r,n,e)=>{e.d(n,{R:()=>i,x:()=>t});var o=e(6540);const a={},s=o.createContext(a);function i(r){const n=o.useContext(s);return o.useMemo(function(){return"function"==typeof r?r(n):{...n,...r}},[n,r])}function t(r){let n;return n=r.disableParentContext?"function"==typeof r.components?r.components(a):r.components||a:i(r.components),o.createElement(s.Provider,{value:n},r.children)}}}]);