"use strict";(globalThis.webpackChunkDocuQuest_oslar_code=globalThis.webpackChunkDocuQuest_oslar_code||[]).push([[3786],{7457:(e,n,o)=>{o.r(n),o.d(n,{assets:()=>l,contentTitle:()=>c,default:()=>u,frontMatter:()=>i,metadata:()=>r,toc:()=>t});const r=JSON.parse('{"id":"backend/Node.js/asincronia","title":"Asincron\xeda en Node.js ES Modules","description":"\xbfPor qu\xe9 es tan importante la asincron\xeda en Node.js?","source":"@site/docs/backend/Node.js/asincronia.md","sourceDirName":"backend/Node.js","slug":"/backend/Node.js/asincronia","permalink":"/docuQuest/docs/backend/Node.js/asincronia","draft":false,"unlisted":false,"editUrl":"https://github.com/OslarCode/OslarCode/docs/backend/Node.js/asincronia.md","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Manejo de procesos del sistema en Node.js ES Modules","permalink":"/docuQuest/docs/backend/Node.js/manejoDeProcesos"},"next":{"title":"Servidores Web con Node.js y ES Modules","permalink":"/docuQuest/docs/backend/Node.js/servidorWeb"}}');var a=o(4848),s=o(8453);const i={},c="Asincron\xeda en Node.js ES Modules",l={},t=[{value:"\xbfPor qu\xe9 es tan importante la asincron\xeda en Node.js?",id:"por-qu\xe9-es-tan-importante-la-asincron\xeda-en-nodejs",level:2},{value:"Configuraci\xf3n inicial para ES Modules",id:"configuraci\xf3n-inicial-para-es-modules",level:2},{value:"Callback: el punto de partida",id:"callback-el-punto-de-partida",level:2},{value:"El problema del &quot;callback hell&quot; y c\xf3mo identificarlo",id:"el-problema-del-callback-hell-y-c\xf3mo-identificarlo",level:2},{value:"Promesas: una evoluci\xf3n natural",id:"promesas-una-evoluci\xf3n-natural",level:2},{value:"Promesas con el m\xf3dulo fs/promises",id:"promesas-con-el-m\xf3dulo-fspromises",level:3},{value:"Encadenamiento de promesas",id:"encadenamiento-de-promesas",level:3},{value:"M\xfaltiples promesas simult\xe1neas",id:"m\xfaltiples-promesas-simult\xe1neas",level:3},{value:"Async/Await: la evoluci\xf3n moderna",id:"asyncawait-la-evoluci\xf3n-moderna",level:2},{value:"Sintaxis b\xe1sica de async/await",id:"sintaxis-b\xe1sica-de-asyncawait",level:3},{value:"M\xfaltiples operaciones con async/await",id:"m\xfaltiples-operaciones-con-asyncawait",level:3},{value:"Operaciones paralelas con async/await",id:"operaciones-paralelas-con-asyncawait",level:3},{value:"\xbfC\xf3mo funciona el Event Loop en Node.js?",id:"c\xf3mo-funciona-el-event-loop-en-nodejs",level:2},{value:"Fases del Event Loop:",id:"fases-del-event-loop",level:3},{value:"Ejemplo pr\xe1ctico del Event Loop",id:"ejemplo-pr\xe1ctico-del-event-loop",level:3},{value:"Ejercicio pr\xe1ctico: Gestor de archivos as\xedncrono",id:"ejercicio-pr\xe1ctico-gestor-de-archivos-as\xedncrono",level:2},{value:"Patrones avanzados y mejores pr\xe1cticas",id:"patrones-avanzados-y-mejores-pr\xe1cticas",level:2},{value:"1. Manejo robusto de errores",id:"1-manejo-robusto-de-errores",level:3},{value:"2. Limitaci\xf3n de operaciones concurrentes",id:"2-limitaci\xf3n-de-operaciones-concurrentes",level:3},{value:"Conclusi\xf3n del m\xf3dulo",id:"conclusi\xf3n-del-m\xf3dulo",level:2},{value:"Recursos complementarios",id:"recursos-complementarios",level:2}];function d(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.header,{children:(0,a.jsx)(n.h1,{id:"asincron\xeda-en-nodejs-es-modules",children:"Asincron\xeda en Node.js ES Modules"})}),"\n",(0,a.jsx)(n.h2,{id:"por-qu\xe9-es-tan-importante-la-asincron\xeda-en-nodejs",children:"\xbfPor qu\xe9 es tan importante la asincron\xeda en Node.js?"}),"\n",(0,a.jsxs)(n.p,{children:["Node.js fue dise\xf1ado para ser ",(0,a.jsx)(n.strong,{children:"r\xe1pido y eficiente"}),", pero no porque tenga m\xfaltiples hilos como otros lenguajes. Lo que lo hace especial es su capacidad para ",(0,a.jsx)(n.strong,{children:"hacer muchas cosas al mismo tiempo sin bloquearse"}),", gracias a un modelo de ejecuci\xf3n basado en eventos y asincron\xeda."]}),"\n",(0,a.jsxs)(n.p,{children:["Este m\xf3dulo te ense\xf1ar\xe1 c\xf3mo funcionan los ",(0,a.jsx)(n.strong,{children:"callbacks"}),", las ",(0,a.jsx)(n.strong,{children:"promesas"})," y el sistema de ejecuci\xf3n conocido como ",(0,a.jsx)(n.strong,{children:"event loop"}),". Tambi\xe9n aprender\xe1s a trabajar con funciones as\xedncronas modernas como ",(0,a.jsx)(n.code,{children:"async/await"})," de forma clara y progresiva, usando la sintaxis moderna de ES Modules."]}),"\n",(0,a.jsx)(n.h2,{id:"configuraci\xf3n-inicial-para-es-modules",children:"Configuraci\xf3n inicial para ES Modules"}),"\n",(0,a.jsx)(n.p,{children:"Para seguir este m\xf3dulo, aseg\xfarate de tener configurado ES Modules en tu proyecto:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-json",children:'// package.json\n{\n  "name": "asincronia-node",\n  "type": "module",\n  "scripts": {\n    "dev": "node --watch ejemplos/callbacks.js"\n  }\n}\n'})}),"\n",(0,a.jsx)(n.h2,{id:"callback-el-punto-de-partida",children:"Callback: el punto de partida"}),"\n",(0,a.jsxs)(n.p,{children:["En Node.js, muchas funciones que acceden al sistema (como leer un archivo) ",(0,a.jsx)(n.strong,{children:"no se ejecutan inmediatamente"}),", sino que ",(0,a.jsx)(n.strong,{children:"se programan para ejecutarse despu\xe9s"}),". Esto se hace mediante callbacks: funciones que se ejecutan cuando otra tarea termina."]}),"\n",(0,a.jsx)(n.p,{children:"Veamos un ejemplo pr\xe1ctico leyendo un archivo de forma as\xedncrona con ES Modules:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-jsx",children:'// ejemplos/lectura-callback.js\nimport { readFile } from "fs";\n\n// Lectura de archivo con callback tradicional\nreadFile("ejemplo.txt", "utf8", (error, datos) => {\n  if (error) {\n    console.error("Error al leer el archivo:", error.message);\n    return;\n  }\n  console.log("Contenido del archivo:", datos);\n});\n\nconsole.log("Archivo solicitado. Esperando resultados...");\n// Esta l\xednea se ejecuta inmediatamente, antes de que el archivo se lea\n'})}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Caracter\xedsticas importantes de los callbacks:"})}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"No bloquean el hilo principal"}),"\n",(0,a.jsx)(n.li,{children:'Reciben error como primer par\xe1metro (convenci\xf3n "error-first")'}),"\n",(0,a.jsx)(n.li,{children:"Se ejecutan cuando la operaci\xf3n as\xedncrona finaliza"}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"el-problema-del-callback-hell-y-c\xf3mo-identificarlo",children:'El problema del "callback hell" y c\xf3mo identificarlo'}),"\n",(0,a.jsxs)(n.p,{children:["Aunque los callbacks son fundamentales, cuando los anidas demasiado se vuelven dif\xedciles de leer y mantener. A esto se le llama ",(0,a.jsx)(n.strong,{children:"callback hell"}),' o "pir\xe1mide de la muerte".']}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-jsx",children:'// ejemplos/callback-hell.js\nimport { readFile } from "fs";\n\n// Ejemplo de callback hell - EVITAR ESTE PATR\xd3N\nreadFile("uno.txt", "utf8", (err1, data1) => {\n  if (err1) {\n    console.error("Error leyendo uno.txt:", err1);\n    return;\n  }\n\n  readFile("dos.txt", "utf8", (err2, data2) => {\n    if (err2) {\n      console.error("Error leyendo dos.txt:", err2);\n      return;\n    }\n\n    readFile("tres.txt", "utf8", (err3, data3) => {\n      if (err3) {\n        console.error("Error leyendo tres.txt:", err3);\n        return;\n      }\n\n      console.log("Todos los archivos le\xeddos:");\n      console.log("Uno:", data1);\n      console.log("Dos:", data2);\n      console.log("Tres:", data3);\n    });\n  });\n});\n'})}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Problemas del callback hell:"})}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"C\xf3digo dif\xedcil de leer y mantener"}),"\n",(0,a.jsx)(n.li,{children:"Manejo repetitivo de errores"}),"\n",(0,a.jsx)(n.li,{children:"Dificultad para depurar"}),"\n",(0,a.jsx)(n.li,{children:"Complicado agregar nuevas funcionalidades"}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"promesas-una-evoluci\xf3n-natural",children:"Promesas: una evoluci\xf3n natural"}),"\n",(0,a.jsx)(n.p,{children:"Las promesas son objetos que representan el resultado eventual (\xe9xito o fracaso) de una operaci\xf3n as\xedncrona. Proporcionan una alternativa m\xe1s limpia y manejable a los callbacks."}),"\n",(0,a.jsx)(n.h3,{id:"promesas-con-el-m\xf3dulo-fspromises",children:"Promesas con el m\xf3dulo fs/promises"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-jsx",children:'// ejemplos/promesas-basicas.js\nimport { readFile } from "fs/promises";\n\n// Lectura con promesas usando .then() y .catch()\nreadFile("ejemplo.txt", "utf8")\n  .then((datos) => {\n    console.log("Contenido del archivo:", datos);\n    return datos.length; // Puedes encadenar operaciones\n  })\n  .then((longitud) => {\n    console.log("Longitud del contenido:", longitud);\n  })\n  .catch((error) => {\n    console.error("Error al leer el archivo:", error.message);\n  });\n\nconsole.log("Leyendo archivo con promesas...");\n'})}),"\n",(0,a.jsx)(n.h3,{id:"encadenamiento-de-promesas",children:"Encadenamiento de promesas"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-jsx",children:'// ejemplos/encadenamiento-promesas.js\nimport { readFile, writeFile } from "fs/promises";\n\nfunction procesarArchivos() {\n  return readFile("origen.txt", "utf8")\n    .then((contenido) => {\n      console.log("Archivo le\xeddo, procesando...");\n      const contenidoProcesado = contenido.toUpperCase();\n      return writeFile("destino.txt", contenidoProcesado);\n    })\n    .then(() => {\n      console.log("Archivo procesado y guardado exitosamente");\n      return readFile("destino.txt", "utf8");\n    })\n    .then((contenidoFinal) => {\n      console.log("Contenido final:", contenidoFinal);\n    })\n    .catch((error) => {\n      console.error("Error en el proceso:", error.message);\n    });\n}\n\nprocesarArchivos();\n'})}),"\n",(0,a.jsx)(n.h3,{id:"m\xfaltiples-promesas-simult\xe1neas",children:"M\xfaltiples promesas simult\xe1neas"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-jsx",children:'// ejemplos/promesas-paralelas.js\nimport { readFile } from "fs/promises";\n\n// Promise.all - ejecuta m\xfaltiples promesas en paralelo\nPromise.all([\n  readFile("uno.txt", "utf8"),\n  readFile("dos.txt", "utf8"),\n  readFile("tres.txt", "utf8"),\n])\n  .then((resultados) => {\n    console.log("Todos los archivos le\xeddos:");\n    resultados.forEach((contenido, index) => {\n      console.log(`Archivo ${index + 1}:`, contenido);\n    });\n  })\n  .catch((error) => {\n    console.error("Error leyendo archivos:", error.message);\n  });\n\n// Promise.allSettled - espera a que todas se resuelvan o rechacen\nPromise.allSettled([\n  readFile("uno.txt", "utf8"),\n  readFile("archivo-inexistente.txt", "utf8"),\n  readFile("tres.txt", "utf8"),\n]).then((resultados) => {\n  console.log("Resultados de todas las promesas:");\n  resultados.forEach((resultado, index) => {\n    if (resultado.status === "fulfilled") {\n      console.log(`Promesa ${index + 1}: \xc9xito`);\n    } else {\n      console.log(`Promesa ${index + 1}: Error -`, resultado.reason.message);\n    }\n  });\n});\n'})}),"\n",(0,a.jsx)(n.h2,{id:"asyncawait-la-evoluci\xf3n-moderna",children:"Async/Await: la evoluci\xf3n moderna"}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.code,{children:"async/await"})," es una forma moderna de trabajar con promesas que hace que el c\xf3digo as\xedncrono se lea como c\xf3digo s\xedncrono, manteniendo todas las ventajas de la asincron\xeda."]}),"\n",(0,a.jsx)(n.h3,{id:"sintaxis-b\xe1sica-de-asyncawait",children:"Sintaxis b\xe1sica de async/await"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-jsx",children:'// ejemplos/async-await-basico.js\nimport { readFile } from "fs/promises";\n\n// Funci\xf3n async siempre retorna una promesa\nasync function leerYProcesarArchivo() {\n  try {\n    // await pausa la ejecuci\xf3n hasta que la promesa se resuelve\n    const datos = await readFile("ejemplo.txt", "utf8");\n    console.log("Contenido del archivo:", datos);\n\n    // Puedes usar m\xfaltiples await en secuencia\n    const longitud = datos.length;\n    console.log("Longitud del contenido:", longitud);\n\n    return datos; // Se convierte autom\xe1ticamente en promesa resuelta\n  } catch (error) {\n    console.error("Error al leer el archivo:", error.message);\n    throw error; // Propaga el error\n  }\n}\n\n// Uso de la funci\xf3n async\nleerYProcesarArchivo()\n  .then((resultado) => {\n    console.log("Proceso completado con resultado:", resultado);\n  })\n  .catch((error) => {\n    console.error("Error en el proceso:", error.message);\n  });\n'})}),"\n",(0,a.jsx)(n.h3,{id:"m\xfaltiples-operaciones-con-asyncawait",children:"M\xfaltiples operaciones con async/await"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-jsx",children:'// ejemplos/async-await-avanzado.js\nimport { readFile, writeFile, access } from "fs/promises";\n\nasync function procesarMultiplesArchivos() {\n  try {\n    console.log("Iniciando procesamiento de archivos...");\n\n    // Operaciones secuenciales\n    const archivo1 = await readFile("uno.txt", "utf8");\n    const archivo2 = await readFile("dos.txt", "utf8");\n\n    console.log("Archivo 1:", archivo1);\n    console.log("Archivo 2:", archivo2);\n\n    // Combinar contenido\n    const contenidoCombinado = archivo1 + "\\\\n" + archivo2;\n\n    // Guardar resultado\n    await writeFile("combinado.txt", contenidoCombinado);\n    console.log("Archivos combinados y guardados exitosamente");\n\n    return {\n      archivo1: archivo1.length,\n      archivo2: archivo2.length,\n      combinado: contenidoCombinado.length,\n    };\n  } catch (error) {\n    console.error("Error en el procesamiento:", error.message);\n    throw error;\n  }\n}\n\n// Ejecutar la funci\xf3n\nprocesarMultiplesArchivos()\n  .then((estadisticas) => {\n    console.log("Estad\xedsticas del proceso:", estadisticas);\n  })\n  .catch((error) => {\n    console.error("Error general:", error.message);\n  });\n'})}),"\n",(0,a.jsx)(n.h3,{id:"operaciones-paralelas-con-asyncawait",children:"Operaciones paralelas con async/await"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-jsx",children:'// ejemplos/async-await-paralelo.js\nimport { readFile } from "fs/promises";\n\nasync function leerArchivosEnParalelo() {\n  try {\n    console.log("Leyendo archivos en paralelo...");\n\n    // Iniciar todas las operaciones simult\xe1neamente\n    const promesaUno = readFile("uno.txt", "utf8");\n    const promesaDos = readFile("dos.txt", "utf8");\n    const promesaTres = readFile("tres.txt", "utf8");\n\n    // Esperar a que todas terminen\n    const [contenidoUno, contenidoDos, contenidoTres] = await Promise.all([\n      promesaUno,\n      promesaDos,\n      promesaTres,\n    ]);\n\n    console.log("Todos los archivos le\xeddos exitosamente");\n    console.log("Uno:", contenidoUno);\n    console.log("Dos:", contenidoDos);\n    console.log("Tres:", contenidoTres);\n\n    return {\n      uno: contenidoUno,\n      dos: contenidoDos,\n      tres: contenidoTres,\n    };\n  } catch (error) {\n    console.error("Error leyendo archivos en paralelo:", error.message);\n    throw error;\n  }\n}\n\nleerArchivosEnParalelo();\n'})}),"\n",(0,a.jsx)(n.h2,{id:"c\xf3mo-funciona-el-event-loop-en-nodejs",children:"\xbfC\xf3mo funciona el Event Loop en Node.js?"}),"\n",(0,a.jsxs)(n.p,{children:['Node.js no ejecuta varias operaciones "a la vez" como lo har\xeda un lenguaje multihilo. En su lugar, utiliza un \xfanico hilo que sigue un ciclo de eventos llamado ',(0,a.jsx)(n.strong,{children:"Event Loop"}),". Este sistema es extremadamente eficiente para operaciones I/O."]}),"\n",(0,a.jsx)(n.h3,{id:"fases-del-event-loop",children:"Fases del Event Loop:"}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Timers"}),": Ejecuta callbacks de ",(0,a.jsx)(n.code,{children:"setTimeout()"})," y ",(0,a.jsx)(n.code,{children:"setInterval()"})]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Pending Callbacks"}),": Ejecuta callbacks de operaciones del sistema"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Poll"}),": Recupera nuevos eventos I/O y ejecuta sus callbacks"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Check"}),": Ejecuta callbacks de ",(0,a.jsx)(n.code,{children:"setImmediate()"})]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Close"}),": Ejecuta callbacks de eventos 'close'"]}),"\n"]}),"\n",(0,a.jsx)(n.h3,{id:"ejemplo-pr\xe1ctico-del-event-loop",children:"Ejemplo pr\xe1ctico del Event Loop"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-jsx",children:'// ejemplos/event-loop-demo.js\nimport { readFile } from "fs/promises";\n\nconsole.log("1. Inicio del script");\n\nsetTimeout(() => {\n  console.log("3. Timeout ejecutado");\n}, 0);\n\nPromise.resolve().then(() => {\n  console.log("4. Microtarea de promesa");\n});\n\nreadFile("ejemplo.txt", "utf8").then(() => {\n  console.log("5. Archivo le\xeddo (operaci\xf3n I/O)");\n});\n\nconsole.log("2. Fin del script sincr\xf3nico");\n\n// Salida esperada:\n// 1. Inicio del script\n// 2. Fin del script sincr\xf3nico\n// 4. Microtarea de promesa\n// 3. Timeout ejecutado\n// 5. Archivo le\xeddo (operaci\xf3n I/O)\n'})}),"\n",(0,a.jsx)(n.h2,{id:"ejercicio-pr\xe1ctico-gestor-de-archivos-as\xedncrono",children:"Ejercicio pr\xe1ctico: Gestor de archivos as\xedncrono"}),"\n",(0,a.jsx)(n.p,{children:"Vamos a crear un gestor de archivos que demuestre todos los conceptos aprendidos:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-jsx",children:'// ejercicios/gestor-archivos.js\nimport { readFile, writeFile, readdir, stat } from "fs/promises";\nimport { join } from "path";\n\nclass GestorArchivos {\n  constructor(directorio) {\n    this.directorio = directorio;\n  }\n\n  // Listar archivos con informaci\xf3n de tama\xf1o\n  async listarArchivos() {\n    try {\n      const archivos = await readdir(this.directorio);\n\n      const infoArchivos = await Promise.all(\n        archivos.map(async (archivo) => {\n          const rutaCompleta = join(this.directorio, archivo);\n          const info = await stat(rutaCompleta);\n\n          return {\n            nombre: archivo,\n            tama\xf1o: info.size,\n            esDirectorio: info.isDirectory(),\n            modificado: info.mtime,\n          };\n        })\n      );\n\n      return infoArchivos;\n    } catch (error) {\n      throw new Error(`Error listando archivos: ${error.message}`);\n    }\n  }\n\n  // Leer y procesar m\xfaltiples archivos\n  async procesarArchivos(extension = ".txt") {\n    try {\n      const archivos = await this.listarArchivos();\n      const archivosTexto = archivos.filter(\n        (archivo) => archivo.nombre.endsWith(extension) && !archivo.esDirectorio\n      );\n\n      console.log(\n        `Procesando ${archivosTexto.length} archivos ${extension}...`\n      );\n\n      const contenidos = await Promise.all(\n        archivosTexto.map(async (archivo) => {\n          const rutaCompleta = join(this.directorio, archivo.nombre);\n          const contenido = await readFile(rutaCompleta, "utf8");\n\n          return {\n            nombre: archivo.nombre,\n            contenido: contenido,\n            lineas: contenido.split("\\\\n").length,\n            palabras: contenido.split(/\\\\s+/).length,\n          };\n        })\n      );\n\n      // Generar reporte\n      const reporte = {\n        totalArchivos: contenidos.length,\n        totalLineas: contenidos.reduce(\n          (sum, archivo) => sum + archivo.lineas,\n          0\n        ),\n        totalPalabras: contenidos.reduce(\n          (sum, archivo) => sum + archivo.palabras,\n          0\n        ),\n        archivos: contenidos,\n      };\n\n      // Guardar reporte\n      await writeFile(\n        join(this.directorio, "reporte.json"),\n        JSON.stringify(reporte, null, 2)\n      );\n\n      return reporte;\n    } catch (error) {\n      throw new Error(`Error procesando archivos: ${error.message}`);\n    }\n  }\n}\n\n// Uso del gestor de archivos\nasync function main() {\n  const gestor = new GestorArchivos("./archivos-ejemplo");\n\n  try {\n    console.log("=== GESTOR DE ARCHIVOS AS\xcdNCRONO ===");\n\n    const archivos = await gestor.listarArchivos();\n    console.log("Archivos encontrados:", archivos.length);\n\n    const reporte = await gestor.procesarArchivos(".txt");\n    console.log("Reporte generado:");\n    console.log("- Total archivos:", reporte.totalArchivos);\n    console.log("- Total l\xedneas:", reporte.totalLineas);\n    console.log("- Total palabras:", reporte.totalPalabras);\n\n    console.log("Reporte guardado en reporte.json");\n  } catch (error) {\n    console.error("Error en la aplicaci\xf3n:", error.message);\n  }\n}\n\n// Ejecutar la aplicaci\xf3n\nmain();\n'})}),"\n",(0,a.jsx)(n.h2,{id:"patrones-avanzados-y-mejores-pr\xe1cticas",children:"Patrones avanzados y mejores pr\xe1cticas"}),"\n",(0,a.jsx)(n.h3,{id:"1-manejo-robusto-de-errores",children:"1. Manejo robusto de errores"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-jsx",children:'// ejemplos/manejo-errores.js\nimport { readFile } from "fs/promises";\n\nasync function leerConReintentos(rutaArchivo, reintentos = 3) {\n  for (let intento = 1; intento <= reintentos; intento++) {\n    try {\n      const contenido = await readFile(rutaArchivo, "utf8");\n      return contenido;\n    } catch (error) {\n      if (intento === reintentos) {\n        throw new Error(\n          `Fall\xf3 despu\xe9s de ${reintentos} intentos: ${error.message}`\n        );\n      }\n      console.log(`Intento ${intento} fall\xf3, reintentando...`);\n      // Esperar antes del reintento\n      await new Promise((resolve) => setTimeout(resolve, 1000 * intento));\n    }\n  }\n}\n\n// Uso con manejo de errores espec\xedfico\nleerConReintentos("archivo-importante.txt")\n  .then((contenido) => console.log("\xc9xito:", contenido))\n  .catch((error) => console.error("Error cr\xedtico:", error.message));\n'})}),"\n",(0,a.jsx)(n.h3,{id:"2-limitaci\xf3n-de-operaciones-concurrentes",children:"2. Limitaci\xf3n de operaciones concurrentes"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-jsx",children:'// ejemplos/limitacion-concurrencia.js\nclass LimitadorConcurrencia {\n  constructor(maximoConcurrente) {\n    this.maximoConcurrente = maximoConcurrente;\n    this.cola = [];\n    this.ejecutando = 0;\n  }\n\n  async ejecutar(operacion) {\n    return new Promise((resolve, reject) => {\n      this.cola.push({ operacion, resolve, reject });\n      this.ejecutarSiguiente();\n    });\n  }\n\n  ejecutarSiguiente() {\n    if (this.ejecutando >= this.maximoConcurrente || this.cola.length === 0) {\n      return;\n    }\n\n    const { operacion, resolve, reject } = this.cola.shift();\n    this.ejecutando++;\n\n    Promise.resolve(operacion())\n      .then(resolve)\n      .catch(reject)\n      .finally(() => {\n        this.ejecutando--;\n        this.ejecutarSiguiente();\n      });\n  }\n}\n\n// Uso del limitador\nconst limitador = new LimitadorConcurrencia(2);\n\nasync function tareaSimulada(id, duracion) {\n  console.log(`Iniciando tarea ${id}`);\n  await new Promise((resolve) => setTimeout(resolve, duracion));\n  console.log(`Completando tarea ${id}`);\n  return `Resultado-${id}`;\n}\n\n// Ejecutar m\xfaltiples tareas con limitaci\xf3n\nPromise.all([\n  limitador.ejecutar(() => tareaSimulada(1, 1000)),\n  limitador.ejecutar(() => tareaSimulada(2, 500)),\n  limitador.ejecutar(() => tareaSimulada(3, 800)),\n  limitador.ejecutar(() => tareaSimulada(4, 300)),\n]).then((resultados) => {\n  console.log("Todas las tareas completadas:", resultados);\n});\n'})}),"\n",(0,a.jsx)(n.h2,{id:"conclusi\xf3n-del-m\xf3dulo",children:"Conclusi\xf3n del m\xf3dulo"}),"\n",(0,a.jsx)(n.p,{children:"Has aprendido la evoluci\xf3n completa de la asincron\xeda en Node.js, desde los callbacks b\xe1sicos hasta los patrones modernos con async/await. Comprendes c\xf3mo Node.js maneja operaciones no bloqueantes a trav\xe9s del Event Loop y c\xf3mo escribir c\xf3digo as\xedncrono eficiente y mantenible."}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Puntos clave recordatorios:"})}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:["Usa ",(0,a.jsx)(n.strong,{children:"async/await"})," para c\xf3digo m\xe1s legible"]}),"\n",(0,a.jsxs)(n.li,{children:["Aprovecha ",(0,a.jsx)(n.strong,{children:"Promise.all"})," para operaciones paralelas"]}),"\n",(0,a.jsxs)(n.li,{children:["Implementa ",(0,a.jsx)(n.strong,{children:"manejo robusto de errores"})," con try/catch"]}),"\n",(0,a.jsxs)(n.li,{children:["Considera ",(0,a.jsx)(n.strong,{children:"limitaci\xf3n de concurrencia"})," para operaciones masivas"]}),"\n",(0,a.jsxs)(n.li,{children:["Entiende el ",(0,a.jsx)(n.strong,{children:"Event Loop"})," para optimizar el rendimiento"]}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"recursos-complementarios",children:"Recursos complementarios"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.a,{href:"https://nodejs.org/en/docs/guides/event-loop-timers-and-nexttick/",children:"Documentaci\xf3n oficial de Node.js sobre Event Loop"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.a,{href:"https://developer.mozilla.org/es/docs/Web/JavaScript/Reference/Statements/async_function",children:"MDN Web Docs: async function"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.a,{href:"https://developer.mozilla.org/es/docs/Web/JavaScript/Reference/Global_Objects/Promise",children:"MDN Web Docs: Promise"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.a,{href:"https://dev.to/lydiahallie/javascript-visualized-event-loop-3dif",children:"Art\xedculo: JavaScript Visualized - Event Loop"})}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:"Este conocimiento te prepara para construir aplicaciones Node.js escalables y eficientes, capaces de manejar m\xfaltiples operaciones I/O sin bloquear el hilo principal."})]})}function u(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(d,{...e})}):d(e)}},8453:(e,n,o)=>{o.d(n,{R:()=>i,x:()=>c});var r=o(6540);const a={},s=r.createContext(a);function i(e){const n=r.useContext(s);return r.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:i(e.components),r.createElement(s.Provider,{value:n},e.children)}}}]);