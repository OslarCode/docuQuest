"use strict";(globalThis.webpackChunkDocuQuest_oslar_code=globalThis.webpackChunkDocuQuest_oslar_code||[]).push([[1860],{8453:(e,r,n)=>{n.d(r,{R:()=>c,x:()=>i});var a=n(6540);const o={},s=a.createContext(o);function c(e){const r=a.useContext(s);return a.useMemo(function(){return"function"==typeof e?e(r):{...r,...e}},[r,e])}function i(e){let r;return r=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:c(e.components),a.createElement(s.Provider,{value:r},e.children)}},9589:(e,r,n)=>{n.r(r),n.d(r,{assets:()=>l,contentTitle:()=>i,default:()=>m,frontMatter:()=>c,metadata:()=>a,toc:()=>d});const a=JSON.parse('{"id":"frontend/poo/herencia&polimorfismo","title":"Herencia y polimorfismo en JavaScript","description":"En este m\xf3dulo, profundizaremos en los conceptos de Herencia y Polimorfismo en JavaScript, fundamentales en la Programaci\xf3n Orientada a Objetos (POO). Estos principios permiten crear estructuras de c\xf3digo m\xe1s organizadas, reutilizables y escalables.\ue206","source":"@site/docs/frontend/poo/herencia&polimorfismo.md","sourceDirName":"frontend/poo","slug":"/frontend/poo/herencia&polimorfismo","permalink":"/docuQuest/docs/frontend/poo/herencia&polimorfismo","draft":false,"unlisted":false,"editUrl":"https://github.com/OslarCode/OslarCode/docs/frontend/poo/herencia&polimorfismo.md","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Clases y m\xe9todos en JavaScript (ES6+)","permalink":"/docuQuest/docs/frontend/poo/clases&metodos"},"next":{"title":"POO aplicada al desarrollo web con JavaScript","permalink":"/docuQuest/docs/frontend/poo/POOAplicada"}}');var o=n(4848),s=n(8453);const c={},i="Herencia y polimorfismo en JavaScript",l={},d=[{value:"Herencia en JavaScript",id:"herencia-en-javascript",level:2},{value:"Uso de <code>extends</code> para herencia de clases",id:"uso-de-extends-para-herencia-de-clases",level:3},{value:"Llamado al constructor padre con <code>super()</code>",id:"llamado-al-constructor-padre-con-super",level:3},{value:"Sobreescritura de m\xe9todos",id:"sobreescritura-de-m\xe9todos",level:3},{value:"Polimorfismo en JavaScript",id:"polimorfismo-en-javascript",level:2},{value:"M\xe9todos sobrescritos (method overriding)",id:"m\xe9todos-sobrescritos-method-overriding",level:3},{value:"Uso de clases abstractas (simulaci\xf3n)",id:"uso-de-clases-abstractas-simulaci\xf3n",level:3}];function t(e){const r={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",p:"p",pre:"pre",strong:"strong",...(0,s.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(r.header,{children:(0,o.jsx)(r.h1,{id:"herencia-y-polimorfismo-en-javascript",children:"Herencia y polimorfismo en JavaScript"})}),"\n",(0,o.jsxs)(r.p,{children:["En este m\xf3dulo, profundizaremos en los conceptos de ",(0,o.jsx)(r.strong,{children:"Herencia y Polimorfismo en JavaScript"}),", fundamentales en la Programaci\xf3n Orientada a Objetos (POO). Estos principios permiten crear estructuras de c\xf3digo m\xe1s organizadas, reutilizables y escalables.\ue206"]}),"\n",(0,o.jsx)(r.h2,{id:"herencia-en-javascript",children:"Herencia en JavaScript"}),"\n",(0,o.jsxs)(r.p,{children:["La ",(0,o.jsx)(r.strong,{children:"herencia"})," es un mecanismo que permite a una clase derivar propiedades y m\xe9todos de otra clase. En JavaScript, a partir de ECMAScript 6 (ES6), se introdujo la sintaxis de clases que facilita la implementaci\xf3n de la herencia."]}),"\n",(0,o.jsxs)(r.h3,{id:"uso-de-extends-para-herencia-de-clases",children:["Uso de ",(0,o.jsx)(r.code,{children:"extends"})," para herencia de clases"]}),"\n",(0,o.jsxs)(r.p,{children:["La palabra clave ",(0,o.jsx)(r.code,{children:"extends"})," se utiliza para crear una clase que hereda de otra. Esto establece una relaci\xf3n de prototipo entre la clase hija y la clase padre."]}),"\n",(0,o.jsx)(r.p,{children:(0,o.jsx)(r.strong,{children:"Ejemplo:"})}),"\n",(0,o.jsx)(r.pre,{children:(0,o.jsx)(r.code,{className:"language-jsx",children:'class Animal {\r\n  constructor(nombre) {\r\n    this.nombre = nombre;\r\n  }\r\n\r\n  hacerSonido() {\r\n    console.log(`${this.nombre} hace un sonido.`);\r\n  }\r\n}\r\n\r\nclass Perro extends Animal {\r\n  constructor(nombre, raza) {\r\n    super(nombre);\r\n    this.raza = raza;\r\n  }\r\n\r\n  ladrar() {\r\n    console.log(`${this.nombre} ladra.`);\r\n  }\r\n}\r\n\r\nconst miPerro = new Perro("Rex", "Labrador");\r\nmiPerro.hacerSonido(); // Rex hace un sonido.\r\nmiPerro.ladrar(); // Rex ladra.\n'})}),"\n",(0,o.jsxs)(r.p,{children:["En este ejemplo, ",(0,o.jsx)(r.code,{children:"Perro"})," hereda de ",(0,o.jsx)(r.code,{children:"Animal"}),", adquiriendo sus propiedades y m\xe9todos. Adem\xe1s, ",(0,o.jsx)(r.code,{children:"Perro"})," a\xf1ade el m\xe9todo ",(0,o.jsx)(r.code,{children:"ladrar"}),"."]}),"\n",(0,o.jsxs)(r.h3,{id:"llamado-al-constructor-padre-con-super",children:["Llamado al constructor padre con ",(0,o.jsx)(r.code,{children:"super()"})]}),"\n",(0,o.jsxs)(r.p,{children:["Dentro del constructor de la clase hija, es necesario llamar a ",(0,o.jsx)(r.code,{children:"super()"})," para invocar el constructor de la clase padre. Esto asegura que las propiedades heredadas sean inicializadas correctamente."]}),"\n",(0,o.jsx)(r.p,{children:(0,o.jsx)(r.strong,{children:"Ejemplo:"})}),"\n",(0,o.jsx)(r.pre,{children:(0,o.jsx)(r.code,{className:"language-jsx",children:'class Vehiculo {\r\n  constructor(marca) {\r\n    this.marca = marca;\r\n  }\r\n}\r\n\r\nclass Coche extends Vehiculo {\r\n  constructor(marca, modelo) {\r\n    super(marca);\r\n    this.modelo = modelo;\r\n  }\r\n}\r\n\r\nconst miCoche = new Coche("Toyota", "Corolla");\r\nconsole.log(miCoche.marca); // Toyota\r\nconsole.log(miCoche.modelo); // Corolla\n'})}),"\n",(0,o.jsxs)(r.p,{children:["Aqu\xed, ",(0,o.jsx)(r.code,{children:"Coche"})," llama a ",(0,o.jsx)(r.code,{children:"super(marca)"})," para inicializar la propiedad ",(0,o.jsx)(r.code,{children:"marca"})," definida en ",(0,o.jsx)(r.code,{children:"Vehiculo"}),"."]}),"\n",(0,o.jsx)(r.h3,{id:"sobreescritura-de-m\xe9todos",children:"Sobreescritura de m\xe9todos"}),"\n",(0,o.jsxs)(r.p,{children:["La ",(0,o.jsx)(r.strong,{children:"sobreescritura de m\xe9todos"})," permite que una clase hija proporcione una implementaci\xf3n espec\xedfica de un m\xe9todo que ya est\xe1 definido en su clase padre."]}),"\n",(0,o.jsx)(r.p,{children:(0,o.jsx)(r.strong,{children:"Ejemplo:"})}),"\n",(0,o.jsx)(r.pre,{children:(0,o.jsx)(r.code,{className:"language-jsx",children:'class Animal {\r\n  hacerSonido() {\r\n    console.log("Sonido gen\xe9rico de animal.");\r\n  }\r\n}\r\n\r\nclass Gato extends Animal {\r\n  hacerSonido() {\r\n    console.log("El gato ma\xfalla.");\r\n  }\r\n}\r\n\r\nconst miGato = new Gato();\r\nmiGato.hacerSonido(); // El gato ma\xfalla.\n'})}),"\n",(0,o.jsxs)(r.p,{children:["En este caso, ",(0,o.jsx)(r.code,{children:"Gato"})," sobrescribe el m\xe9todo ",(0,o.jsx)(r.code,{children:"hacerSonido"})," de ",(0,o.jsx)(r.code,{children:"Animal"})," para proporcionar su propia implementaci\xf3n."]}),"\n",(0,o.jsx)(r.hr,{}),"\n",(0,o.jsx)(r.h2,{id:"polimorfismo-en-javascript",children:"Polimorfismo en JavaScript"}),"\n",(0,o.jsxs)(r.p,{children:["El ",(0,o.jsx)(r.strong,{children:"polimorfismo"})," es la capacidad de diferentes clases para ser tratadas como instancias de la misma clase a trav\xe9s de una interfaz com\xfan. Esto permite que m\xe9todos con el mismo nombre act\xfaen de manera diferente seg\xfan la clase que los implemente."]}),"\n",(0,o.jsx)(r.h3,{id:"m\xe9todos-sobrescritos-method-overriding",children:"M\xe9todos sobrescritos (method overriding)"}),"\n",(0,o.jsx)(r.p,{children:"Como se mostr\xf3 anteriormente, las clases hijas pueden sobrescribir m\xe9todos de sus clases padres para proporcionar comportamientos espec\xedficos."}),"\n",(0,o.jsx)(r.p,{children:(0,o.jsx)(r.strong,{children:"Ejemplo adicional:"})}),"\n",(0,o.jsx)(r.pre,{children:(0,o.jsx)(r.code,{className:"language-jsx",children:'class Ave {\r\n  volar() {\r\n    console.log("El ave vuela.");\r\n  }\r\n}\r\n\r\nclass Pinguino extends Ave {\r\n  volar() {\r\n    console.log("El ping\xfcino no puede volar.");\r\n  }\r\n}\r\n\r\nconst miAve = new Ave();\r\nconst miPinguino = new Pinguino();\r\n\r\nmiAve.volar(); // El ave vuela.\r\nmiPinguino.volar(); // El ping\xfcino no puede volar.\n'})}),"\n",(0,o.jsxs)(r.p,{children:["Aqu\xed, aunque ",(0,o.jsx)(r.code,{children:"Pinguino"})," es una subclase de ",(0,o.jsx)(r.code,{children:"Ave"}),", sobrescribe el m\xe9todo ",(0,o.jsx)(r.code,{children:"volar"})," para reflejar su incapacidad para volar."]}),"\n",(0,o.jsx)(r.h3,{id:"uso-de-clases-abstractas-simulaci\xf3n",children:"Uso de clases abstractas (simulaci\xf3n)"}),"\n",(0,o.jsxs)(r.p,{children:["JavaScript no tiene soporte nativo para ",(0,o.jsx)(r.strong,{children:"clases abstractas"}),", pero podemos simular este comportamiento lanzando errores en m\xe9todos que deben ser implementados por las clases derivadas."]}),"\n",(0,o.jsx)(r.p,{children:(0,o.jsx)(r.strong,{children:"Ejemplo:"})}),"\n",(0,o.jsx)(r.pre,{children:(0,o.jsx)(r.code,{className:"language-jsx",children:'class Figura {\r\n  constructor() {\r\n    if (new.target === Figura) {\r\n      throw new Error("No se puede instanciar una clase abstracta.");\r\n    }\r\n  }\r\n\r\n  calcularArea() {\r\n    throw new Error("El m\xe9todo calcularArea() debe ser implementado.");\r\n  }\r\n}\r\n\r\nclass Circulo extends Figura {\r\n  constructor(radio) {\r\n    super();\r\n    this.radio = radio;\r\n  }\r\n\r\n  calcularArea() {\r\n    return Math.PI * this.radio ** 2;\r\n  }\r\n}\r\n\r\nconst miCirculo = new Circulo(5);\r\nconsole.log(miCirculo.calcularArea()); // 78.53981633974483\r\n\r\nconst miFigura = new Figura(); // Error: No se puede instanciar una clase abstracta.\n'})}),"\n",(0,o.jsxs)(r.p,{children:["En este ejemplo, ",(0,o.jsx)(r.code,{children:"Figura"})," act\xfaa como una clase abstracta. Intentar instanciar ",(0,o.jsx)(r.code,{children:"Figura"})," directamente lanza un error, y cualquier subclase debe implementar el m\xe9todo ",(0,o.jsx)(r.code,{children:"calcularArea"}),"."]}),"\n",(0,o.jsx)(r.hr,{}),"\n",(0,o.jsxs)(r.p,{children:["Comprender y aplicar ",(0,o.jsx)(r.strong,{children:"herencia"})," y ",(0,o.jsx)(r.strong,{children:"polimorfismo"})," en JavaScript es esencial para desarrollar aplicaciones robustas y mantenibles. Estos conceptos permiten estructurar el c\xf3digo de manera que sea f\xe1cil de extender y reutilizar, facilitando la colaboraci\xf3n y el crecimiento del proyecto."]})]})}function m(e={}){const{wrapper:r}={...(0,s.R)(),...e.components};return r?(0,o.jsx)(r,{...e,children:(0,o.jsx)(t,{...e})}):t(e)}}}]);